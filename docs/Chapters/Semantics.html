<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="ToC.html">目錄</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction">0.3 抽象化</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:correctness">0.5 正確性</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:relevant-information">0.7 相關資料</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:evaluation">1.1 值與求值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:function-defns">1.2 函數定義</a></li><li class="pure-menu-item"><a href="Basics.html#sec:higher-order-func">1.3 高階函數</a></li><li class="pure-menu-item"><a href="Basics.html#sec:func-comp">1.4 函數合成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:boolean">1.6.1 布林值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:char">1.6.2 字元</a></li><li class="pure-menu-item"><a href="Basics.html#sec:pairs">1.6.3 序對</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:weak-head-normal-form">1.7 弱首範式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:list-deconstruct">1.8.1 串列解構</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-generation">1.8.2 串列生成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:wholemeal">1.9 全麥編程</a></li><li class="pure-menu-item"><a href="Basics.html#sec:user-defined-data">1.10 自訂資料型別</a></li><li class="pure-menu-item"><a href="Basics.html#sec:refs-basics">1.11 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:math-induction">2.1 數學歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li><li class="pure-menu-item"><a href="Induction.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:list-segments">2.6.3 串列區段</a></li><li class="pure-menu-item"><a href="Induction.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li><li class="pure-menu-item"><a href="Induction.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li><li class="pure-menu-item"><a href="Induction.html#sec:complete-induction">2.11 完全歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:well-founded-induction">2.12 良基歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:mutual-induction">2.14 交互歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-ref">2.15 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.1 紅黑樹插入</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.2 紅黑樹之性質：高度</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.3 紅黑樹之性質：平衡</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.4 紅黑樹之性質：顏色</a></li></ul></li></ul></li><li class="pure-menu-selected pure-menu-item"><a href="#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" checked type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics.html#sec:denotational-semantics">4.1 指稱語意</a></li><li class="pure-menu-item"><a href="Semantics.html#sec:operational-semantics">4.2 操作語意</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:efficiency-basics">5.2 關於執行效率</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:var-cons">5.4 變數換常數</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:steep">5.5.1 陡串列</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion">5.6.3 尾遞迴</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:difference-list">5.6.6 函數作為串列</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li><li class="pure-menu-item"><a href="Folds.html#sec:scan-lemma">6.2.3 掃描</a></li><li class="pure-menu-item"><a href="Folds.html#sec:banana-split">6.2.4 香蕉船定理</a></li><li class="pure-menu-item"><a href="Folds.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li><li class="pure-menu-item"><a href="Folds.html#sec:bring-in-context">6.2.6 引入脈絡</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldl">6.3.1 左摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:list-homomorphism">6.3.2 串列同構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldN">6.4 自然數的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:folds-ref">6.6 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-segment-sum">7.1 最大區段和</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:segProblems-ref">7.3 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:exceptions">8.1 例外處理</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-class-laws">8.2 單子與單子律</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:var-env-reader">8.3.1 變數與環境</a></li><li class="pure-menu-item"><a href="Monads.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:hanoi">8.4.1 河內塔問題</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#">8.5 參考資料</a></li></ul></li></ul></nav><p><a href="Ix.html">索引</a></p><p><a href="Biblio.html">參考書目</a></p><p class="author-info"><a href="https://  homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div><div id="main"><div class="header"><h1 class="chapter" id="ch:semantics">4 關於語意的基本概念</h1></div><div class="content"><p>第<a href="Basics.html#ch:basics">1 </a>章介紹了函數語言的基礎概念，第<a href="Induction.html#ch:induction">2 </a>章談了歸納定義與證明。我們將運用這些知識在第<a href="Derivation.html#ch:derivation">5 </a>章之中推導一些程式、解一些編程問題。但在那之前，我們得暫緩一下，釐清一些和語意相關的概念。</p><p>語意(semantics)<span id="ix-4-1"></span>一詞由語言學中借用而來。&shy;語意學是關於字句、詞語的意思的研究。一段程式的「意思」為何？&shy;在電腦技術發展的早期這似乎不是個問題。&shy;當時，「程式語言」只是屬於某台特定型號電腦的指令集，指令的意思就如同其操作手冊所說。&shy;若有疑義，用電腦執行看看就知道了。&shy;隨著技術發展，同一個程式語言可在不同電腦上執行，各廠商、研究機構都可以實作同一語言的編譯器。&shy;同時，實用性質的程式語言也發展得更加複雜，一個程式語言中常有不太能憑直覺理解的細微處。&shy;我們因而需要有個不依賴特定硬體、特定編譯器，也可討論程式語言的「意思」的方法。&shy;不僅可作為各家實作程式語言的依據，也方便大家溝通：每當我們設計新的語言、符號，我們也常需要釐清它的語意是什麼。</p><p>描述語意的方式有許多種。本書目前為止其實在不知不覺中混用了兩種語意：指稱語意談一個程式<em>是什麼</em>，操作語意談一個程式<em>做什麼</em>。以下我們以非常粗略的方式介紹它們。</p><h2 class="section" id="sec:denotational-semantics">4.1 指稱語意</h2><p><em>指稱語意</em>(denotational semantics)<span id="ix-4-2"></span>談一個程式<em>是什麼</em>。&shy;在我們的討論範圍中，有堅實基礎、有不含糊的定義的東西只有數學物件。&shy;因此，指稱語意試圖把程式語言對應到數學物件。&shy;最簡單的指稱語意可能是基於集合論的：把型別視為集合，把程式語言中的函數視為集合論中的函數。&shy;例如，<code class="haskell">Nat</code> 便是自然數的集合；<code class="haskell">(A * B)</code> 是 <code class="haskell">A</code> 與 <code class="haskell">B</code> 的笛卡兒積：&shy;<input class="toggle" id="footnote-4-1-1" type="checkbox"/><label class="fnote-toggle" for="footnote-4-1-1">(註1) </label><span class="collapsible-footnote">在更嚴謹的說法中，我們通常用一個<em>語意函數</em>$\llbracket\_\rrbracket$將語法對應到其意義。因此我們會說 $\llbracket |A*B| \rrbracket = \llbracket |A| \rrbracket \times \llbracket |B| \rrbracket$. 此處採用較不正式的說法。</span></p><pre><code class="equation">    |(A * B)| ~&= \{ (a,b) \mid a \in |A|, b \in |B| \} \mbox{~~.}</code>    (4.1 )
</pre><p>但函數又是什麼呢？集合論中，一個型別為 <code class="haskell">A -&gt; B</code> 的函數可視為 <code class="haskell">A * B</code> 的一個子集；若 <code class="haskell">f x = y</code>，該子集中便有 <code class="haskell">(x,y)</code> 這個元素。例如，<code class="haskell">double :: Nat -&gt; Nat</code> 可表示成如下的集合：</p><pre><code class="equation">   \{(0,0), (1,1), (2,4), (3,6), (4,8) \ldots \} \mbox{~~.}</code>    (4.2 )
</pre><p>能稱為函數的集合還需滿足兩個額外條件：</p><ul><li><p>簡單性(<em>simplicity</em>): 對所有 $x \in |A|$, 該集合中僅存在一對唯一的 <code class="haskell">(x,y)</code>。意即每個輸入只對應到一個輸出。</p></li><li><p>完整性(<em>totality</em>): 對所有 $x \in |A|$, 在該集合中都存在某對 <code class="haskell">(x,y)</code>。意即值域中的每個元素都被涵蓋到。</p></li></ul><p>至於遞迴函數呢？以階層 <code class="haskell">fact</code> 為例，其定義為：</p><pre><code class="spec">fact :: Nat -&gt; Nat
fact Zero     = 1
fact (Suc n)  = (Suc n) * fact n 
</code></pre><p>我們可想成：有一個從集合到集合的函數 <code class="haskell">factF</code>，</p><pre><code class="equation">  \Varid{factF}~X ~=~ \{(|Zero|,1)\} \cup \{(|Suc n|, (|Suc n|) \times m) \mid (n,m) \in X \} \mbox{~~.}</code>    (4.3 )
</pre><p>給任何集合 <code class="haskell">X</code>，<code class="haskell">factF</code> 傳回這樣的集合：</p><ul><li><p>新集合中有 <code class="haskell">(Zero,1)</code> --- 這對應到 <code class="haskell">fact Zero = 1</code>.</p></li><li><p>對 <code class="haskell">X</code> 之中的每一個 <code class="haskell">(n,m)</code>, 新集合中有 <code class="haskell">(Suc n, (Suc n) * m)</code> --- 這對應到 <code class="haskell">fact (Suc n)  = (Suc n) * fact n</code>.</p></li></ul><p>而函數 <code class="haskell">fact</code> 的語意就是 <code class="haskell">factF</code> 唯一的定點 (fixed point).<span id="ix-4-3"></span>&shy;意即 <code class="haskell">fact</code> 是唯一滿足 <code class="haskell">fact = factF fact</code> 的集合。&shy;關於定點的較完整理論可參照第 <a href="Induction.html#sec:induction-set-theory">2.9 </a> 節。&shy;確實，<code class="haskell">fact</code> 可寫成集合如下：</p><pre><code class="spec"> fact = {(0,1),(1,1),(2,2),(3,6),(4,24)...} 
</code></pre><p>若將 <code class="haskell">fact</code> 餵給 <code class="haskell">factF</code>,</p><pre><code class="spec">   factF fact
=  {(0,1)} ∪ {(Suc n, (Suc n) * m) | (n,m) `elem` {(0,1),(1,1),(2,2),(3,6)...}}
=  {(0,1)} ∪ {(1,1),(2,2),(3,6),(4,24)...} 
</code></pre><p>我們又得到了 <code class="haskell">fact</code>. 因此 <code class="haskell">fact</code> 確實是 <code class="haskell">factF</code> 的定點。</p><p>但，要把「<code class="haskell">fact</code> 便是 <code class="haskell">factF</code> 的定點」當作 <code class="haskell">fact</code> 的定義，我們還得確定：確實只有這麼一個集合滿足 <code class="haskell">fact = factF fact</code>。&shy;讀者稍加檢查一下，即可發現確實如此 ---&shy;例如，把 <code class="haskell">fact</code> 添一項或刪一項，都會使得 <code class="haskell">factF fact</code> 不等於 <code class="haskell">fact</code>.</p><p>並不是所有從集合到集合的函數都有唯一的定點。考慮如下兩個函數：</p><div class="multicols"><div class="mcol" width="0.5\textwidth"><pre><code class="spec">g 0  = 0
g x  = g (Suc x) 
</code></pre></div><div class="mcol" width="0.5\textwidth"><pre><code class="spec">h 0  = 0
h x  = (-1) * h x 
</code></pre></div></div><p>若以類似 <code class="haskell">fact</code> 的方式試圖將它們寫成某函數的定點，我們可能寫出如下的 <code class="haskell">gF</code> 和 <code class="haskell">hF</code>:</p><pre><code class="spec">gF X  = {(0,0)} ∪ {(n,m) | (Suc n,m) `elem` X}  
hF X  = {(n,(-1*m)) | (n,m) `elem` X} 
</code></pre><p>但 <code class="haskell">gF</code> 的定點有</p><pre><code class="spec">  {(0,0),(1,1),(2,1),(3,1)...} 
  {(0,0),(1,2),(2,2),(3,2)...} 
  {(0,0),(1,10),(2,10),(3,10)...} <comment>{-"~~..."-}</comment>
</code></pre><p>等無限多個。而 <code class="haskell">hF</code> 有一個唯一定點：空集合，但空集合違反了前述的完整性要求。</p><p>如同 <code class="haskell">g</code> 和 <code class="haskell">f</code> 這樣的函數，在我們目前介紹的簡單指稱語意中是沒有定義的。&shy;它們沒有語意，在我們的語言中是不該有的存在。&shy;它們剛好也是執行起來不會終止的函數。&shy;因此，我們似乎可以猜測「有唯一定點」和「執行會終止」似乎有些關聯。&shy;但，如前所述，我們的指稱語意中沒有「執行」的觀念。&shy;那是操作語意擅長描述的。</p><p>值得一提地，指稱語意採取了一個靜態的世界觀。&shy;一個函數單純地<em>是</em>輸入與輸出的對應，沒有「執行」的觀念，沒有執行快慢的考量，也沒有預設「終止」的概念。</p><p>函數 <code class="haskell">double1 x = x + x</code> 與 <code class="haskell">double2 x = 2 * x</code> 使用不同的演算法，但它們的語意都是同一個集合，因此被視為同一個函數 --- 在語意上我們無法區分 <code class="haskell">double1</code> 與 <code class="haskell">double2</code>。</p><p>在指稱語意中，當我們說兩個函數相等，意指它們的語意是同一個集合。&shy;例如，<code class="haskell">map Suc . concat = concat . map (map (Suc))</code>, 因為兩者的語意都是下述的集合：</p><pre><code class="spec"> {([],[]), ... ([[1],[2]], [2,3]),... ([[1],[2,3]],[2,3,4]), ...} 
</code></pre><h2 class="section" id="sec:operational-semantics">4.2 操作語意</h2><p><em>操作語意</em>(operational semantics)<span id="ix-4-4"></span>談一個程式<em>做什麼</em>。&shy;在操作語意中，我們通常不談符號的「意思」是什麼。&shy;符號 <code class="haskell">Zero</code> 只代表它本身，<code class="haskell">Suc Zero</code> 也只代表它本身。&shy;操作語意著重的是一串符號如何變成另一段符號。&shy;在這個意義下，前述的 <code class="haskell">fact</code> 定義：</p><pre><code class="spec">fact :: Nat -&gt; Nat
fact Zero     = 1
fact (Suc n)  = (Suc n) * fact n 
</code></pre><p>從操作語意的觀點可被讀解成覆寫規則：看到 <code class="haskell">fact Zero</code>, 均可改寫為 <code class="haskell">1</code>; 看到 <code class="haskell">fact (Suc n)</code>, 均可改寫為 <code class="haskell">(Suc n) * fact n</code>.&shy;歸約 <code class="haskell">fact (Suc (Suc Zero))</code> 這個式子可被視為是不斷使用這兩條覆寫規則：</p><pre><code class="spec">   fact (Suc (Suc Zero))
=  (Suc (Suc Zero)) * fact (Suc Zero)
=  (Suc (Suc Zero)) * (Suc Zero) * fact Zero
=  (Suc (Suc Zero)) * (Suc Zero) * 1 
</code></pre><p>其中的每個等號都可讀解為「改寫成」。</p><p>操作語意中較容易談「執行」與「終止」的概念。&shy;改寫一個式子相當於執行它，如果已經沒有可改寫之處，也就是碰到了範式，執行便終止了。&shy;在操作語意中，兩個數值（例如 <code class="haskell">4+4</code> 與 <code class="haskell">2*4</code>）相等意謂它們可被歸約成同一個範式；&shy;兩個函數 <code class="haskell">f</code> 和 <code class="haskell">g</code> 相等則意謂對於任何 <code class="haskell">x</code>, <code class="haskell">f x</code> 與 <code class="haskell">g x</code> 都相等。</p><p>有了兩種談語意的方式，我們自然希望它們有些一致性。確實，我們有如下的定理：</p><div class="theorem" id="thm:operational-denotational"><h5 class="theorem-title">定理 4.1  </h5><p>操作語意保持指稱語意。意即，給定一個有指稱語意的算式 <code class="haskell">e</code>, 若算式 <code class="haskell">e</code> 能在零步或多步之內依據操作語意改寫成 <code class="haskell">e'</code>, 則 <code class="haskell">e</code> 與 <code class="haskell">e'</code> 的指稱語意相同。</p></div><div class="theorem" id="thm:semantics-fixedpoint"><h5 class="theorem-title">定理 4.2  </h5><p>給定一個遞迴的函數定義 <code class="haskell">f = F f</code>。若在操作語意中，該函數對所有輸入都正常終止，則在指稱語意中，<code class="haskell">f</code> 是 <code class="haskell">F</code> 的唯一定點。</p></div><p>我們在下一節會</p></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
