<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="ToC.html">目錄</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction">0.3 抽象化</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:correctness">0.5 正確性</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:relevant-information">0.7 相關資料</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:evaluation">1.1 值與求值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:function-defns">1.2 函數定義</a></li><li class="pure-menu-item"><a href="Basics.html#sec:higher-order-func">1.3 高階函數</a></li><li class="pure-menu-item"><a href="Basics.html#sec:func-comp">1.4 函數合成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:boolean">1.6.1 布林值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:char">1.6.2 字元</a></li><li class="pure-menu-item"><a href="Basics.html#sec:pairs">1.6.3 序對</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:weak-head-normal-form">1.7 弱首範式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:list-deconstruct">1.8.1 串列解構</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-generation">1.8.2 串列生成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:wholemeal">1.9 全麥編程</a></li><li class="pure-menu-item"><a href="Basics.html#sec:user-defined-data">1.10 自訂資料型別</a></li><li class="pure-menu-item"><a href="Basics.html#sec:refs-basics">1.11 參考資料</a></li></ul></li><li class="pure-menu-selected pure-menu-item"><a href="#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" checked type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:math-induction">2.1 數學歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li><li class="pure-menu-item"><a href="Induction.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:list-segments">2.6.3 串列區段</a></li><li class="pure-menu-item"><a href="Induction.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li><li class="pure-menu-item"><a href="Induction.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li><li class="pure-menu-item"><a href="Induction.html#sec:complete-induction">2.11 完全歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:well-founded-induction">2.12 良基歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:mutual-induction">2.14 交互歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-ref">2.15 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.1 紅黑樹插入</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.2 紅黑樹之性質：高度</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.3 紅黑樹之性質：平衡</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.4 紅黑樹之性質：顏色</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics.html#sec:denotational-semantics">4.1 指稱語意</a></li><li class="pure-menu-item"><a href="Semantics.html#sec:operational-semantics">4.2 操作語意</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:efficiency-basics">5.2 關於執行效率</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:var-cons">5.4 變數換常數</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:steep">5.5.1 陡串列</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion">5.6.3 尾遞迴</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:difference-list">5.6.6 函數作為串列</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li><li class="pure-menu-item"><a href="Folds.html#sec:scan-lemma">6.2.3 掃描</a></li><li class="pure-menu-item"><a href="Folds.html#sec:banana-split">6.2.4 香蕉船定理</a></li><li class="pure-menu-item"><a href="Folds.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li><li class="pure-menu-item"><a href="Folds.html#sec:bring-in-context">6.2.6 引入脈絡</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldl">6.3.1 左摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:list-homomorphism">6.3.2 串列同構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldN">6.4 自然數的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:folds-ref">6.6 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-segment-sum">7.1 最大區段和</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:segProblems-ref">7.3 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:exceptions">8.1 例外處理</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-class-laws">8.2 單子與單子律</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:var-env-reader">8.3.1 變數與環境</a></li><li class="pure-menu-item"><a href="Monads.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:hanoi">8.4.1 河內塔問題</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#">8.5 參考資料</a></li></ul></li></ul></nav><p><a href="Ix.html">索引</a></p><p><a href="Biblio.html">參考書目</a></p><p class="author-info"><a href="https://  homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div><div id="main"><div class="header"><h1 class="chapter" id="ch:induction">2 歸納定義與證明</h1></div><div class="content"><p>「全麥編程」的觀念鼓勵我們以小組件組織出大程式。&shy;但這些個別組件該如何實作呢？或著，沒有合用的組件時該怎麼辦？&shy;我們可以回到更基礎的層次，用<em>遞迴</em>(recursion)<span id="ix-2-1"></span>定義它們。&shy;「遞迴」意指一個值的定義又用到它本身，是數學中常見的定義方式。&shy;在早期的編程教材中，遞迴常被視為艱澀、難懂、進階的主題。&shy;但在函數程設中，遞迴是唯一可使程式不定次數地重複一項計算的方法。&shy;一旦跨過了門檻，遞迴其實是個很清晰、簡潔地描述事情的方式。</p><p>對於遞迴，許多初學者一方面不習慣、覺得如此構思程式很違反「直覺」，另一方面也納悶：以自己定義自己，到底是什麼意思？&shy;這兩個難處其實都談到了好問題。&shy;對於前者，我們希望發展一些引導我們構思遞迴程式的思路；希望有了這些依據，能使寫遞迴程式變得直覺而自然。&shy;關於後者，其實並非所有遞迴定義都有「意思」 --- 有些「不好」的遞迴並沒有定義出東西。我們討論遞迴的意義時必須限定在「好」的、有意義的程式上。最好有些方式確保我們寫出的遞迴定義是好的。</p><p>在本章我們將討論一種型式較單純的遞迴：<em>歸納</em>(induction)<span id="ix-2-2"></span>。&shy;對上述兩個問題，本章的回應是：先有歸納定義出的資料結構，再依附著該資料結構撰寫歸納定義的程式，是一種思考、解決程式問題的好方法，也是一種理解遞迴程式的方式。&shy;此外，依循這種方法也能確保該定義是「好」的。&shy;我們將從數學歸納法出發，發現歸納程式與數學歸納法的相似性 --- 寫程式和證明其實是很相似的活動。</p><p>本書以 Haskell 為學習工具，但在之後的幾章，我們僅使用 Haskell 的一小部分。&shy;Haskell 支援無限大的資料結構，也允許我們寫出不會終止的程式。&shy;但我們將假設所有資料結構都是有限的（除非特別指明），所有函數皆會好好終止（也就是說函數都是「<em>全函數</em>(total function)」<span id="ix-2-3"></span>--- 對每一個值，都會好好地算出一個結果，不會永遠算下去，也不會丟回一個錯誤）。這麼做的理由將在本章解釋。</p><h2 class="section" id="sec:math-induction">2.1 數學歸納法</h2><p>在討論怎麼寫程式之前，我們得先複習一下<em>數學歸納法</em> --- 晚點我們就會明白理由。&shy;回顧：<em>自然數</em><span id="ix-2-4"></span>在此指的是<code class="haskell">0, 1, 2...</code> 等所有非負整數。&shy;<input class="toggle" id="footnote-2-1-1" type="checkbox"/><label class="fnote-toggle" for="footnote-2-1-1">(註1) </label><span class="collapsible-footnote">有些數學派別的「自然數」是從 <code class="haskell">1</code> 算起的。計算科學中則通常習慣以 <code class="haskell">0</code> 起算。</span>&shy;自然數有無限多個，但每個自然數都是有限大的。&shy;自然數的型別記為 <code class="haskell">Nat</code>.&shy;若<code class="haskell">a</code>是一個型別, <code class="haskell">a</code>之上的<em>述語</em>(predicate)<span id="ix-2-5"></span>可想成型別為<code class="haskell">a -&gt; Bool</code>的函數，常用來表示某性質對某特定的<code class="haskell">a</code>是否成立。&shy;自然數上的述語便是<code class="haskell">Nat -&gt; Bool</code>。&shy;數學歸納法可用來證明某性質對所有自然數都成立：</p><blockquote><p>給定述語<code class="haskell">P :: Nat -&gt; Bool</code>. 若</p><ol><li><p><code class="haskell">P</code> 對 <code class="haskell">0</code> 成立，並且</p></li><li><p>若 <code class="haskell">P</code> 對 <code class="haskell">n</code> 成立，<code class="haskell">P</code> 對 <code class="haskell">1+n</code> 亦成立，</p></li></ol><p>我們可得知 <code class="haskell">P</code> 對所有自然數皆成立。</p></blockquote><p>為何上述的論證是對的？我們在<a href="Induction.html#sec:induction-set-theory">2.9 </a>節將提供一個解釋。但此處我們可以提供一個和程式設計較接近的理解方式。自然數可被想成如下的一個資料結構：</p><pre><code class="spec">  data Nat = Zero | Suc Nat 
</code></pre><p>這行定義有幾種讀解法，目前我們考慮其中一種 --- 該定義告訴我們：</p><ol><li><p><code class="haskell">Zero</code> 的型別是 <code class="haskell">Nat</code>;</p></li><li><p>如果 <code class="haskell">n</code> 的型別是 <code class="haskell">Nat</code>, <code class="haskell">Suc n</code> 的型別也是 <code class="haskell">Nat</code>;</p></li><li><p>此外，沒有其他型別是 <code class="haskell">Nat</code> 的東西。</p></li></ol><p>這種定義方式稱作<em>歸納定義</em>(inductive definition)。&shy;其中「沒有其他型別是 <code class="haskell">Nat</code> 的東西」一句話很重要 ---&shy;這意味著任一個自然數只可能是 <code class="haskell">Zero</code>，或是另一個自然數加一，沒有別的可能。&shy;任一個自然數都是這麼做出來的：由 <code class="haskell">Zero</code> 開始，套上<em>有限</em>個 <code class="haskell">Suc</code>。&shy;反過來說，給任意一個自然數，我們將包覆其外的 <code class="haskell">Suc</code> 一層層拆掉，在有限時間內一定會碰到 <code class="haskell">Zero</code>.&shy;有人主張將 inductive definition 翻譯為<em>迭構定義</em>，著重在從基底（此處為 <code class="haskell">Zero</code>）開始，一層層堆積上去（此處為套上 <code class="haskell">Suc</code>）的概念。</p><p>本書中，我們把自然數的 <code class="haskell">Zero</code> 寫成粗體，表明它是資料建構元；把 <code class="haskell">Suc</code> 的加號寫得小些並和 $\mathbf{1}$ 放得很近，以強調「加一」是資料建構元、是一個不可分割的動作（和我們之後將介紹的一般自然數加法<code class="haskell">(+)</code>不同）。&shy;數字 <code class="haskell">2</code> 其實是 <code class="haskell">Suc (Suc Zero)</code> 的簡寫, <code class="haskell">3</code> 其實是 <code class="haskell">Suc (Suc (Suc Zero))</code> 的簡寫。</p><p>歸納定義出的資料型別允許我們做<em>歸納證明</em>。&shy;由於 <code class="haskell">P</code> 是 <code class="haskell">Nat</code> 到 <code class="haskell">Bool</code> 的函數，「<code class="haskell">P</code> 對 <code class="haskell">0</code> 成立」可記為 <code class="haskell">P Zero</code>，「若 <code class="haskell">P</code> 對 <code class="haskell">n</code> 成立，<code class="haskell">P</code> 對 <code class="haskell">1+n</code> 亦成立」可記為 <code class="haskell">P (Suc n) &lt;== P n</code>。&shy;<input class="toggle" id="footnote-2-1-2" type="checkbox"/><label class="fnote-toggle" for="footnote-2-1-2">(註2) </label><span class="collapsible-footnote"><code class="haskell">P &lt;== Q</code> 意思是「若 <code class="haskell">Q</code> 則 <code class="haskell">P</code>」。依此順序寫，有「為證明 <code class="haskell">P</code>，我們想辦法讓 <code class="haskell">Q</code> 成立」的感覺。許多人不習慣由右到左的箭頭，但不論數學上或日常生活中，這都是常使用的論證思考方向。</span>&shy;我們假設兩者都已被證明，用它們證明 <code class="haskell">P 3</code>：</p><pre><code class="spec">     P (Suc (Suc (Suc Zero)))
&lt;==    <comment>{- 因 <code class="haskell">P (Suc n) &lt;== P n</code> -}</comment>
     P (Suc (Suc Zero))
&lt;==    <comment>{- 因 <code class="haskell">P (Suc n) &lt;== P n</code> -}</comment>
     P (Suc Zero)
&lt;==    <comment>{- 因 <code class="haskell">P (Suc n) &lt;== P n</code> -}</comment>
     P Zero 
</code></pre><p>第一步中，我們希望 <code class="haskell">P (Suc (Suc (Suc Zero)))</code> 成立，根據 <code class="haskell">P (Suc n) &lt;== P n</code>, 只要 <code class="haskell">P (Suc (Suc Zero))</code> 即可。第二步中，我們希望 <code class="haskell">P (Suc (Suc Zero))</code> 成立，同樣根據<code class="haskell">P (Suc n) &lt;== P n</code>，只要 <code class="haskell">P (Suc Zero)</code> 成立即可... 最後，只要 <code class="haskell">P Zero</code> 成立，<code class="haskell">P (Suc Zero)</code> 即成立，但 <code class="haskell">P Zero</code> 是已知的。因此我們已論證出 <code class="haskell">P 3</code> 成立！</p><p>由上述推演中，我們發現：數學歸納法的兩個前提 <code class="haskell">P Zero</code> 與 <code class="haskell">P (Suc n) &lt;== P n</code> 給了我們一個<em>對任一個自然數<code class="haskell">m</code>, 生成一個 <code class="haskell">P m</code> 之證明</em>的方法。&shy;這是由於自然數本就是一個歸納定義出的資料型別：任一個自然數 <code class="haskell">m</code> 都是有限個 <code class="haskell">Suc</code> 套在 <code class="haskell">Zero</code> 之上的結果，因此，只要反覆用 <code class="haskell">P (Suc n) &lt;== P n</code> 拆，總有碰到 <code class="haskell">P Zero</code> 的一天。&shy;既然對任何 <code class="haskell">m</code>, 都做得出一個 <code class="haskell">P m</code> 的證明，我們就可安心相信 <code class="haskell">P</code> 對任何自然數都成立了。</p><p>為了之後討論方便，我們將前述的數學歸納法寫得更形式化些：</p><pre><code class="equation" id="eq:induction-on-Nat" title="自然數上之歸納法：">|(forall n . P n)  &lt;==   P Zero ⋀ (forall n . P (Suc n) &lt;== P n) |</code>    (2.1 )
</pre><p>這只是把之前的文字描述改寫成二階邏輯，但可清楚看出：給定 <code class="haskell">P</code>, 我們希望證明它對所有自然數都成立，只需要提供 <code class="haskell">P Zero</code> 和 <code class="haskell">P (Suc n) &lt;== P n</code> 兩個證明。&shy;其中 <code class="haskell">P Zero</code> 是確定 <code class="haskell">P</code> 對 <code class="haskell">0</code> 成立的<em>基底</em> (base case)，<span id="ix-2-6"></span>&shy;<code class="haskell">P (Suc n) &lt;== P n</code> 則被稱作<em>歸納步驟</em>(inductive step)：<span id="ix-2-7"></span>&shy;在<em>假設 <code class="haskell">P n</code> 成立的前提下，想辦法「多做一步」，論證 <code class="haskell">P (Suc n)</code> 也成立</em>。餘下的就可交給數學歸納法這個架構了。</p><h2 class="section" id="sec:induction-on-Nat">2.2 自然數上之歸納定義</h2><p>數學歸納法和編程有什麼關係呢？考慮一個例子：給定 <code class="haskell">b, n :: Nat</code>, 我們希望寫個函數 <code class="haskell">exp</code> 計算乘冪，使得 <code class="haskell">exp b n = {-"\Varid{b}^{\Varid{n}}"-}</code>. 我們先把型別寫下：</p><pre><code class="spec">exp :: Nat -&gt; Nat -&gt; Nat
exp b n = ?
</code></pre><p>問號部分該怎麼寫？沒有其他線索很難進行，因此我們回想：<code class="haskell">n</code> 是自然數，而任何自然數只可能是 <code class="haskell">Zero</code> 或 <code class="haskell">Suc</code> 做出的。我們便分成這兩個狀況考慮吧：</p><pre><code class="spec">exp :: Nat -&gt; Nat -&gt; Nat
exp b Zero     = ?
exp b (Suc n)  = ?
</code></pre><p>其中，<code class="haskell">exp b Zero</code> 較簡單：顯然應該是 $\Varid{b}^0 = 1$. 至於 <code class="haskell">exp b (Suc n)</code> 的右手邊該怎麼寫？似乎很難一步定出來。&shy;但<em>假設 <code class="haskell">exp b n</code> 已經順利算出了$\Varid{b}^{\Varid{n}}$</em>, 由於 $\Varid{b}^{1+\Varid{n}} = \Varid{b} \times \Varid{b}^{\Varid{n}}$, <code class="haskell">exp b (Suc n)</code> 與之的關係可寫成：</p><pre><code class="spec">exp b (Suc n) = b * exp b n 
</code></pre><p>如此一來我們便完成了一個計算乘冪的程式：</p><pre><code class="haskell">exp :: Nat -&gt; Nat -&gt; Nat
exp b Zero     = 1
exp b (Suc n)  = b *: exp b n 
</code></pre><div class="infobox infobox" title="Haskell v.s Math"><h5 class="infobox-title">Haskell v.s Math</h5><p>很不幸地，Haskell 並不接受<a href="Induction.html#sec:induction-on-Nat">2.2 </a>節中<code class="haskell">exp</code>的定義。</p><p>首先，Haskell 並沒有獨立的自然數型別。我們可自己定（並將其宣告為 <code class="haskell">Num</code> 類別的一員），或著直接使用 Haskell 內建的 <code class="haskell">Int</code> 型別。&shy;其次，Haskell 原本允許我們在定義的左手邊寫 <code class="haskell">exp b (n+1)</code> ，但這套稱作``<code class="haskell">n+k</code> pattern'' 的語法已在 Haskell 2010 中被移除。目前我們得將 <code class="haskell">exp</code> 寫成：</p><pre><code class="spec">exp :: Int -&gt; Int -&gt; Int
exp b 0  = 1
exp b n  = b * exp b (n-1) 
</code></pre><p><code class="haskell">n+k</code> pattern 曾引起激烈討論。支持者主要著眼於它在教學上的方便：這方便我們討論數學歸納法、做證明、並讓我們更明顯地看出自然數與串列的相似性。&shy;反對者則批評它與 type class 的衝突。後來由反方勝出。</p><p>有些 Haskell 教科書堅持書中出現的程式碼須是能在一個字一個字地鍵入電腦後即可執行的。&shy;本書的定位並非 Haskell 教材，而是函數編程概念的入門書。&shy;為此目的，我們希望選擇適合清晰表達概念、易於操作、演算、證明的符號。&shy;而一個實用目的的語言得在許多設計上妥協尋求平衡，基於種種考量，往往得犧牲符號的簡潔與便利性（這點我們完全能理解）。&shy;因此本書中的程式語法偶爾會和 Haskell 語法有所不同。&shy;我們會盡量指明這些不同處，使讀者知道如何將本書中的程式轉換成現下的 Haskell 語法。</p></div><p>回顧一下剛剛的思路：我們難以一步登天地對任何 <code class="haskell">n</code> 寫出 <code class="haskell">exp b n</code>, 但我們提供 <code class="haskell">exp b Zero</code> 該有的值，並在假設 <code class="haskell">exp b n</code> 已算出該有的值的前提下，試著做一點加工、多算那一步，想法做出 <code class="haskell">exp b (Suc n)</code> 該有的值。&shy;這和前述的數學歸納法是一樣的！&shy;<em>寫歸納程式和做歸納證明是很類似的行為。</em>&shy;使用數學歸納法證明 <code class="haskell">P</code> 需要提供一個基底 <code class="haskell">P 0</code> 和歸納步驟 <code class="haskell">P (Suc n) &lt;== P n</code>.&shy;歸納定義程式也一樣。&shy;在 <code class="haskell">exp b n</code> 的定義中，基底是 <code class="haskell">exp b Zero</code>，歸納步驟則是由 <code class="haskell">exp b n</code> 想法變出 <code class="haskell">exp b (Suc n)</code>.&shy;有這兩個元件，我們便有了一個<em>對任何自然數 <code class="haskell">n</code>, 保證算出 <code class="haskell">exp b n</code> 的方法</em>。作為例子，我們看看 <code class="haskell">exp 2 3</code> 是怎麼被算出來的：</p><pre><code class="spec">   exp 2 (Suc (Suc (Suc Zero)))
=    <comment>{- <code class="haskell">exp</code> 之歸納步驟 -}</comment>
   2 * exp (Suc (Suc Zero))
=    <comment>{- <code class="haskell">exp</code> 之歸納步驟 -}</comment>
   2 * 2 * exp (Suc Zero)
=    <comment>{- <code class="haskell">exp</code> 之歸納步驟 -}</comment>
   2 * 2 * 2 * exp Zero
=    <comment>{- <code class="haskell">exp</code> 之基底 -}</comment>
   2 * 2 * 2 * 1 
</code></pre><p>第一步中，要算出 <code class="haskell">exp 2 (Suc (Suc (Suc Zero)))</code>, 我們得先算出 <code class="haskell">exp (Suc (Suc Zero))</code>. 要算出後者，在第二步中我們得先算出 <code class="haskell">exp (Suc Zero)</code>... 直到我們碰到 <code class="haskell">exp b Zero</code>.</p><p><b>自然數上的歸納定義</b> &emsp;&shy;我們將 <code class="haskell">b</code> 固定，稍微抽象一點地看 <code class="haskell">exp b :: Nat -&gt; Nat</code> 這個函數。該定義符合這樣的模式：</p><pre><code class="spec">f :: Nat -&gt; a
f Zero     = e
f (Suc n)  = ... f n ... 
</code></pre><p>這類函數的輸入是 <code class="haskell">Nat</code>，其定義中 <code class="haskell">f (Suc n)</code> 的狀況以 <code class="haskell">f n</code> 定出，此外沒有其他對 <code class="haskell">f</code> 的呼叫。若一個函數符合這樣的模式，我們說它是<em>在自然數上歸納定義</em>出的，其中 <code class="haskell">f Zero</code> 那條稱作其基底，<code class="haskell">f (Suc n)</code> 那條稱作其歸納步驟。我們日後將看到的許多程式都符合這個模式。</p><p>數學上，若一個函數能為其值域內的每個值都找到一個輸出，我們說它是個全函數(total function)，否則是部分函數(partial function).&shy;計算上，當我們說 <code class="haskell">f</code> 是一個全函數，意謂只要 <code class="haskell">x</code> 型別正確並可算出值，<code class="haskell">f x</code> 便能終止並算出一個值，不會永久跑下去，也不會丟出錯誤。</p><p>如前所述的、在自然數上歸納定義的 <code class="haskell">f</code> 會是全函數嗎？首先，任何自然數都可拆成 <code class="haskell">Zero</code> 或是 <code class="haskell">Suc n</code>，而這兩個情況已被 <code class="haskell">f</code> 的兩行定義涵括，不會出現漏失的錯誤。其次，<code class="haskell">f</code> 每次呼叫自己，其參數都少了一層 <code class="haskell">Suc</code>. 長此以往，不論輸入多大，總有一天會遇到基底 <code class="haskell">f Zero</code> ---&shy;因為任何自然數都是從 <code class="haskell">Zero</code> 開始，套上有限個 <code class="haskell">Suc</code>.&shy;只要基底狀況的 <code class="haskell">e</code> 以及在歸納步驟中 <code class="haskell">f n</code> 前後的計算都正常終止，對任何輸入，<code class="haskell">f</code> 都會正常終止。因此 <code class="haskell">f</code> 是個全函數。</p><p>「程式會終止」是很重要的性質，我們之後會常談到。&shy;在本書目前為止示範的編程方法中，「一個函數若呼叫自己，只能給它更小的參數」是個單純但重要的規範&shy;（例如 <code class="haskell">f (Suc n)</code> 的右手邊可以有 <code class="haskell">f n</code>, 不能有 <code class="haskell">f (Suc n)</code> 或 <code class="haskell">f (Suc (Suc n))</code>）。&shy;操作上這確保程式會終止，而在第 \todo{where?} 章之中，我們將提到這也確保該遞迴定義是「好」的、有意義的。</p><p>順便一提：在 <code class="haskell">f (Suc n)</code> 的右手邊中，<code class="haskell">f n</code> 可以出現不只一次 ---&shy;因為 <code class="haskell">... f n ... f n ...</code> 可看成&shy;<code class="haskell">(\x -&gt; ... x ...x ...) (f n)</code>.&shy;在 <code class="haskell">f n</code> 的前後 <code class="haskell">...</code> 的部分可以出現 <code class="haskell">n</code> --- 將在第頁中介紹的階層函數就是一個這樣的例子。&shy;有些情況下我們不允許 <code class="haskell">n</code> 出現在 <code class="haskell">...</code> 中，此時會額外說明。</p><p><b>乘法、加法</b> &emsp; 我們多看一些歸納定義的例子。在 <code class="haskell">exp</code> 中我們用到乘法，但假若我們的程式語言中只有加法、沒有乘法呢？我們可自己定定看：</p><pre><code class="spec">(*) :: Nat -&gt; Nat -&gt; Nat
m * n = ?
</code></pre><p>若不用組件，我們目前會的寫程式方法只有歸納法，也只有這招可試試看了。&shy;但，<code class="haskell">(*)</code> 有兩個參數，我們該把 <code class="haskell">(m *) :: Nat -&gt; Nat</code> 視為一個函數，分別考慮 <code class="haskell">n</code> 是 <code class="haskell">Zero</code> 或 <code class="haskell">Suc ...</code> 的情況，還是把&shy;<code class="haskell">(* n) :: Nat -&gt; Nat</code> 視為一個函數，考慮 <code class="haskell">m</code> 是 <code class="haskell">Zero</code> 或 <code class="haskell">Suc ...</code> 的情況？答案是兩者皆可，並無根本性的差異。只是現在我們做的選擇會影響到之後與 <code class="haskell">(*)</code> 相關的證明怎麼寫(見第<a href="Induction.html#sec:inductive-proof-on-Nat">2.3 </a>節)。本書中的習慣是拆左手邊的參數，因此我們考慮以下兩種情況。</p><pre><code class="spec">(*) :: Nat -&gt; Nat -&gt; Nat
Zero     * n  = ?
(Suc m)  * n  = ... m * n ....
</code></pre><p>基底狀況中，<code class="haskell">Zero * n</code> 的合理結果應是 <code class="haskell">Zero</code>.&shy;歸納步驟中，我們得想法算出 <code class="haskell">(Suc m) * n</code>, 但我們可假設 <code class="haskell">m * n</code> 已經算出了。&shy;稍作思考後，讀者應可同意以下的做法：</p><pre><code class="spec">(*) :: Nat -&gt; Nat -&gt; Nat
Zero     * n  = Zero
(Suc m)  * n  = n + (m * n) 
</code></pre><p>如果已有 <code class="haskell">m * n</code>，多做一個 <code class="haskell">(n+)</code>, 就可得到 <code class="haskell">(Suc m) * n</code>了。</p><p>如果我們的程式語言中連加法都沒有呢？加法可看成連續地做 <code class="haskell">Suc</code>:</p><pre><code class="spec">(+) :: Nat -&gt; Nat -&gt; Nat
Zero     + n  = n
(Suc m)  + n  = Suc (m + n) 
</code></pre><p>此處 <code class="haskell">(+)</code> 是我們定義的、可將任意兩個自然數相加的加法，而 <code class="haskell">Suc</code> 只做「加一」，是基本的資料建構元。&shy;為求一致，我們同樣在左邊的參數上做歸納。&shy;基底狀況中，<code class="haskell">Zero + n</code> 只應是 <code class="haskell">n</code>. 想計算 <code class="haskell">(Suc m) + n</code>, 先假設 <code class="haskell">m+n</code> 已經算出，再多套一個 <code class="haskell">Suc</code>. 不難看出 <code class="haskell">m + n</code> 是把 <code class="haskell">n</code> 當做基底，在外面套上 <code class="haskell">m</code> 個 <code class="haskell">Suc</code> 的結果。&shy;<input class="toggle" id="footnote-2-2-3" type="checkbox"/><label class="fnote-toggle" for="footnote-2-2-3">(註3) </label><span class="collapsible-footnote">「這樣做不是很慢嗎？」是的。本章的自然數表示法，以及其引申出的運算元都不應看作有效率的實作，而是理論工具。了解加法與乘法可這樣看待後，許多其相關性質都可依此推導出來。</span></p><h2 class="section" id="sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</h2><p>上一節中我們定出了函數 <code class="haskell">exp</code>。如果定義正確，<code class="haskell">exp b n</code> 算的應是 $\Varid{b}^\Varid{n}$.&shy;例如，我們知道 $\Varid{b}^\Varid{m+n} = \Varid{b}^\Varid{m} \times \Varid{b}^\Varid{n}$. 我們定出的函數 <code class="haskell">exp</code> 是否真有此性質呢？</p><div class="theorem" id="thm:exp-plus-times"><h5 class="theorem-title">定理 2.1  </h5><p>對任何 <code class="haskell">b, m, n :: Nat</code>, <code class="haskell">exp b (m + n) = exp b m * exp b n</code>.</p></div><p>我們試著證明定理<a href="Induction.html#thm:exp-plus-times">2.1 </a>。數學歸納法是我們目前唯一的工具，&shy;而要使用它，第一個問題是：該用 <code class="haskell">b</code>, <code class="haskell">m</code>, 或 <code class="haskell">n</code> 的哪一個來做歸納呢（意即把哪一個拆解）？</p><p>觀察定理<a href="Induction.html#thm:exp-plus-times">2.1 </a>中待證明式的等號兩邊，並參照 <code class="haskell">exp</code>, <code class="haskell">(+)</code>, 與 <code class="haskell">(*)</code>的定義。&shy;等號左手邊的 <code class="haskell">exp b (m + n)</code> 之中，化簡 <code class="haskell">exp b</code> 前得知道 <code class="haskell">m + n</code> 究竟是 <code class="haskell">Zero</code> 還是 <code class="haskell">Suc k</code>。&shy;而根據 <code class="haskell">(+)</code> 的定義，化簡 <code class="haskell">m + n</code> 前需知道 <code class="haskell">m</code> 究竟是 <code class="haskell">Zero</code> 還是 <code class="haskell">Suc k</code>.&shy;再看右手邊，根據 <code class="haskell">(*)</code> 的定義，要化簡 <code class="haskell">exp b m * exp b n</code> 得先化簡 <code class="haskell">exp b m</code>, 而後者也得知道 <code class="haskell">m</code> 是什麼。對兩邊的分析都指向：我們應針對 <code class="haskell">m</code> 做歸納！</p><p>策略擬定後，我們便試試看吧！</p><div class="proof" title="證明定理 thm:exp-plus-times"><b>證明 </b><p>欲證明 <code class="haskell">exp b (m + n) = exp b m * exp b n</code>, 我們在 <code class="haskell">m</code> 之上做歸納。&shy;<code class="haskell">m</code> 要不就是 <code class="haskell">Zero</code>, 要不就是 <code class="haskell">Suc k</code>.</p><p><strong>情況</strong> <code class="haskell">m := Zero</code>. 此時需證明 <code class="haskell">exp b (Zero + n) = exp b Zero * exp b n</code>. 推論如下：</p><pre><code class="haskell">   exp b (Zero + n)
 ===    <comment>{- <code class="haskell">(+)</code> 之定義 -}</comment>
   exp b n
 ===    <comment>{- 因 <code class="haskell">1 * k = k</code> -}</comment>
   1 *: exp b n
 ===    <comment>{- <code class="haskell">exp</code> 之定義 -}</comment>
   exp b Zero *: exp b n 
</code></pre><p><strong>情況</strong> <code class="haskell">m := Suc m</code>. 此時需證明 <code class="haskell">exp b ((Suc m) + n) = exp b (Suc m) * exp b n</code>, 但可假設 <code class="haskell">exp b (m + n) = exp b m * exp b n</code> 已成立。推論如下：</p><pre><code class="haskell">   exp b ((Suc m) + n)
 ===    <comment>{- <code class="haskell">(+)</code> 之定義 -}</comment>
   exp b (Suc (m + n))
 ===    <comment>{- <code class="haskell">exp</code> 之定義 -}</comment>
   b *: exp b (m + n)
 ===    <comment>{- 歸納假設 -}</comment>
   b *: (exp b m *: exp b n)
 ===    <comment>{- <code class="haskell">(*)</code> 之結合律 -}</comment>
   (b *: exp b m) *: exp b n
 ===    <comment>{- <code class="haskell">exp</code> 之定義 -}</comment>
   exp b (Suc m) *: exp b n 
</code></pre></div><p>對這個證明，讀者是否有所懷疑？最大的疑問可能在「假設 <code class="haskell">exp b (m + n) = exp b m * exp b n</code> 成立」這句上。這不就是我們要證明的性質嗎？在證明中假設它成立，似乎是用該性質自己在證明自己。這是可以的嗎？</p><p>為清楚說明，我們回顧一下第<a href="Induction.html#sec:math-induction">2.1 </a>節中的數學歸納法（並把區域識別字改為 <code class="haskell">k</code> 以避免混淆）：</p><pre><code class="equation" title="自然數上之歸納法：">  |(forall k . P k)  &lt;==   P Zero ⋀ (forall k . P (Suc k) &lt;== P k) |</code>    (2.2 )
</pre><p>證明<a href="Induction.html#thm:exp-plus-times">2.1 </a>欲證的是 <code class="haskell">exp b (m + n) = exp b m * exp b n</code>，並在 <code class="haskell">m</code> 上做歸納。&shy;更精確地說，就是選用了下述的 <code class="haskell">P</code>:%&shy;<input class="toggle" id="footnote-2-3-4" type="checkbox"/><label class="fnote-toggle" for="footnote-2-3-4">(註4) </label><span class="collapsible-footnote">在程式推導圈子中，<code class="haskell">(&lt;=&gt;)</code> 常用來代表「只用在真假值上、且滿足結合律的等號」。本書中使用 <code class="haskell">(&lt;=&gt;)</code> 以和 <code class="haskell">(=)</code> 做區分。</span></p><pre><code class="spec">P m &lt;=&gt; (exp b (m + n) = exp b m * exp b n) 
</code></pre><p>在證明中改變的是 <code class="haskell">m</code>，而 <code class="haskell">b</code> 與 <code class="haskell">n</code> 是固定的。數學歸納法可證明 <code class="haskell">(forall m . P m)</code>, 展開後正是 <code class="haskell">(forall m . exp b (m + n) = exp b m * exp b n)</code>. 而根據數學歸納法，我們需提供 <code class="haskell">P Zero</code> 與 <code class="haskell">(forall m . P (Suc m) &lt;== P m)</code> 的證明。</p><p>證明<a href="Induction.html#thm:exp-plus-times">2.1 </a>中「{\bf 情況} <code class="haskell">m := Zero</code>」的部分，就是 <code class="haskell">P Zero</code> 的證明。&shy;而「{\bf 情況} <code class="haskell">m := Suc m</code>」則是 <code class="haskell">(forall m . P (Suc m) &lt;== P m)</code> 的證明。&shy;「假設 <code class="haskell">exp b (m + n) = exp b m * exp b n</code> 成立」指的是假設 <code class="haskell">P m</code> 成立，我們在此前提之下試圖證明 <code class="haskell">P (Suc m)</code>.&shy;因此，證明 <a href="Induction.html#thm:exp-plus-times">2.1 </a> 並沒有「用該性質自己證明自己」。&shy;我們是以一個比較小的結果（<code class="haskell">P m</code>）證明稍大一點的結果（<code class="haskell">P (Suc m)</code>）。&shy;就如同我們寫歸納程式時，假設 <code class="haskell">f n</code> 已經算出，試著用它定出 <code class="haskell">f (Suc n)</code>.</p><p>在證明之中，如 <code class="haskell">P m</code> 這種在歸納步驟假設成立的性質被稱作<em>歸納假設</em>(induction hypothesis)。<span id="ix-2-8"></span></p><p><b>程式與證明</b> &emsp; 證明<a href="Induction.html#thm:exp-plus-times">2.1 </a>還有一些能啟發我們之處。方才，我們看到 <code class="haskell">exp b (m + n) = exp b m * exp b n</code>， 決定以數學歸納法證明，但接下來怎麼著手？怎麼選定在哪個變數上做歸納？</p><p>答案是：分析該式中程式的行為。程式怎麼拆其參數，我們在證明中就怎麼拆。&shy;我們試圖證明某些程式的性質，但程式本身便提供了證明可怎麼進行的提示。&shy;「使證明的結構符合程式的結構」是許多證明的秘訣。&shy;並非所有證明都可以如此完成，但本原則在許多情況下適用。</p><p>再看看 <code class="haskell">exp</code>, <code class="haskell">(+)</code>, <code class="haskell">(*)</code> 等函數的定義。&shy;為何他們都分出了兩個情況：<code class="haskell">Zero</code> 與 <code class="haskell">Suc n</code>, 並且 <code class="haskell">Suc n</code> 的情況使用到該函數對於 <code class="haskell">n</code> 的值？&shy;因為自然數的資料型別是這麼定的！&shy;自然數只可能是<code class="haskell">Zero</code> 或 <code class="haskell">Suc n</code>，而後者是由 <code class="haskell">n</code> 做出來的。&shy;因此程式也如此寫。程式的結構依循與其處理的資料型別之結構。</p><p>資料、程式、與證明原來有著這樣的關係：<em>證明的結構依循著程式的結構，而程式的結構又依循著資料型別的結構</em>。歸納定義出了一個型別後，自然知道怎麼在上面寫歸納程式；歸納程式有了，自然知道如何做關於這些程式的歸納證明。一切由定義資料結構開始。掌握這個原則，大部分的證明就不是難事。</p><p><b>讓符號為你工作</b> &emsp; 再考慮證明<a href="Induction.html#thm:exp-plus-times">2.1 </a>中的狀況<code class="haskell">m := Suc m</code>. 假想由你做這個證明，由第一行 <code class="haskell">exp b ((Suc m) + n)</code> 開始。接下來該怎麼進行？</p><p>既然我們已經打定主意用數學歸納法，在證明的某處必定會使用<code class="haskell">exp b (m + n) = exp b m * exp b n</code>這個歸納假設。&shy;因此，證明前幾行的目的便是想辦法將 <code class="haskell">exp b ((Suc m) + n)</code> 中的 <code class="haskell">Suc</code> 往外提，將 <code class="haskell">exp b</code> 往內側推，使得式子中出現 <code class="haskell">exp b (m + n)</code>。一旦成功，就可運用歸納假設，將其改寫成 <code class="haskell">exp b m * exp b n</code>！&shy;接下的就是機械化地收尾、將式子整理成 <code class="haskell">exp b (Suc m) * exp b n</code> 了。</p><p>這呼應到第<a href="Introduction.html#sec:let-symbols-work">0.2 </a>節所說的「讓符號為你工作」。&shy;光從語意上想，我們不易理解為何 <code class="haskell">exp b ((Suc m) + n)</code> 能夠等於 <code class="haskell">exp b (Suc m) * exp b n</code>. 但符號給我們線索。&shy;我們可觀察式子的結構，暫時不去想語意；&shy;我們的目標是操作、移動這些符號，將它們轉換成可使用歸納假設的形式。&shy;因此，接下來的演算推導便有所依據而非盲目進行：已知目標是把某符號往外提或往內推，&shy;我們就可尋找、使用可達到此目的的規則。&shy;這些規則包括已知函數的定義、或諸如分配律、遞移律、結合律等等數學性質。&shy;若很明顯地缺了一個想要的性質，也許可以把它當作引理另外證證看。&shy;符號幫助我們，使我們的思考清晰而有方向。</p><div class="exlist"><div class="exercise exer" id="ex:proof-no-induction"><h5 class="exercise-title">練習 2.1 </h5><p>證明 <code class="haskell">1 * k = k</code>. 這個證明並不需要歸納。</p></div><div class="exercise exer" id="ex:add-associative"><h5 class="exercise-title">練習 2.2 </h5><p>證明 <code class="haskell">(+)</code> 之結合律: <code class="haskell">m + (n + k) = (m + n) + k</code>. 此證明中你使用的述語是什麼？</p></div><div class="exercise exer" id="ex:add-right-id"><h5 class="exercise-title">練習 2.3 </h5><p>證明 <code class="haskell">k + 1 = k</code>. 你需要使用歸納法嗎？用什麼述語？</p></div></div><p>最後，說到自然數上的歸納定義，似乎不得不提<em>階層</em>(factorial)。用非正式的寫法，<code class="haskell">fact n = n * (n-1) * (n-2) * ... * 1</code>.&shy;<span id="ix-2-9"></span>&shy;\label{ex:factorial}&shy;形式化的定義如下：</p><pre><code class="haskell">fact :: Nat -&gt; Nat
fact Zero     = 1
fact (Suc n)  = (Suc n) *: fact n 
</code></pre><p>我們在定理 <a href="Induction.html#thm:length-perms">2.5 </a> 中將會談到階層與排列的關係。</p><h2 class="section" id="sec:induction-lists">2.4 串列與其歸納定義</h2><p>如同第<a href="Basics.html#sec:lists">1.8 </a>節所述，「元素型別為<code class="haskell">a</code>的串列」可定義成如下的資料型別：<input class="toggle" id="footnote-2-4-5" type="checkbox"/><label class="fnote-toggle" for="footnote-2-4-5">(註5) </label><span class="collapsible-footnote">Haskell 中「元素型別為<code class="haskell">a</code>的串列」寫成<code class="haskell">[a]</code>. 由於這樣的符號在教學中遇到許多困難，本書中寫成<code class="haskell">List a</code>.</span></p><pre><code class="spec">data List a = [] | a : List a 
</code></pre><p>這個定義可以理解為</p><ol><li><p><code class="haskell">[]</code> 是一個串列，</p></li><li><p>若 <code class="haskell">xs</code> 是一個元素型別為<code class="haskell">a</code>的串列，<code class="haskell">x</code> 型別為 <code class="haskell">a</code>, 則 <code class="haskell">x:xs</code> 也是一個元素型別為<code class="haskell">a</code>的串列，</p></li><li><p>此外沒有其他元素型別為<code class="haskell">a</code>的串列。</p></li></ol><p>我們不難發現 <code class="haskell">List a</code> 和 <code class="haskell">Nat</code> 是相當類似的資料結構：<code class="haskell">[]</code> 相當於 <code class="haskell">Zero</code>, <code class="haskell">(:)</code> 則類似 <code class="haskell">Suc</code>, 只是此處我們不只「加一」，添加的那個東西多了一些資訊，是一個型別為<code class="haskell">a</code>的元素。&shy;或著我們可反過來說，串列「只是」在每個<code class="haskell">Suc</code>上都添了一些資訊的自然數！&shy;既然自然數與串列有類似的結構，不難想像許多自然上的函數、自然數的性質，都有串列上的類似版本，</p><h3 class="subsection" id="sec:induction-lists-defn">2.4.1 串列上之歸納定義</h3><p>和自然數類似，許多串列上的函數可歸納地定義出來。&shy;由於串列只可能由<code class="haskell">[]</code>或<code class="haskell">(:)</code>做出，定義串列上的函數時也分別處理這兩個情況。&shy;基底情況為<code class="haskell">[]</code>, 而欲定義 <code class="haskell">f (x:xs)</code> 的值時，可假設 <code class="haskell">f xs</code> 已算出來了：</p><pre><code class="spec">f :: List a -&gt; b
f []      = e
f (x:xs)  = ... f xs ...
</code></pre><p>來看些例子吧！「算一個陣列的和」可能是許多人學到陣列後得寫的頭幾個練習程式。串列版的和可以這麼寫：</p><pre><code class="spec">sum :: List Int -&gt; Int
sum []      = 0
sum (x:xs)  = x + sum xs 
</code></pre><p>基底狀況中，空串列的和應是<code class="haskell">0</code>。歸納步驟中，我們要算<code class="haskell">x:xs</code> 的和，可假設我們已算出<code class="haskell">xs</code> 的和，再加上<code class="haskell">x</code> 即可。計算串列長度的 <code class="haskell">length</code> 有很類似的定義 ：</p><pre><code class="haskell">length :: List a -&gt; Nat
length []      = Zero
length (x:xs)  = Suc (length xs) 
</code></pre><p>在歸納步驟中，我們想計算<code class="haskell">x:xs</code> 的長度，只需假設我們已知<code class="haskell">xs</code> 的長度，然後加一。&shy;事實上，<code class="haskell">length</code> 剛好體現了前述「<code class="haskell">List a</code> 只是在每個<code class="haskell">Suc</code>上添了資訊的自然數」一事：&shy;<code class="haskell">length</code> 把串列走過一遍，將 <code class="haskell">[]</code> 代換成 <code class="haskell">Zero</code>，並將每個 <code class="haskell">(_:)</code> 中附加的資訊拋棄，代換成 <code class="haskell">Suc</code>。</p><p>函數 <code class="haskell">map f :: List a -&gt; List b</code>，也就是 <code class="haskell">map</code> 給定函數 <code class="haskell">f</code> 的結果，也可在串列上歸納定義：</p><pre><code class="spec">map :: (a -&gt; b) -&gt; List a -&gt; List b
map f []      = []
map f (x:xs)  = f x : map f xs 
</code></pre><p>基底狀況的合理結果是<code class="haskell">[]</code>. 歸納步驟中，要對 <code class="haskell">x:xs</code> 中的每個元素都做 <code class="haskell">f</code>,&shy;我們可假設已經知道如何對 <code class="haskell">xs</code> 中的每個元素都做 <code class="haskell">f</code>, 把其結果接上 <code class="haskell">f x</code> 即可。</p><p>函數 <code class="haskell">(++)</code> 把兩個串列接起來。如果我們在其左邊的參數上做歸納定義，可得到：%&shy;<input class="toggle" id="footnote-2-4-6" type="checkbox"/><label class="fnote-toggle" for="footnote-2-4-6">(註6) </label><span class="collapsible-footnote">依照 Haskell 的運算元優先順序，<code class="haskell">x : (xs ++ ys)</code> 其實可寫成 <code class="haskell">x : xs ++ ys</code>, 一般也常如此寫。此處為了清楚而加上括號。</span></p><pre><code class="spec">(++) :: List a -&gt; List a -&gt; List a
[]      ++ ys  = ys
(x:xs)  ++ ys  = x : (xs ++ ys) 
</code></pre><p>空串列接上 <code class="haskell">ys</code> 仍是 <code class="haskell">ys</code>. 歸納步驟中，要把 <code class="haskell">x:xs</code> 接上 <code class="haskell">ys</code>, 我們可假設已有辦法把 <code class="haskell">xs</code> 接上 <code class="haskell">ys</code>, 然後只需添上 <code class="haskell">x</code> 即可。</p><p>請讀者比較一下<code class="haskell">(++)</code>與自然數加法<code class="haskell">(+)</code>的定義，會發現兩者的結構一模一樣！&shy;如果串列是在每個<code class="haskell">Suc</code>中加上資料的自然數，<code class="haskell">(++)</code>就是串列上的加法了。&shy;若要形式化地把 <code class="haskell">List a</code>, <code class="haskell">Nat</code>, <code class="haskell">(++)</code>, 與 <code class="haskell">(+)</code> 牽上關係，連接他們的橋樑就是 <code class="haskell">length</code> --- <code class="haskell">xs ++ ys</code> 的長度，應是 <code class="haskell">xs</code> 與 <code class="haskell">ys</code> 的長度之和！意即：</p><pre><code class="equation" id="eq:length-append">  |length (xs ++ ys) = length xs + length ys| \mbox{~~.}</code>    (2.3 )
</pre><p>習題 <a href="Induction.html#ex:length-append">2.10 </a> 中將證明此性質。</p><p>最後，<code class="haskell">(++)</code> 是反覆使用 <code class="haskell">(:)</code>, 函數 <code class="haskell">concat</code> 則是反覆使用 <code class="haskell">(++)</code>:</p><pre><code class="spec">concat :: List (List a) -&gt; List a
concat [] = []
concat (xs:xss) = xs ++ concat xss 
</code></pre><h3 class="subsection" id="sec:induction-lists-proof">2.4.2 串列上之歸納證明</h3><p>如果 <code class="haskell">List a</code> 是一個歸納定義出的資料結構，我們應可以在 <code class="haskell">List a</code> 之上做歸納證明。確實，串列上的歸納法可寫成：</p><pre><code class="equation" title="串列上之歸納法：">  |(forall xs . P xs)  &lt;==   P [] ⋀ (forall x xs . P (x:xs) &lt;== P xs) |</code>    (2.4 )
</pre><p>以文字敘述的話：給定一個述語 <code class="haskell">P :: List a -&gt; Bool</code>, 若要證明 <code class="haskell">P xs</code> 對所有 <code class="haskell">xs</code> 都成立，只需證明 <code class="haskell">P []</code> 和「對所有 <code class="haskell">x</code> 和 <code class="haskell">xs</code>, 若 <code class="haskell">P xs</code> 則 <code class="haskell">P (x:xs)</code>」。</p><p>下述的 <em><code class="haskell">map</code> 融合定理</em>(<em>map-fusion theorem</em>)&shy;<span id="ix-2-10"></span>&shy;是關於 <code class="haskell">map</code> 極常用的定理之一。所謂「融合」在此處是把兩個 <code class="haskell">map</code> 融合為一。&shy;我們日後會見到更多的融合定理。</p><div class="theorem" id="thm:map-fusion" title="|map| 融合定理"><h5 class="theorem-title">定理 2.2  |map| 融合定理 </h5><p>對任何 <code class="haskell">f</code> 與 <code class="haskell">g</code>,&shy;<code class="haskell">map f . map g = map (f.g)</code>.</p></div><p>作為一個例子，我們試著證明定理<a href="Induction.html#thm:map-fusion">2.2 </a>。&shy;我們目前只會用歸納證明，但是 <code class="haskell">map f . map g = map (f.g)</code> 的左右邊都是函數，&shy;沒有出現串列也沒有出現自然數。該拿什麼東西來歸納呢？</p><p>回顧<em>外延相等</em>（定義<a href="Basics.html#def:extensional-eq">1.8 </a>）：&shy;當<code class="haskell">h</code>, <code class="haskell">k</code> 均是函數，<code class="haskell">h = k</code> 的意思是對任何參數 <code class="haskell">x</code>, <code class="haskell">h x = k x</code>.&shy;因此，將待證式左右邊各補上參數，並將 <code class="haskell">(.)</code> 展開，可得知其意義為對任何 <code class="haskell">xs</code>,</p><pre><code class="equation">    |map f (map g xs) = map (f.g) xs| \mbox{~ ~.}</code>    (2.5 )
</pre><p>我們便可以在<code class="haskell">xs</code>上做歸納了！</p><div class="proof"><b>證明 </b><p>當 <code class="haskell">xs := []</code>，等式兩邊皆歸約為 <code class="haskell">[]</code>.&shy;考慮 <code class="haskell">xs := x:xs</code> 的情況：</p><pre><code class="spec">  map f (map g (x:xs))
=   <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
  map f (g x : map g xs)
=   <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
  f (g x) : map f (map g xs)
=   <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
  (f.g) x : map f (map g xs)
=   <comment>{- 歸納假設 -}</comment>
  (f.g) x : map (f.g) xs
=   <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
  map (f.g) (x:xs) 
</code></pre></div><p>% 前面說到 <code class="haskell">(++)</code> 與 <code class="haskell">(+)</code> 的相似性。若要形式化地把 <code class="haskell">List a</code>, <code class="haskell">Nat</code>, <code class="haskell">(++)</code>, 與 <code class="haskell">(+)</code>&shy;% 牽上關係，連接他們的橋樑就是 <code class="haskell">length</code> --- <code class="haskell">xs ++ ys</code> 的長度，應是 <code class="haskell">xs</code> 與 <code class="haskell">ys</code> 的長度之和！我們試著證明看看。&shy;% \begin{theorem} \label{thm:length-append}&shy;% 對所有 <code class="haskell">xs</code> 與 <code class="haskell">ys</code>, <code class="haskell">length (xs ++ ys) = length xs + length ys</code>.&shy;% \end{theorem}&shy;% \begin{proof} 檢視 <code class="haskell">length</code>, <code class="haskell">(++)</code>, 與 <code class="haskell">(+)</code> 的定義，會發現等號兩邊都須對 <code class="haskell">xs</code> 做分析才能化簡。因此我們對 <code class="haskell">xs</code> 做歸納。&shy;%&shy;% \noindent {\bf 狀況} <code class="haskell">xs := []</code>.&shy;% %if False&shy;% <code>haskell
% lengthAppendPf0 ys =
%</code>&shy;% %endif&shy;% <code>haskell
%       length ([] ++ ys)
%  ===    {- |(++)| 之定義 -}
%       length ys
%  ===   {- |(+)| 之定義 -}
%       Zero + length ys
%  ===   {- |length| 之定義 -}
%       length [] + length ys 
%</code>&shy;%&shy;% \noindent {\bf 狀況} <code class="haskell">xs := x : xs</code>.&shy;% %if False&shy;% <code>haskell
% lengthAppendPf1 :: a -&gt; List a -&gt; List a -&gt; Nat
% lengthAppendPf1 x xs ys =
%</code>&shy;% %endif&shy;% <code>haskell
%    length ((x:xs) ++ ys)
%  ===    {- |(++)| 之定義  -}
%    length (x : (xs ++ ys))
%  ===    {- |length| 之定義 -}
%    Suc (length (xs ++ ys))
%  ===    {- 歸納假設 -}
%    Suc (length xs + length ys)
%  ===    {- |(+)| 之定義 -}
%    (Suc (length xs)) + length ys
%  ===    {- |length| 之定義 -}
%    length (x:xs) + length ys 
%</code>&shy;% \end{proof}&shy;% 讀者可觀察到類似的技巧：在<code class="haskell">xs := x : xs</code>的狀況中，頭幾步的目的是將<code class="haskell">length</code>往裡推，製造出<code class="haskell">length (xs++ys)</code>, 以便使用歸納假設。</p><div class="infobox infobox" title="等式證明的步驟該多詳細？"><h5 class="infobox-title">等式證明的步驟該多詳細？</h5><p>本書中目前為止的等式證明相當細：每一個定義展開都成為獨立的步驟。&shy;這是為了教學目的，實務上不一定得如此。&shy;以我而言，自己的研究手稿中可能會將步驟寫得極詳細，&shy;為確保每個細節正確，並讓他人（或幾年後已經忘記細節的自己）在不需知道上下文的情況下也能機械化地檢查每個步驟。&shy;但在論文中，因篇幅有限，及考量讀者一次能處理的資訊量有限，&shy;發表出的證明可能會省略許多步驟。</p><p>實務上，被認為簡單、不寫出也不妨礙理解的步驟或說明都可被省略。&shy;但何謂簡單則很依靠作者的判斷與習慣。&shy;一般說來，僅展開定義的步驟用電腦便可自動做到，通常是可精簡掉的。&shy;最好寫出的步驟則可能是決定整個證明之結構的、不易以電腦決定而得靠人類智慧與經驗的，等等。&shy;這可能包括使用歸納假設的那步，或使用較特別的引理時。&shy;例如，性質 [RefUndefined]的歸納步驟證明可能被精簡如下：</p><pre><code class="spec">   length ((x:xs) ++ ys)
=  Suc (length (xs ++ ys))
=    <comment>{- 歸納假設 -}</comment>
   Suc (length xs + length ys)
=  length (x:xs) + length ys 
</code></pre></div><div class="exlist"><div class="exercise exer" id="ex:append-nil"><h5 class="exercise-title">練習 2.4 </h5><p>證明對所有 <code class="haskell">xs</code>, <code class="haskell">xs ++ [] = xs</code>. 比較本題與習題<a href="Induction.html#ex:add-right-id">2.3 </a>的證明。</p></div><div class="exercise exer" id="ex:reverse"><h5 class="exercise-title">練習 2.5 </h5><p>定義函數 <code class="haskell">reverse :: List a -&gt; List a</code>, 將輸入的串列反轉。例如 <code class="haskell">reverse [1,2,3,4,5] = [5,4,3,2,1]</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-5" type="checkbox"/><label class="lbl-toggle" for="ans-2-5">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="spec">reverse :: List a -&gt; List a
reverse []      = []
reverse (x:xs)  = reverse xs ++ [x] 
</code></pre><p>另，關於 <code class="haskell">reverse</code> 效率的討論詳見第 <a href="Derivation.html#sec:efficiency-basics">5.2 </a> 節。</p></div></div><div class="exercise exer" id="ex:length-map"><h5 class="exercise-title">練習 2.6 </h5><p>證明對所有 <code class="haskell">f</code>, <code class="haskell">length . map f = length</code>.</p></div><div class="exercise exer" id="ex:sum-map-times"><h5 class="exercise-title">練習 2.7 </h5><p>證明對所有 <code class="haskell">x</code>, <code class="haskell">sum . map (x*) = (x*) . sum</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-7" type="checkbox"/><label class="lbl-toggle" for="ans-2-7">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>欲證明<code class="haskell">sum (map (x*) ys) = x * sum ys</code>, 在 <code class="haskell">ys</code> 上歸納。</p><p><strong>情況</strong> <code class="haskell">ys := []</code>, 兩邊都歸約為 <code class="haskell">0</code>.</p><p><strong>情況</strong> <code class="haskell">ys := y:ys</code>:</p><pre><code class="spec">   sum (map (x*) (y:ys))
=    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
   sum (x*y : map (x*) ys)
=    <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
   x * y + sum (map (x*) ys)
=    <comment>{- 歸納假設 -}</comment>
   x * y + x * sum ys
=    <comment>{- 乘法與加法之分配律 -}</comment>
   x * (y+sum ys)
=    <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
   x * sum (y:ys) 
</code></pre></div></div><div class="exercise exer" id="ex:sum-map-suc"><h5 class="exercise-title">練習 2.8 </h5><p>證明對所有 <code class="haskell">xs</code>, <code class="haskell">sum (map (Suc) xs) = length xs + sum xs</code>.</p></div><div class="exercise exer" id="ex:sum-map-const"><h5 class="exercise-title">練習 2.9 </h5><p>證明對所有 <code class="haskell">xs</code> 與 <code class="haskell">y</code>,&shy;<code class="haskell">sum (map (const y) xs) = y * length xs</code>.</p></div></div><p>討論自然數時，習題<a href="Induction.html#ex:add-associative">2.2 </a>曾請讀者證明加法都滿足結合律。此處示範證明類似定理的串列版：</p><div class="theorem" id="thm:append-associative"><h5 class="theorem-title">定理 2.3  </h5><p><code class="haskell">(++)</code> 滿足結合律。意即，對任何 <code class="haskell">xs</code>, <code class="haskell">ys</code>, 和<code class="haskell">zs</code>,&shy;<code class="haskell">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</code>.</p></div><div class="proof"><b>證明 </b><p>上述式子中有三個變數，我們怎麼得知該在哪一個變數上做歸納呢？&shy;此時絕對別急著把三個變數都拆開，變成多達八種狀況。&shy;觀察：如果要歸約等號左邊的 <code class="haskell">(xs ++ ys) ++ zs</code>，根據 <code class="haskell">(++)</code> 的定義，得對 <code class="haskell">xs ++ ys</code> 做狀況分析；要歸約 <code class="haskell">xs ++ ys</code>，又得對 <code class="haskell">xs</code> 做狀況分析。&shy;同樣地，根據 <code class="haskell">(++)</code> 的定義，要歸約等號右邊的 <code class="haskell">xs ++ (ys ++ zs)</code> 得對 <code class="haskell">xs</code> 做狀況分析。&shy;不論左右邊，最關鍵的值都是 <code class="haskell">xs</code>.&shy;因此我們在 <code class="haskell">xs</code> 之上做歸納。</p><p><strong>狀況</strong> <code class="haskell">xs:=[]</code>:</p><pre><code class="spec">   ([] ++ ys) ++ zs
=   <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   ys ++ zs
=   <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   [] ++ (ys ++ zs) 
</code></pre><p><strong>狀況</strong> <code class="haskell">xs:= x:xs</code>:</p><pre><code class="spec">   ((x:xs) ++ yz) ++ zs
=    <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   (x : (xs ++ ys)) ++ zs
=    <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   x : ((xs ++ ys) ++ zs)
=    <comment>{- 歸納假設 -}</comment>
   x : (xs ++ (ys ++ zs))
=    <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   (x : xs) ++ (ys ++ zs) 
</code></pre></div><p>基底狀況的證明很簡單。至於歸納步驟，同樣地，前兩步都是為了湊出 <code class="haskell">(xs ++ ys) ++ zs</code>, 以便使用歸納假設。既然 <code class="haskell">(++)</code> 滿足結合律，日後我們寫 <code class="haskell">xs ++ ys ++ zs</code> 就可不加括號了。</p><div class="exlist"><div class="exercise exer" id="ex:length-append"><h5 class="exercise-title">練習 2.10 </h5><p>證明性質([RefUndefined])：對所有 <code class="haskell">xs</code> 與 <code class="haskell">ys</code>, <code class="haskell">length (xs ++ ys) = length xs + length ys</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-10" type="checkbox"/><label class="lbl-toggle" for="ans-2-10">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>檢視 <code class="haskell">length</code>, <code class="haskell">(++)</code>, 與 <code class="haskell">(+)</code> 的定義，會發現等號兩邊都須對 <code class="haskell">xs</code> 做分析才能化簡。因此我們對 <code class="haskell">xs</code> 做歸納。</p><p><strong>狀況</strong> <code class="haskell">xs := []</code>.</p><pre><code class="haskell">      length ([] ++ ys)
 ===    <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
      length ys
 ===   <comment>{- <code class="haskell">(+)</code> 之定義 -}</comment>
      Zero + length ys
 ===   <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
      length [] + length ys 
</code></pre><p><strong>狀況</strong> <code class="haskell">xs := x : xs</code>.</p><pre><code class="haskell">   length ((x:xs) ++ ys)
 ===    <comment>{- <code class="haskell">(++)</code> 之定義  -}</comment>
   length (x : (xs ++ ys))
 ===    <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
   Suc (length (xs ++ ys))
 ===    <comment>{- 歸納假設 -}</comment>
   Suc (length xs + length ys)
 ===    <comment>{- <code class="haskell">(+)</code> 之定義 -}</comment>
   (Suc (length xs)) + length ys
 ===    <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
   length (x:xs) + length ys 
</code></pre></div></div><div class="exercise exer" id="ex:map-append"><h5 class="exercise-title">練習 2.11 </h5><p>證明對所有 <code class="haskell">f</code>, <code class="haskell">xs</code>, 與 <code class="haskell">ys</code>, <code class="haskell">map f (xs ++ ys) = map f xs ++ map f ys</code>.</p></div></div><h2 class="section" id="sec:data-prog-proof">2.5 從資料、程式、到證明</h2><p>本節再用一個例子談談「讓符號為我們工作」。考慮證明下述性質：</p><pre><code class="equation" id="eq:sum-concat"> |sum . concat = sum . map sum|\mbox{~ ~.}</code>    (2.6 )
</pre><p>根據外延相等，這相當於證明對所有<code class="haskell">xss</code>,&shy;<code class="haskell">sum (concat xss) = sum (map sum xss)</code>.&shy;當 <code class="haskell">xss := []</code>, 等號兩邊都歸約成 <code class="haskell">0</code>. 考慮 <code class="haskell">xss := xs :xss</code> 的情況：</p><pre><code class="haskell">      sum (concat (xs:xss))
 ===    <comment>{- <code class="haskell">concat</code> 之定義 -}</comment>
      sum (xs ++ concat xss)
 ===    <comment>{- 因 <code class="haskell">sum (xs ++ ys) = sum xs + sum ys</code> -}</comment>
      sum xs + sum (concat xss)
 ===    <comment>{- 歸納假設 -}</comment>
      sum xs + sum (map sum xss)
 ===    <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
      sum (sum xs : map sum xss)
 ===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
      sum (map sum (xs:xss)) 
</code></pre><p>讀者對這個證明最大的疑問可能是：我們怎麼知道該用 <code class="haskell">sum (xs ++ ys) = sum xs + sum ys</code> 呢？&shy;為什麼當我們遇到 <code class="haskell">sum (xs ++ concat xss)</code>, 我們不是把 <code class="haskell">xs</code> 再拆成首和尾，甚至把 <code class="haskell">xss</code> 拆開？&shy;這是許多綜合考量的結果。&shy;首先，我們預期會使用歸納假設，因此證明前幾步的目的均為把 <code class="haskell">sum</code> 推到 <code class="haskell">concat xss</code> 左側，試圖做出 <code class="haskell">sum (concat xss)</code>.&shy;此處我們再強調一個觀念：<em>證明中的步驟不是瞎猜的，而是有目的的</em>。&shy;符號給我們提示：我們需要把 <code class="haskell">sum</code> 往右推，因此我們試圖尋找能完成這個目標的性質。</p><p>其次，<em>證明的結構跟隨著程式的結構</em>。由於 <code class="haskell">concat</code> 是由 <code class="haskell">(++)</code> 定義的，每一個關於 <code class="haskell">concat</code> 的定理，均很有可能奠基在一個關於 <code class="haskell">(++)</code> 的相對定理上。為了證明一個描述 <code class="haskell">sum</code> 與 <code class="haskell">concat</code> 的關係的定理，我們可能會需要一個關於 <code class="haskell">sum</code> 與 <code class="haskell">(++)</code> 的性質。</p><p>有了符號給我們的這兩個線索，我們便可以運用我們對語意的了解：<code class="haskell">sum</code> 與 <code class="haskell">(++)</code> 應該會滿足什麼性質？&shy;我們可猜測應該是 <code class="haskell">sum (xs ++ ys) = sum xs + sum ys</code> --- 根據我們對 <code class="haskell">sum</code> 與 <code class="haskell">(++)</code> 的語意上的理解，這性質成立的機會很大。&shy;而且，這個性質允許我們把 <code class="haskell">sum</code> 推到右邊。</p><p>符號仍舊幫助了我們。&shy;我們不可能期待所有定理都只靠符號推導出，在關鍵時刻我們仍會需要對於特定領域的、語意上的知識。但符號給了我們許多引導，&shy;縮小我們需要猜測的範圍。</p><p>至於 <code class="haskell">sum (xs ++ ys) = sum xs + sum ys</code> 該怎麼證明呢？&shy;不要急著把 <code class="haskell">xs</code> 與 <code class="haskell">ys</code> 都拆開。&shy;觀察等號左右邊的式子，根據 <code class="haskell">(++)</code>, <code class="haskell">(+)</code> 與 <code class="haskell">sum</code> 的定義，兩個式子的歸約都是先對 <code class="haskell">xs</code> 做情況分析。&shy;因此我們可試著在 <code class="haskell">xs</code> 上做歸納。</p><p><em>證明的結構跟隨著程式的結構</em> --- 這是做證明時相當好用的指引。&shy;程式對哪個參數做歸納，我們做證明時就在那個參數上做歸納。&shy;函數 <code class="haskell">f</code> 用函數 <code class="haskell">g</code> 定義，我們證明 <code class="haskell">f</code> 的性質時就可以預期會需要一個 <code class="haskell">g</code> 的相關性質。&shy;並非所有證明都可以如此做出，但這個模式在許多情況下都適用。</p><p>而如我們所知，<em>程式的結構又跟隨著資料的結構</em>：&shy;例如，串列有 <code class="haskell">[]</code> 和 <code class="haskell">x:xs</code> 兩個情況，我們定義串列上的程式時也分出這兩個情況，&shy;定義 <code class="haskell">f (x:xs)</code> 時可以使用 <code class="haskell">f xs</code> 的值。&shy;資料結構、程式、與證明於是有著這樣的連續關係：&shy;歸納定義出一個資料結構，我們就有了一個在上面歸納定義程式的方法；&shy;有了歸納定義的程式，我們便知道怎麼做關於它的歸納證明。&shy;一切由資料結構開始。</p><div class="exlist"><div class="exercise exer" id="ex:length-concat"><h5 class="exercise-title">練習 2.12 </h5><p>證明 <code class="haskell">length . concat = sum . map length</code>.&shy;我們會需要什麼關於 <code class="haskell">(++)</code> 的相關性質？</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-12" type="checkbox"/><label class="lbl-toggle" for="ans-2-12">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>考慮 <code class="haskell">xs:xss</code> 的情況：</p><pre><code class="spec">     length (concat (xs:xss))
===  length (xs ++ concat xss)
===    <comment>{- 因 <code class="haskell">length (xs ++ ys) = length xs + length ys</code> -}</comment>
     length xs + length (concat xss)
===    <comment>{- 歸納假設 -}</comment>
     length xs + sum (map length xss)
===  sum (length xs : map length xss)
===  sum (map length (xs:xss)) 
</code></pre><p>我們需要的性質是 <code class="haskell">length (xs ++ ys) = length xs + length ys</code> .</p></div></div><div class="exercise exer" id="ex:map-concat"><h5 class="exercise-title">練習 2.13 </h5><p>證明對所有 <code class="haskell">f</code>, <code class="haskell">map f . concat = concat . map (map f)</code>.&shy;我們會需要什麼關於 <code class="haskell">(++)</code> 的相關性質？</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-13" type="checkbox"/><label class="lbl-toggle" for="ans-2-13">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>考慮 <code class="haskell">xs:xss</code> 的情況：</p><pre><code class="spec">     map f (concat (xs:xss))
===  map f (xs ++ concat xss)
===   <comment>{- 因 <code class="haskell">map f (xs ++ ys) = map f xs ++ map f ys</code> -}</comment>
     map f xs ++ map f (concat xss)
===   <comment>{- 歸納假設 -}</comment>
     map f xs ++ concat (map (map f xss))
===  concat (map f xs : map (map f xss))
===  concat (map (map f (xs : xss))) 
</code></pre><p>我們需要的性質是 <code class="haskell">map f (xs ++ ys) = map f xs ++ map f ys</code> .</p></div></div></div><h2 class="section" id="sec:more-inductive-defns">2.6 更多歸納定義與證明</h2><p>為讓讀者熟悉，本節中我們多看一些自然數或串列上的歸納定義。</p><h3 class="subsection" id="sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></h3><p><b>filter</b> &emsp; 我們曾見過的函數 <code class="haskell">filter</code> 可寫成如下的歸納定義：</p><pre><code class="spec">filter :: (a -&gt; Bool) -&gt; List a -&gt; List a
filter p []      = []
filter p (x:xs)  = if p x then x : filter p xs else filter p xs 
</code></pre><p>在 <code class="haskell">filter</code> 的許多性質中，我們試著證明下述性質作為例子：</p><div class="theorem" id="thm:filter-map"><h5 class="theorem-title">定理 2.4  </h5><p><code class="haskell">filter p . map f = map f . filter (p . f)</code>.</p></div><div class="proof"><b>證明 </b><p>和定理<a href="Induction.html#thm:map-fusion">2.2 </a>一樣，待證式的左右邊都是函數。&shy;根據外延相等，我們將左右邊各補上參數 <code class="haskell">xs</code>，並在 <code class="haskell">xs</code> 上做歸納：</p><pre><code class="equation">  |filter p (map f xs) = map f (filter (p . f) xs)| \mbox{~~.}</code>    (2.7 )
</pre><p>情況 <code class="haskell">x := []</code> 中左右邊都可化簡成<code class="haskell">[]</code>.&shy;我們看看 <code class="haskell">xs := x:xs</code> 的情況：</p><pre><code class="haskell">   filter p (map f (x:xs))
 ===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
   filter p (f x : map f xs)
 ===    <comment>{- <code class="haskell">filter</code> 之定義 -}</comment>
   if p (f x)  then f x : filter p (map f xs) else filter p (map f xs)
 ===    <comment>{- 歸納假設 -}</comment>
   if p (f x)  then f x : map f (filter (p . f) xs) else map f (filter (p . f) xs)
 ===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
   if p (f x)  then map f (x : filter (p . f) xs) else map f (filter (p . f) xs)
 ===    <comment>{- 因 <code class="haskell">f (if p then e1 else e2) = if p then f e1 else f e2</code>, 如後述 -}</comment>
   map f (if p (f x) then x : filter (p . f) xs else filter (p . f) xs)
 ===    <comment>{- <code class="haskell">filter</code> 之定義 -}</comment>
   map f (filter (p . f) (x:xs)) 
</code></pre></div><p><b>終止與證明</b> &emsp;&shy;上述證明的倒數第二步為將 <code class="haskell">map f</code> 提到外面，用了一個關於 <code class="haskell">if</code> 的性質：</p><pre><code class="equation" id="eq:fn-if-distribute">  |f (if p then e1 else e2)  =  if p then f e1 else f e2| \mbox{~~.}</code>    (2.8 )
</pre><p>這性質對嗎？若 <code class="haskell">p</code> 成立，左右手邊都化簡為<code class="haskell">f e1</code>, 若 <code class="haskell">p</code> 不成立，左右手邊都化簡為 <code class="haskell">f e2</code>. 因此 ([RefUndefined]) 應該成立，是嗎？</p><p>答案是：如果我們假設的世界中有不終止的程式，([RefUndefined])便不正確了。&shy;例如，當 <code class="haskell">f</code> 是 <code class="haskell">three x = 3</code>，而 <code class="haskell">p</code> 是個永遠執行、不終止的算式（例：<code class="haskell">let b = not b in b</code>)：</p><pre><code class="equation" id="eq:fn-if-three-distribute">  |three (if p then e1 else e2) <comment>{-"~\stackrel{?}{=}~"-}</comment> if p then three e1 else three e2| </code>    (2.9 )
</pre><p>上述式子的左手邊直接化簡成<code class="haskell">3</code>, 但右手邊卻不會終止，因為 <code class="haskell">if</code> 得知道 <code class="haskell">p</code> 的值。&shy;我們找到了 ([RefUndefined]) 的反例！</p><p>在允許可能不終止的程式存在的世界中，([RefUndefined])得多些附加條件。&shy;通常的做法是限定 <code class="haskell">f</code> 須是個<em>嚴格函數</em>, 意即 <code class="haskell">f</code> 的輸入若不終止，<code class="haskell">f</code>也不會終止。&shy;但([RefUndefined])並不是唯一帶著附加條件的性質 --- 許多常用性質都得加上類似的附加條件。&shy;所有狀況分析也都得將不終止考慮進去，例如，自然數除了 <code class="haskell">Zero</code> 與 <code class="haskell">Suc n</code> 之外，還多了第三種情況「不終止」。<input class="toggle" id="footnote-2-6-7" type="checkbox"/><label class="fnote-toggle" for="footnote-2-6-7">(註7) </label><span class="collapsible-footnote"><a href="Biblio.html#Bird:87:Introduction">Bird [1987]</a> 就採用這種作法。</span>&shy;推論與證明變得更複雜。&shy;有些人因此較喜歡另一條路：藉由種種方法確保我們只寫出會終止的程式，便可假設我們確實活在所有程式都正常終止的世界中。</p><p><b>保護式 v.s. 條件分支</b> &emsp; 有些人喜歡用保護式語法定義 <code class="haskell">filter</code>：</p><pre><code class="spec">filter p []      = []
filter p (x:xs)  | p x        = x : filter p xs
                 | otherwise  = filter p xs 
</code></pre><p>若在此定義下證明定理<a href="Induction.html#thm:filter-map">2.4 </a>，依「證明的結構與程式的結構相同」的原則，順理成章地，我們可在 <code class="haskell">xs:=x:xs</code> 中再分出 <code class="haskell">p (f x)</code> 成立與不成立的兩個子狀況：</p><pre><code class="spec"> <comment>{-"\mbox{\bf 狀況}~"-}</comment> xs:=[]:  ...
 <comment>{-"\mbox{\bf 狀況}~"-}</comment> xs:=x:xs: ...
    <comment>{-"\mbox{\bf 狀況}~"-}</comment> p (f x):
         filter p (map f (x:xs))
      =    <comment>{- <code class="haskell">p (f x)</code> 成立 -}</comment>
         f x : filter p (map f xs)
      =  ... 
    <comment>{-"\mbox{\bf 狀況}~"-}</comment> not (p (f x)):
         filter p (map f (x:xs))
      =   <comment>{- <code class="haskell">(not p (f x))</code> -}</comment>
         filter p (map f xs)
      =  ... 
</code></pre><p>這個定義中不用 <code class="haskell">if</code>, 因此證明中也用不上 ([RefUndefined]), 但該證明要成立仍須假設所有程式都正常終止 --- 我們少證了一個 「<code class="haskell">p (f x)</code> 不終止」的情況（而確實，在此情況下([RefUndefined])並不成立）。喜歡用哪個方式純屬個人偏好。</p><p>前幾章提過的 <code class="haskell">takeWhile</code> 與 <code class="haskell">dropWhile</code> 兩函數型別與 <code class="haskell">filter</code> 相同。他們可寫成如下的歸納定義：</p><pre><code class="spec">takeWhile :: (a -&gt; Bool) -&gt; List a -&gt; List a
takeWhile p []      = []
takeWhile p (x:xs)  = if p x then x : takeWhile p xs else [] 

dropWhile :: (a -&gt; Bool) -&gt; List a -&gt; List a
dropWhile p []      = []
dropWhile p (x:xs)  = if p x then dropWhile p xs else x:xs 
</code></pre><p>兩者都是在輸入串列上做歸納。兩者也都可用保護式語法定義。</p><div class="exlist"><div class="exercise exer" id="ex:take-cat-drop"><h5 class="exercise-title">練習 2.14 </h5><p>證明 <code class="haskell">takeWhile p xs ++ dropWhile p xs = xs</code>.</p></div><div class="exercise exer" id="ex:protect-takeWhile-dropWhile"><h5 class="exercise-title">練習 2.15 </h5><p>以保護式語法定義 <code class="haskell">takeWhile</code> 與 <code class="haskell">dropWhile</code>, 以此定義做做看習題 <a href="Induction.html#ex:take-cat-drop">2.14 </a>.</p></div></div><h3 class="subsection" id="sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</h3><p><b>不等式證明</b> &emsp; 給定如下的定義，<code class="haskell">elem x xs</code> 判斷 <code class="haskell">x</code> 是否出現在串列 <code class="haskell">xs</code> 中：</p><pre><code class="spec">elem x []      = False
elem x (y:xs)  = (x == y) || elem x xs 
</code></pre><p>% 在 Haskell 中 <code class="haskell">elem</code> 的型別是 <code class="haskell">Eq a =&gt; a -&gt; List a -&gt; Bool</code>.&shy;% 我們將在第???章詳細解釋 <code class="haskell">Eq a =&gt;</code> 的部分。&shy;% 目前可粗略地理解為：<code class="haskell">elem</code> 檢查某型別為 <code class="haskell">a</code> 的元素是否出現在型別為 <code class="haskell">List a</code> 的串列中，但有個附加條件：屬於型別 <code class="haskell">a</code> 的值必須能判斷是否相等。&shy;目前為止，我們所練習的都是以<code class="haskell">(=)</code>將式子串起的等式證明。&shy;以下以<code class="haskell">elem</code>為例，我們嘗試證明一個「不等式」：</p><pre><code class="spec">  elem z xs  ==&gt;  elem z (xs ++ ys) 
</code></pre><p>以口語說出的話：「若<code class="haskell">z</code> 出現在<code class="haskell">xs</code> 中，<code class="haskell">z</code> 也出現在<code class="haskell">xs ++ ys</code> 中」。&shy;欲證明上式，該從哪一側推到哪一側呢？&shy;一般認為從式子較長、或結構較複雜的那側開始，化簡成較短、較簡單的那側，是較容易的。&shy;因此我們嘗試由右側推到左側：由 <code class="haskell">elem z (xs ++ ys)</code> 開始，尋找使之成立的條件，&shy;並希望 <code class="haskell">elem z xs</code> 是足夠的。</p><div class="proof"><b>證明 </b><p>在 <code class="haskell">xs</code> 上做歸納。基底 <code class="haskell">xs := []</code> 的狀況在此省略，&shy;看 <code class="haskell">xs:=x:xs</code> 的狀況：</p><pre><code class="spec">     elem z ((x:xs) ++ ys)
&lt;=&gt;   <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
     elem z (x : (xs ++ ys))
&lt;=&gt;   <comment>{- <code class="haskell">elem</code> 之定義 -}</comment>
     (z==x) || elem z (xs ++ ys)
&lt;==   <comment>{- 歸納假設 -}</comment>
     (z==x) || elem z xs
&lt;=&gt;   <comment>{- <code class="haskell">elem</code> 之定義 -}</comment>
     elem z (x:xs) 
</code></pre></div><p>讀者可注意：第1, 2, 4 步使用的邏輯關係都是 <code class="haskell">(&lt;=&gt;)</code> ，第 3 步卻是 <code class="haskell">(&lt;==)</code>，因此整個證明建立了「若<code class="haskell">elem z (x:xs)</code>，則<code class="haskell">elem z ((x:xs) ++ ys)</code>」。</p><div class="exlist"><div class="exercise exer" id="ex:weaken-not-elem"><h5 class="exercise-title">練習 2.16 </h5><p>證明 <code class="haskell">not (elem z (xs ++ ys)) ==&gt; not (elem z xs)</code>.</p></div><div class="exercise exer" id="ex:elem-catleft"><h5 class="exercise-title">練習 2.17 </h5><p>證明 <code class="haskell">elem z xs ==&gt; elem z (ys ++ xs)</code>.</p></div><div class="exercise exer" id="ex:all-monotonic"><h5 class="exercise-title">練習 2.18 </h5><p>證明<code class="haskell">(forall x . p x ==&gt; q x) ==&gt; all p xs ==&gt; all q xs</code>.&shy;其中 <code class="haskell">all</code> 的定義為：</p><pre><code class="spec">all :: (a -&gt; Bool) -&gt; List a -&gt; Bool
all p []      = True
all p (x:xs)  = p x ⋀ all p xs 
</code></pre></div><div class="exercise exer" id="ex:all-elem"><h5 class="exercise-title">練習 2.19 </h5><p>證明 <code class="haskell">all (`elem` xs) (filter p xs)</code>. 其中 <code class="haskell">x `elem` xs</code> 是 <code class="haskell">elem x xs</code> 的中序寫法。 我們可能需要習題 <a href="Induction.html#ex:elem-catleft">2.17 </a> 和 <a href="Induction.html#ex:all-monotonic">2.18 </a> 的結果，以及下述性質：</p><pre><code class="equation" id="eq:ifpxx">    |if p then x else x| = |x| \mbox{~~.}</code>    (2.10 )
</pre></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-19" type="checkbox"/><label class="lbl-toggle" for="ans-2-19">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>在 xs 上做歸納。</p><pre><code class="haskell">      all (`elem` (x:xs)) (filter p (x:xs))
 &lt;=&gt;  all (`elem` (x:xs)) (if p x then x:filter p xs else filter p xs)
 &lt;=&gt;  if p x  then all (`elem` (x:xs)) (x:filter p xs)
              else all (`elem` (x:xs)) (filter p xs)
 &lt;=&gt;  if p x  then x `elem` (x:xs) ⋀ all (`elem` (x:xs)) (filter p xs)
              else all (`elem` (x:xs)) (filter p xs)
 &lt;==  if p x  then all (`elem` (x:xs)) (filter p xs)
              else all (`elem` (x:xs)) (filter p xs)
 &lt;=&gt;     <comment>{- \eqref{eq:ifpxx} -}</comment>
      all (`elem` (x:xs)) (filter p xs)
 &lt;==     <comment>{- 因習題 \ref{ex:elem-catleft}, <code class="haskell">z `elem` (x:xs) &lt;== z `elem` xs</code> -}</comment>
      all (`elem` xs) (filter p xs)
 &lt;==  True 
</code></pre></div></div></div><h3 class="subsection" id="sec:list-segments">2.6.3 串列區段</h3><p><b>前段與後段</b> &emsp;&shy;本章目前為止討論的歸納定義都依循著這樣的模式：欲定義 <code class="haskell">f :: List a -&gt; b</code>, 只要為 <code class="haskell">f []</code> 與 <code class="haskell">f (x:xs)</code> 找到定義。在定義後者時，只需定義出由 <code class="haskell">f xs</code> 做出 <code class="haskell">f (x:xs)</code> 的關鍵一步。&shy;目前為止，這關鍵一步都是加一、加上一個元素等簡單的動作。現在我們來看些更複雜的例子。</p><p>例<a href="Basics.html#ex:inits">1.19 </a>中曾提及：如果一個串列 <code class="haskell">xs</code> 可分解為 <code class="haskell">ys ++ zs</code>, 我們說 <code class="haskell">ys</code> 是 <code class="haskell">xs</code> 的一個<em>前段(prefix)</em>,<span id="ix-2-11"></span>&shy;<code class="haskell">zs</code> 是 <code class="haskell">xs</code> 的一個<em>後段(suffix)</em>.<span id="ix-2-12"></span>&shy;例如，串列 <code class="haskell">[1,2,3]</code> 的前段包括 <code class="haskell">[]</code>, <code class="haskell">[1]</code>, <code class="haskell">[1,2]</code>, 與<code class="haskell">[1,2,3]</code> （注意：<code class="haskell">[]</code>是一個前段，串列 <code class="haskell">[1,2,3]</code> 本身也是）, 後段則包括 <code class="haskell">[1,2,3]</code>, <code class="haskell">[2,3]</code>, <code class="haskell">[3]</code>, 與 <code class="haskell">[]</code>。我們是否能定義一個函數 <code class="haskell">inits :: List a -&gt; List (List a)</code>, 計算給定串列的所有前段呢？&shy;例<a href="Basics.html#ex:inits">1.19 </a>給的答案是：</p><pre><code class="spec">inits xs = map (\n -&gt; take n xs) [0 .. length xs] 
</code></pre><p>如果不用組件，改用歸納定義呢？我們試試看：</p><pre><code class="spec">inits :: List a -&gt; List (List a)
inits []      = ?
inits (x:xs)  = ?
</code></pre><p>基底狀況 <code class="haskell">inits []</code> 的可能選擇是 <code class="haskell">[[]]</code> （見後述）。至於歸納步驟該怎麼寫？&shy;我們用例子來思考。比較 <code class="haskell">inits [2,3]</code> 與 <code class="haskell">inits [1,2,3]</code>:</p><pre><code class="spec">  inits [2,3]    = [[],[2],[2,3]] 
  inits [1,2,3]  = [[],[1],[1,2],[1,2,3]] 
</code></pre><p>假設我們已算出 <code class="haskell">inits [2,3]</code>, 如何把它加工變成 <code class="haskell">inits [1,2,3]</code>? 請讀者暫停一下，思考看看！</p><p>一個思路是：如果在 <code class="haskell">[[],[2],[2,3]]</code> 中的每個串列前面都補一個 <code class="haskell">1</code>, 我們就有了 <code class="haskell">[[1],[1,2],[1,2,3]]</code>. 再和 <code class="haskell">inits [1,2,3]</code> 比較，就只差一個空串列了！&shy;因此 <code class="haskell">inits</code> 的一種定義方式是：</p><pre><code class="haskell">inits :: List a -&gt; List (List a)
inits []      = [[]]
inits (x:xs)  = [] : map (x:) (inits xs) 
</code></pre><p>在此得提醒：有些讀者認為基底狀況 <code class="haskell">inits []</code> 的值選為 <code class="haskell">[[]]</code>，是因為結果的型別是 <code class="haskell">List (List a)</code>&shy;（直覺地把每個 <code class="haskell">List</code> 都對應到一組中括號，或認為 <code class="haskell">[[]]</code> 是型別為 <code class="haskell">List (List a)</code> 的最簡單的值）。&shy;但事實並非如此：畢竟，<code class="haskell">[]</code> 的型別也可以是 <code class="haskell">List (List a)</code>！&shy;我們讓 <code class="haskell">inits [] = [[]]</code> 的原因是空串列 <code class="haskell">[]</code> 的「所有前段」只有一個，恰巧也是 <code class="haskell">[]</code>。&shy;就如同在自然數上的歸納函數定義中，有些基底狀況是 <code class="haskell">0</code>, 有些是 <code class="haskell">1</code>, 有些是別的值，&shy;此處我們也依我們的意圖，選定最合適的基底值。</p><div class="exlist"><div class="exercise exer" id="ex:initsp"><h5 class="exercise-title">練習 2.20 </h5><p>試定義 <code class="haskell">initsp :: List a -&gt; List (List a)</code>, 計算一個串列的所有<em>非空前段</em>。例如 <code class="haskell">initsp [1,2,3]</code> 是 <code class="haskell">[[1],[1,2],[1,2,3]]</code>。當然，其中一個定義方式是 <code class="haskell">initsp = tail . inits</code>. 你能以歸納方式定義出 <code class="haskell">initsp</code> 嗎？</p><pre><code class="spec">initsp []      = ?
initsp (x:xs)  = ?
</code></pre></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-20" type="checkbox"/><label class="lbl-toggle" for="ans-2-20">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">initsp :: List a -&gt; List (List a)
initsp []      = []
initsp (x:xs)  = [x] : map (x:) (initsp xs) 
</code></pre></div></div><div class="exercise exer" id="ex:inits-upto"><h5 class="exercise-title">練習 2.21 </h5><p>我們驗證一下 <code class="haskell">inits</code> 在例<a href="Basics.html#ex:inits">1.19 </a> 中的組件定義與本章的歸納定義是相等的。定義 <code class="haskell">upto :: Nat -&gt; List Nat</code>:</p><pre><code class="haskell">upto Zero     = [Zero]
upto (Suc n)  = 0 : map (Suc) (upto n) 
</code></pre><p>使得 <code class="haskell">upto n = [0.. n]</code>.&shy;假設 <code class="haskell">inits</code> 已如本節一般地歸納定義，證明對所有 <code class="haskell">xs</code>,&shy;<code class="haskell">inits xs = map (\n -&gt; take n xs) (upto (length xs))</code>.&shy;您可能會需要 <code class="haskell">map</code> 融合定理（定理<a href="Induction.html#thm:map-fusion">2.2 </a>），</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-21" type="checkbox"/><label class="lbl-toggle" for="ans-2-21">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>在 <code class="haskell">xs</code> 上做歸納。</p><p><strong>情況</strong> <code class="haskell">xs := []</code>. 此時等號兩邊都是 <code class="haskell">[[]]</code>.</p><p><strong>情況</strong> <code class="haskell">xs := x:xs</code>.</p><pre><code class="haskell">    map (\n -&gt; take n (x:xs)) (upto (length (x:xs)))
 ===    <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
    map (\n -&gt; take n (x:xs)) (upto (Suc (length xs)))
 ===    <comment>{- <code class="haskell">upto</code> 之定義 -}</comment>
    map (\n -&gt; take n (x:xs)) (0 : map (Suc) (upto (length xs)))
 ===    <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
    map (\n -&gt; take n (x:xs)) (0 : map (Suc) (upto (length xs)))
 ===    <comment>{- <code class="haskell">map</code>之定義，<code class="haskell">take 0 (x:xs) = []</code> -}</comment>
    [] : map (\n -&gt; take n (x:xs)) (map (Suc) (upto (length xs)))
 ===    <comment>{- 定理\ref{thm:map-fusion}：<code class="haskell">map f . map g = map (f.g)</code> -}</comment>
    [] : map (\n -&gt; take (Suc n) (x:xs)) (upto (length xs))
 ===    <comment>{- <code class="haskell">take</code> 之定義 -}</comment>
    [] : map (\n -&gt; x : take n xs) (upto (length xs))
 ===    <comment>{- 定理\ref{thm:map-fusion}：<code class="haskell">map f . map g = map (f.g)</code> -}</comment>
    [] : map (x:) (map (\n -&gt; take n xs) (upto (length xs)))
 ===    <comment>{- 歸納假設 -}</comment>
    [] : map (x:) (inits xs)
 ===    <comment>{- <code class="haskell">inits</code> 之定義 -}</comment>
    inits (x:xs) 
</code></pre></div></div></div><p>定義傳回後段的函數 <code class="haskell">tails</code> 時可依循類似的想法：&shy;如何把 <code class="haskell">tails [2,3] = [[2,3],[3],[]]</code>加工，得到 <code class="haskell">tails [1,2,3] = [[1,2,3],[2,3],[3],[]]</code>?&shy;這次較簡單：加上 <code class="haskell">[1,2,3]</code> 即可。&shy;的確，串列 <code class="haskell">x:xs</code> 的後段包括 <code class="haskell">x:xs</code> 自己，以及 <code class="haskell">xs</code> 的後段：</p><pre><code class="haskell">tails :: List a -&gt; List (List a)
tails []      = [[]]
tails (x:xs)  = (x:xs) : tails xs 
</code></pre><p>在習題 <a href="Induction.html#ex:zip-inits-tails">2.45 </a> 中我們將證明一個將 <code class="haskell">inits</code> 與 <code class="haskell">tails</code> 牽上關係的定理：將 <code class="haskell">inits</code> 傳回的前段與 <code class="haskell">tails</code> 傳回的後段照其順序對應，每對接起來都是原來的串列。</p><p><b>連續區段</b> &emsp;&shy;給定一個串列，許多傳統最佳化問題的目標是計算符合某條件的<em>連續區段</em>（簡稱「區段」）。%&shy;<span id="ix-2-13"></span>&shy;例如，<code class="haskell">[1,2,3]</code> 的區段包括<code class="haskell">[]</code>,<code class="haskell">[1]</code>,<code class="haskell">[2]</code>,<code class="haskell">[3]</code>,<code class="haskell">[1,2]</code>,<code class="haskell">[2,3]</code>, 以及&shy;<code class="haskell">[1,2,3]</code>本身。&shy;我們可用 <code class="haskell">inits</code> 與 <code class="haskell">tails</code> 得到一個串列的所有區段。</p><pre><code class="haskell">segments :: List a -&gt; List (List a)
segments = concat . map inits . tails 
</code></pre><p>但 <code class="haskell">segments</code> 無法寫成本章目前這種形式的歸納定義。我們將在以後的章節再討論到 <code class="haskell">segments</code>.</p><div class="exlist"><div class="exercise exer" id="ex:segments-pattern"><h5 class="exercise-title">練習 2.22 </h5><p>試著把 <code class="haskell">segments</code> 寫成如下的歸納定義：</p><pre><code class="spec">segments :: List a -&gt; List (List a)
segments []      = ?
segments (x:xs)  = ... segments xs ... 
</code></pre><p>在歸納步驟中希望由 <code class="haskell">segments xs</code> 湊出 <code class="haskell">segments (x:xs)</code>。&shy;這是能在不對輸入串列（型別為<code class="haskell">List a</code>）做任何限制之下做得到的嗎？&shy;如果做不到，為什麼？</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-22" type="checkbox"/><label class="lbl-toggle" for="ans-2-22">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>考慮如何從 <code class="haskell">segments [1,2,3]</code> 湊出 <code class="haskell">segments [0,1,2,3]</code>.&shy;前者應當有的結果可能是：</p><pre><code class="spec">[[],[1],[1,2],[1,2,3],[2],[2,3],[3]] 
</code></pre><p>而 <code class="haskell">segments [0,1,2,3]</code> 的結果可能是：</p><pre><code class="spec">[[],[0],[0,1],[0,1,2],[0,1,2,3],[1],[1,2],[1,2,3],[2],[2,3],[3]] 
</code></pre><p>乍看之下，要多做的一步是：在空串列或所有<code class="haskell">1</code>開頭的串列前面補上 <code class="haskell">0</code>.&shy;之所以只擴充<code class="haskell">1</code>開頭的串列，因為只有這些是原本便靠在左邊，和 <code class="haskell">0</code> 相鄰的&shy;（也就是說它們是<code class="haskell">[1,2,3]</code>的前段）。</p><p>然而，當輸入串列型別為 <code class="haskell">List a</code>（而不是特定的 <code class="haskell">List Int</code>, <code class="haskell">List Char</code> 時），我們無法用比較的方式找出這些前段。函數 <code class="haskell">segments</code> 傳回的資訊不夠多。如果要歸納定義，我們必須把「前段」們和其他的區段分開。</p></div></div></div><h3 class="subsection" id="sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</h3><p><b>排列</b> &emsp;&shy;函數 <code class="haskell">fan x xs</code> 把 <code class="haskell">x</code> 插入 <code class="haskell">xs</code> 的每一個可能空隙。例如，<code class="haskell">fan 1 [2,3,4]</code> 可得到&shy;<code class="haskell">[[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1]]</code>. 讀者不妨想想它該怎麼定義？一種可能方式如下：</p><pre><code class="haskell">fan :: a -&gt; List a -&gt; List (List a)
fan x []      = [[x]]
fan x (y:xs)  = (x:y:xs) : map (y:) (fan x xs) 
</code></pre><p>有了 <code class="haskell">fan</code>, 我們不難定義 <code class="haskell">perms :: List a -&gt; List (List a)</code>, 計算一個串列所有可能&shy;的<em>排列</em>。例如，<code class="haskell">perms [1,2,3] = [[1,2,3], [2,1,3], [2,3,1], [1,3,2], [3,1,2], [3,2,1]]</code>：</p><pre><code class="haskell">perms :: List a -&gt; List (List a)
perms []      = [[]]
perms (x:xs)  = concat (map (fan x) (perms xs)) 
</code></pre><p>讀者可思考為何我們需要 <code class="haskell">concat</code>? 如果沒有，會出現什麼錯誤？</p><p>基於 <code class="haskell">perm</code> 的這個定義，我們證明一個定理：<em>長度為 <code class="haskell">n</code> 的串列有 <code class="haskell">fact n</code> 種排列</em>。&shy;這個證明將使用到許多輔助性質與引理，有些已經是我們之前證明過的習題，有些則可作為接下來的習題。&shy;在本證明之中我們也練習將連續的函數應用 <code class="haskell">f (g (h x))</code> 寫成函數合成&shy;<code class="haskell">f . g . h $ x</code> 以方便計算。</p><div class="theorem" id="thm:length-perms"><h5 class="theorem-title">定理 2.5  </h5><p>對任何 <code class="haskell">xs</code>, <code class="haskell">length (perms xs) = fact (length xs)</code>.</p></div><div class="proof"><b>證明 </b><p>在 <code class="haskell">xs</code> 上做歸納。</p><p>\noindent{\bf 基底狀況} <code class="haskell">xs:=[]</code>:</p><pre><code class="haskell">      length (perms [])
 ===  length [[]]
 ===  1
 ===  fact (length []) 
</code></pre><p>\noindent <strong>歸納步驟</strong> <code class="haskell">xs := x:xs</code>:</p><pre><code class="haskell">      length (perms (x:xs))
 ===    <comment>{- <code class="haskell">perms</code>, <code class="haskell">(.)</code>, 與 <code class="haskell">($)</code> 之定義 -}</comment>
      length . concat . map (fan x) . perms $ xs
 ===    <comment>{- 因 <code class="haskell">length . concat = sum . map length</code> (習題\ref{ex:length-concat}), <code class="haskell">map</code> 融合 -}</comment>
      sum . map (length . fan x) . perms $ xs
 ===    <comment>{- 因 <code class="haskell">length . fan x = (Suc) . length</code> (習題 \ref{ex:length-fan}) -}</comment>
      sum . map ((Suc) . length) . perms $ xs
 ===    <comment>{- 因 <code class="haskell">map length (perms xs) =</code>
 <code class="haskell">map (const (length xs)) (perms xs)</code> (習題\ref{ex:map-length-perms})  -}</comment>
      sum . map ((Suc) . const (length xs)) . perms $ xs
 ===    <comment>{- 因 <code class="haskell">sum (map (Suc) xs) = length xs + sum xs</code> (習題\ref{ex:sum-map-suc})-}</comment>
      length (perms xs) + sum (map (const (length xs)) (perms xs))
 ===    <comment>{- 因 <code class="haskell">sum (map (const y) xs) = y * length xs</code> (習題\ref{ex:sum-map-const}) -}</comment>
      length (perms xs) + length xs *: length (perms xs)
 ===    <comment>{- 四則運算: <code class="haskell">x + y * x = (1+y) * x</code> -}</comment>
      (Suc (length xs)) *: length (perms xs)
 ===    <comment>{- 歸納假設 -}</comment>
      (Suc (length xs)) *: fact (length xs)
 ===    <comment>{- <code class="haskell">fact</code> 之定義 -}</comment>
      fact (Suc (length xs))
 ===    <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
      fact (length (x:xs)) 
</code></pre></div><div class="exlist"><div class="exercise exer" id="ex:map-fan"><h5 class="exercise-title">練習 2.23 </h5><p>證明 <code class="haskell">map f . fan x = fan (f x) . map f</code>.</p></div><div class="exercise exer" id="ex:perm-map"><h5 class="exercise-title">練習 2.24 </h5><p>證明 <code class="haskell">perm . map f = map (map f) . perm</code>.</p></div><div class="exercise exer" id="ex:length-fan"><h5 class="exercise-title">練習 2.25 </h5><p>證明 <code class="haskell">length (fan x xs) = Suc (length xs)</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-25" type="checkbox"/><label class="lbl-toggle" for="ans-2-25">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>在 <code class="haskell">xs</code> 上做歸納。基底狀況很容易成立。考慮 <code class="haskell">xs := y:xs</code>:</p><pre><code class="haskell">      length (fan x (y:xs))
 ===  length ((x:y:xs) : map (y:) (fan x xs))
 ===  Suc (length (map (y:) (fan x xs)))
 ===   <comment>{- 因 <code class="haskell">length . map f = length</code> (練習 \ref{ex:length-map}) -}</comment>
      Suc (length (fan x xs))
 ===   <comment>{- 歸納假設 -}</comment>
      Suc (Suc (length xs))
 ===  Suc (length (y:xs)) 
</code></pre></div></div><div class="exercise exer" id="ex:map-length-perms"><h5 class="exercise-title">練習 2.26 </h5><p>證明 <code class="haskell">perms xs</code> 傳回的每個串列都和 <code class="haskell">xs</code> 一樣長，也就是 <code class="haskell">map length (perms xs) = map (const (length xs)) (perms xs)</code>.&shy;其中 <code class="haskell">const</code> 定義於第  頁 --- <code class="haskell">const y</code> 是一個永遠傳回 <code class="haskell">y</code> 的函數。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-26" type="checkbox"/><label class="lbl-toggle" for="ans-2-26">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>欲證明 <code class="haskell">map length (perms xs) = map (const (length xs)) (perms xs)</code>, 在 <code class="haskell">xs</code> 之上做歸納。基底狀況 <code class="haskell">xs := []</code> 中，等號兩邊都化約為 <code class="haskell">[0]</code>. 考慮歸納步驟 <code class="haskell">xs := x:xs</code>:</p><pre><code class="haskell">  map length (perms (x:xs))
 ===   <comment>{- <code class="haskell">perms</code> 之定義 -}</comment>
  map length . concat . map (fan x) . perms $ xs
 ===   <comment>{- <code class="haskell">map f . concat = concat . map (map f)</code> (習題\ref{ex:map-concat}), <code class="haskell">map</code> 融合 -}</comment>
  concat . map (map length . fan x) . perms $ xs
 ===   <comment>{- <code class="haskell">map length . fan x = (\n -&gt; repeatN n n) . length</code> -}</comment>
  concat . map ((\n -&gt; repeatN n n) . (Suc) . length) . perms $ xs
 ===   <comment>{- <code class="haskell">map</code> 融合 -}</comment>
  concat . map ((\n -&gt; repeatN n n) . (Suc)) . map length . perms $ xs
 ===   <comment>{- 歸納假設 -}</comment>
  concat . map ((\n -&gt; repeatN n n) . (Suc)) . map (const (length xs)) . perms $ xs
 ===   <comment>{- <code class="haskell">map</code> 融合 -}</comment>
  concat . map ((\n -&gt; repeatN n n) . (Suc) . const (length xs)) . perms $ xs
 ===   <comment>{- 歸約 $\lambda$ 算式 -}</comment>
  concat . map (repeatN (Suc (length xs)) . (Suc) . length) . perms $ xs
 ===   <comment>{- <code class="haskell">length . fan x = (Suc) . length</code> (習題\ref{ex:length-fan})-}</comment>
  concat . map (repeatN (Suc (length xs)) . length . fan x) . perms $ xs
 ===   <comment>{- \todo{???} <code class="haskell">map (const y) = repeatN y . length</code> -}</comment>
  concat . map (map (const (Suc (length xs))) . fan x) . perms $ xs
 ===   <comment>{- <code class="haskell">map f . concat = concat . map (map f)</code> (習題\ref{ex:map-concat}) -}</comment>
  map (const (length (x:xs))) . concat . map (fan x) . perms $ xs
 ===   <comment>{- <code class="haskell">perms</code> 之定義 -}</comment>
  map (const (length (x:xs))) (perms (x:xs)) 
</code></pre></div></div></div><p><b>子串列</b> &emsp;&shy;函數 <code class="haskell">sublists :: List a -&gt; List (List a)</code> 計算一個串列的所有<em>子串列</em>。&shy;後者是類似子集合的概念，只是把順序也考慮進去： <code class="haskell">ys</code> 是 <code class="haskell">xs</code> 的子串列，&shy;如果將 <code class="haskell">xs</code> 中的零個或數個元素移除後可得到 <code class="haskell">ys</code>:&shy;例如 <code class="haskell">sublists [1,2,3]</code> 的結果可能是： <code class="haskell">[[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]</code>。&shy;怎麼定義 <code class="haskell">sublists</code> 呢？在基底狀況中，空串列仍有一個子串列 <code class="haskell">[]</code>.&shy;歸納步驟中，<code class="haskell">x:xs</code> 的子串列可分為兩種：不含 <code class="haskell">x</code> 的，以及含 <code class="haskell">x</code> 的。&shy;不含 <code class="haskell">x</code> 的子串列就是 <code class="haskell">xs</code> 的所有子串列（以下稱作 <code class="haskell">yss</code>），&shy;而含 <code class="haskell">x</code> 的子串列就是 <code class="haskell">yss</code> 中的每個串列接上 <code class="haskell">x</code>. 因此我們可定義：</p><pre><code class="haskell">sublists :: List a -&gt; List (List a)
sublists []      = [[]]
sublists (x:xs)  = yss ++ map (x:) yss 
    where yss = sublists xs 
</code></pre><div class="exlist"><div class="exercise exer" id="ex:splits"><h5 class="exercise-title">練習 2.27 </h5><p>定義 <code class="haskell">splits :: List a -&gt; List (List a × List a)</code>，&shy;使 <code class="haskell">splits xs</code> 傳回所有滿足 <code class="haskell">ys ++ zs</code> 的 <code class="haskell">(ys,zs)</code>.&shy;例：</p><pre><code class="equation">   &|splits [1,2,3] = [([],[1,2,3]), ([1],[2,3]), ([1,2],[3]), ([1,2,3,[]])]|\mbox{~~.}</code>    (2.11 )
</pre><p>另一種說法是 <code class="haskell">splits xs = zip (inits xs) (tails xs)</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-27" type="checkbox"/><label class="lbl-toggle" for="ans-2-27">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">splits :: List a -&gt; List (List a × List a)
splits []      = [([],[])]
splits (x:xs)  = ([],x:xs) : map ((x:)***id) (splits xs) 
</code></pre><p>其中 <code class="haskell">(f *** g) (x,y) = (f x, g y)</code>, 定義於第 <a href="Basics.html#sec:pairs">1.6.3 </a> 節。</p></div></div><div class="exercise exer" id="ex:length-sublists"><h5 class="exercise-title">練習 2.28 </h5><p>證明 <code class="haskell">length . sublists = exp 2 . length</code>. 也就是說，長度為 <code class="haskell">n</code> 的串列的子串列數目為 $2^n$. 你會需要的性質可能包括 ([RefUndefined]) (<code class="haskell">length (xs++ys) = length xs + length ys</code>), 以及 <code class="haskell">length . map f = length</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-28" type="checkbox"/><label class="lbl-toggle" for="ans-2-28">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>將式子改寫為 <code class="haskell">length (sublists xs) = exp 2 (length xs)</code>, 在 <code class="haskell">xs</code> 上做歸納。&shy;歸納步驟 <code class="haskell">xs := x:xs</code> 為：</p><pre><code class="haskell">      length (sublists (x:xs))
 ===  length (sublists xs ++ map (x:) (sublists xs))
 ===    <comment>{- 因 \eqref{eq:length-append} <code class="haskell">length (xs++ys) = length xs + length ys</code>  -}</comment>
      length (sublists xs) + length (map (x:) (sublists xs))
 ===    <comment>{- 因 <code class="haskell">length . map = length</code> (練習 \ref{ex:length-map})-}</comment>
      length (sublists xs) + length (sublists xs)
 ===    <comment>{- 因 <code class="haskell">x + x = 2 * x</code> -}</comment>
      2 *: length (sublists xs)
 ===    <comment>{- 歸納步驟 -}</comment>
      2 *: exp 2 (length xs)
 ===  exp 2 (Suc (length xs))
 ===  exp 2 (length (x:xs)) 
</code></pre></div></div></div><p><b>劃分</b> &emsp;&shy;給定串列 <code class="haskell">xs :: List a</code>. 如果 <code class="haskell">yss :: List (List a)</code> 滿足</p><ol><li><p><code class="haskell">concat yss = xs</code>,</p></li><li><p><code class="haskell">yss</code> 中的每個串列都不是空的，&shy;我們便說 <code class="haskell">yss</code> 是 <code class="haskell">xs</code> 的一個<em>劃分</em>(<em>partition</em>)。&shy;例如，<code class="haskell">[[1],[2,3],[4]]</code> 是 <code class="haskell">[1,2,3,4]</code> 的一個劃分。<span id="ix-2-14"></span></p></li></ol><p>我們是否能定義一個函數 <code class="haskell">parts :: List a -&gt; List (List (List a))</code>,&shy;計算一個串列<em>所有的</em>劃分？&shy;可能的方式有很多，其中一種思路如下。首先，空串列 <code class="haskell">[]</code> 只有一個可能的劃分，即是 <code class="haskell">[]</code>.&shy;考慮 <code class="haskell">x:xs</code>, 如果 <code class="haskell">xs</code> 已經被劃分完畢，對於 <code class="haskell">x</code> 我們有兩個選擇：讓它成為單獨的串列，&shy;或著將 <code class="haskell">xs</code> 加入最左邊的串列。&shy;寫成歸納定義如下：</p><pre><code class="haskell">parts :: List a -&gt; List (List (List a))
parts []      = [[]]
parts (x:xs)  = concat (map (extend x) (parts xs)) 
  where  extend x []        = [[[x]]]
         extend x (ys:yss)  = [[x]:ys:yss, (x:ys):yss] 
</code></pre><p>遞迴呼叫 <code class="haskell">parts xs</code> 找出 <code class="haskell">xs</code> 的所有劃分，&shy;輔助函數 <code class="haskell">extend x :: List (List a) -&gt; List (List (List a))</code> 則作用在其中一個劃分上。&shy;我們得分出兩個狀況：</p><ol><li><p>如果該劃分含第一個串列 <code class="haskell">ys</code> 和剩下的 <code class="haskell">yss</code>, 我們可選擇讓 <code class="haskell">x</code> 自成一個串列，或著加入 <code class="haskell">ys</code> 中。&shy;我們把這兩種選擇收集到一個串列中，因此 <code class="haskell">extend</code> 的結果有三層 <code class="haskell">List</code>。</p></li><li><p>如果該劃分是空的，加入 <code class="haskell">x</code> 的劃分必定是 <code class="haskell">[[x]]</code>，但仍需放入一個串列中，表示「只有這一個選擇」。</p></li></ol><p>呼叫 <code class="haskell">map (extend x)</code> 的結果需再用一個 <code class="haskell">concat</code> 聯集在一起。</p><div class="infobox infobox" title="反函數"><h5 class="infobox-title">反函數</h5><p>假設我們有一個取反函數的運算元：給定 <code class="haskell">f :: a -&gt; b</code>, 其反函數 <code class="haskell">inv f</code> 的型別是 <code class="haskell">b -&gt; List a</code>。&shy;<code class="haskell">inv f y</code> 將所有使得 <code class="haskell">f x = y</code> 的 <code class="haskell">x</code> 收集在串列中。&shy;則 <code class="haskell">parts</code> 可以有一個更接近本節中文字描述的定義：</p><pre><code class="spec">  parts = filter (all (not . null)) . inv concat 
</code></pre><p>計算 <code class="haskell">parts xs</code> 時，我們用 <code class="haskell">inv concat</code> 找出所有滿足 <code class="haskell">concat yss = xs</code> 的 <code class="haskell">List (List a)</code>, 並且只挑出不含空串列的。</p><p>上述定義可以轉換成本節的歸納定義。相關研究可參考 <a href="Biblio.html#MuBird:03:Theory">Mu and Bird [2003]</a>.</p></div><h2 class="section" id="sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</h2><p>看了這麼多歸納定義，我們做個較複雜的練習，並以此為例再談談「讓符號為你工作」。&shy;本節在初次閱讀時可略過。</p><p>以下的函數 <code class="haskell">ins</code> 將一個元素插到一個串列的空隙中。它和第<a href="Induction.html#sec:fan-perm">2.6.4 </a>節中的 <code class="haskell">fan</code> 類似但稍有不同 --- <code class="haskell">ins x xs</code> 不會把 <code class="haskell">x</code> 放到 <code class="haskell">xs</code> 的結尾。%&shy;<input class="toggle" id="footnote-2-7-8" type="checkbox"/><label class="fnote-toggle" for="footnote-2-7-8">(註8) </label><span class="collapsible-footnote">本節不使用 <code class="haskell">fan</code> 而另外定義了 <code class="haskell">ins</code> 的原因僅是因為如此使得性質 ([RefUndefined]) 較單純而方便說明。</span>&shy;例如：<code class="haskell">ins 1 [2,3,4] = [[1,2,3,4],[2,1,3,4],[2,3,1,4]]</code>。</p><pre><code class="haskell">ins :: a -&gt; List a -&gt; List (List a)
ins x []      = []
ins x (y:ys)  = (x:y:ys) : map (y:) (ins x ys) 
</code></pre><p>請證明對所有 <code class="haskell">x</code>, <code class="haskell">ys</code>, 與 <code class="haskell">zs</code>,</p><pre><code class="equation" id="eq:append-ins">  |map (++zs) (ins x ys) ++  map (ys++) (ins x zs)| &= |ins x (ys ++ zs) |</code>    (2.12 )
</pre><p>意即：在 <code class="haskell">ys ++ zs</code> 之中插入 <code class="haskell">x</code> 的所有方法，&shy;是 1. 把 <code class="haskell">x</code> 插入 <code class="haskell">ys</code> 之中，並把每個結果的右邊接上 <code class="haskell">zs</code>,&shy;以及 2. 把 <code class="haskell">x</code> 插入 <code class="haskell">zs</code> 之中，並把每個結果的左邊接上 <code class="haskell">ys</code>.</p><p>面對一個如此冗長的式子，我們該如何著手？我們可猜想如此複雜的性質大概會需要歸納證明。&shy;但在哪個變數上做歸納呢？&shy;觀察([RefUndefined])，等號左手邊最外側的運算子是<code class="haskell">(++)</code>。&shy;計算 <code class="haskell">(++)</code> 時，根據定義，先被樣式配對的是 <code class="haskell">(++)</code> 左邊的參數，也就是 <code class="haskell">map (++zs) (ins x ys)</code>。&shy;再來，根據 <code class="haskell">map</code> 的定義，<code class="haskell">map (++zs) (ins x ys)</code> 的運算要有進展，得先把 <code class="haskell">ins x ys</code> 算出來。&shy;最後，根據 <code class="haskell">ins</code> 的定義，計算 <code class="haskell">ins x ys</code> 會先拆開 <code class="haskell">ys</code>.&shy;由此可知，等號左手邊的運算是從拆解 <code class="haskell">ys</code> 開始的。&shy;等號右手邊的情況也一樣：根據 <code class="haskell">ins</code> 與 <code class="haskell">(++)</code> 的定義，要計算 <code class="haskell">ins x (ys ++ zs)</code>，第一個被拆開的是 <code class="haskell">ys</code>. 因此，欲證明([RefUndefined])，合理的猜測是在 <code class="haskell">ys</code> 上做歸納！</p><p>我們省略 <code class="haskell">ys := []</code> 的情況，僅考慮歸納情況 <code class="haskell">ys := y:ys</code>。&shy;經代換後的式子是 <code class="haskell">map (++zs) (ins x (y:ys)) ++ map ((y:ys) ++) (ins x zs)</code>.&shy;我們採取的策略和證明定理<a href="Induction.html#thm:exp-plus-times">2.1 </a>時一樣：&shy;<em>想辦法湊出 <code class="haskell">map (++zs) (ins x ys) ++  map (ys++) (ins x zs)</code>, 以便使用歸納假設</em>。&shy;由此論證如下（步驟加上編號以利說明）：</p><pre><code class="haskell">     map (++zs) (ins x (y:ys)) ++ map ((y:ys) ++) (ins x zs)
 ===     <comment>{- 1. <code class="haskell">ins</code> 與 <code class="haskell">map</code> 之定義 -}</comment>
     (x:y:ys++zs) : map (++zs) (map (y:) (ins x ys)) ++ map ((y:ys) ++) (ins x zs)
 ===     <comment>{- 2. <code class="haskell">map</code> 融合 -}</comment>
     (x:y:ys++zs) : map ((++zs) . (y:)) (ins x ys) ++ map ((y:ys) ++) (ins x zs)
 ===     <comment>{- 3. 由於 <code class="haskell">(++zs) . (y:) = (y:) . (++zs)</code> (習題 \ref{ex:append-cons}) -}</comment>
     (x:y:ys++zs) : map ((y:) . (++zs)) (ins x ys) ++ map ((y:ys) ++) (ins x zs)
 ===     <comment>{- 4. <code class="haskell">map</code> 融合 -}</comment>
     (x:y:ys++zs) : map (y:) (map (++zs) (ins x ys)) ++ map ((y:ys) ++) (ins x zs)
 ===     <comment>{- 5. 由於 <code class="haskell">((y:ys)++) = (y:).(ys++)</code> (習題 \ref{ex:cons-append}) -}</comment>
     (x:y:ys++zs) : map (y:) (map (++zs) (ins x ys)) ++ map ((y:).(ys++)) (ins x zs)
 ===     <comment>{- 6. <code class="haskell">map</code> 融合 -}</comment>
     (x:y:ys++zs) : map (y:) (map (++zs) (ins x ys)) ++ map (y:) (map (ys++) (ins x zs))
 ===     <comment>{- 7. 由於 <code class="haskell">map f (xs ++ ys) = map f xs ++ map f ys</code> -}</comment>
     (x:y:ys++zs) : map (y:) (map (++zs) (ins x ys) ++ map (ys++) (ins x zs))
 ===     <comment>{- 8. 歸納假設 -}</comment>
     (x:y:ys++zs) : map (y:) (ins x (ys ++ zs))
 ===     <comment>{- 9. <code class="haskell">ins</code> 與 <code class="haskell">(++)</code> 之定義 -}</comment>
     ins x ((y:ys)++zs) 
</code></pre><p>雖然步驟多、式子長，但策略確定後，整個證明的架構便很清楚。第 1 到 7 步都是為了可在第 8 步使用歸納而做的準備。&shy;為湊出 <code class="haskell">map (++zs) (ins x ys) ++ map (ys++) (ins x zs)</code>, 第 2 至第 4 步把 <code class="haskell">map (++zs)</code> 往裡推，把第一個 <code class="haskell">map (y:)</code> 往外提；第 5, 6 步則提出另一個 <code class="haskell">map (y:)</code>。式子變成 <code class="haskell">map (y:) ... ++ map (y:) ...</code> 的形式後，共同的 <code class="haskell">map (y:)</code> 可在第 7 步提出來。&shy;如此，終於可使用歸納假設了。&shy;<em>整個證明中，要配對哪個變數、把式子中的哪些項往哪兒移動，都被符號引導著而有線索可循。</em>&shy;證明中用到的兩個性質 <code class="haskell">(++zs) . (y:) = (y:) . (++zs)</code> 與 <code class="haskell">((y:ys)++) = (y:).(ys++)</code> 並非天外飛來，而是確立了目標後，因為有需求（兩者分別讓我們把 <code class="haskell">(++zs)</code> 與 <code class="haskell">(ys++)</code> 往右推，把 <code class="haskell">(y:)</code> 往左拉）而設計出並另外證明的性質。</p><p>初學者常犯的一個錯誤是：以為所有情況下、所有的變數都需要樣式配對。&shy;事實上，<em>過度的樣式配對是形式證明中希望避免的</em>。&shy;藉由觀察 ([RefUndefined])，我們決定對 <code class="haskell">ys</code> 做歸納，證明過程中發現如此便已經足夠。&shy;如果我們對 <code class="haskell">ys</code> 和 <code class="haskell">zs</code> 都做配對，將必須處理四種情況：<code class="haskell">ys,zs := [],[],[]</code>, <code class="haskell">ys,zs := [],z:zs</code>, <code class="haskell">ys,zs := [],z:zs</code> <code class="haskell">ys,zs := y:ys,z:zs</code>。一個待證明的性質若有 <code class="haskell">n</code> 個串列，似乎得分出 $2^n$ 種情況 --- 只有萬不得已我們才會這麼做。</p><p>最嚴重的問題並不是情況數目太多，而是過度的樣式配對破壞了證明的結構。&shy;如果對 <code class="haskell">zs</code> 做配對，許多人會很自然地想把 <code class="haskell">ins x (z:zs)</code> 展開。&shy;證明可能如此進行：</p><pre><code class="haskell">   map (++(z:zs)) (ins x (y:ys)) ++ map ((y:ys) ++) (ins x (z:zs))
 ===   <comment>{- 將 <code class="haskell">(++)</code> 的左手邊展開 -}</comment>
   (x:y:ys++(z:zs)) : map (++(z:zs)) (map (y:) (ins x ys)) ++
     map ((y:ys) ++) (ins x (z:zs))
 ===   <comment>{- 展開 <code class="haskell">ins x (z:zs)</code> -}</comment>
   (x:y:ys++(z:zs)) : map (++(z:zs)) (map (y:) (ins x ys)) ++
     map ((y:ys) ++) ((x:z:zs) : map (z:) (ins x zs))
 ===   <comment>{- <code class="haskell">map</code> 的定義 -}</comment>
   (x:y:ys++(z:zs)) : map (++(z:zs)) (map (y:) (ins x ys)) ++
     ((y:ys ++ (x:z:zs)) : map ((y:ys) ++) (map (z:) (ins x zs))) 
</code></pre><p>要從這樣的式子中再整理出&shy;<code class="haskell">map (++(z:zs)) (ins x (y:ys)) ++ map ((y:ys) ++) (ins x (z:zs))</code>&shy;以便做歸納假設，&shy;我們得看出如何把（本來不需展開的）<code class="haskell">ins x (z:zs)</code> 給收回來。&shy;式子的結構已經被破壞，操作起來的難度便大大提高了。&shy;<input class="toggle" id="footnote-2-7-9" type="checkbox"/><label class="fnote-toggle" for="footnote-2-7-9">(註9) </label><span class="collapsible-footnote">這其實是我於 2019 年開設的程式語言課程的期末考題。在十數位將 <code class="haskell">ins x (z:zs)</code> 展開的同學中，只有一位成功地將它收了回來。</span></p><div class="exlist"><div class="exercise exer" id="ex:cons-append"><h5 class="exercise-title">練習 2.29 </h5><p>證明：對所有 <code class="haskell">y</code> 與 <code class="haskell">ys</code>, <code class="haskell">(y:).(ys++) = ((y:ys)++)</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-29" type="checkbox"/><label class="lbl-toggle" for="ans-2-29">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="spec">   ((y:).(ys++)) xs
=   <comment>{- definition of <code class="haskell">(.)</code> -}</comment>
   y : (ys ++ xs)
=   <comment>{- definition of <code class="haskell">(++)</code> -}</comment>
   (y : ys) ++ xs 
</code></pre></div></div><div class="exercise exer" id="ex:append-cons"><h5 class="exercise-title">練習 2.30 </h5><p>證明：對所有 <code class="haskell">y</code> 與 <code class="haskell">zs</code>, <code class="haskell">(++zs) . (y:) = (y:) . (++zs)</code>.&shy;以上兩者都是不需歸納、也不須狀況分析的單純證明。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-30" type="checkbox"/><label class="lbl-toggle" for="ans-2-30">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="spec">  ((++zs) . (y:)) xs
=   <comment>{- definition of <code class="haskell">(.)</code> -}</comment>
  (++zs) (y:xs)
= (y:xs) ++ zs
=   <comment>{- definition of <code class="haskell">(++)</code> -}</comment>
   y :(xs ++ zs)
=  (y:) ((++ zs) xs)
=   <comment>{- definition of <code class="haskell">(.)</code> -}</comment>
   ((y:) . (++zs)) xs 
</code></pre></div></div></div><h2 class="section" id="sec:other-inductive-datatypes">2.8 其他歸納資料結構</h2><p>不僅自然數與串列，歸納式的函數定義與證明可用在所有歸納定義的資料結構上。&shy;以第<a href="Basics.html#sec:user-defined-data">1.10 </a>節提及的兩種二元樹為例：</p><pre><code class="spec">data ITree a  = Null | Node a (ITree a) (ITree a) 
data ETree a  = Tip a | Bin (ETree a) (ETree a) 
</code></pre><p>型別 <code class="haskell">ETree</code> 可讀解為一個歸納資料結構，我們可在它之上以歸納法定義函數。&shy;例如，下述的函數 <code class="haskell">minE</code> 計算一個 <code class="haskell">ETree</code> 中最小的元素，<code class="haskell">mapE f</code> 則將函數 <code class="haskell">f</code> 作用在樹中的每個元素上。</p><pre><code class="haskell">minE :: ETree Int -&gt; Int
minE (Tip x)    = x
minE (Bin t u)  = minE t ↓ minE u 

mapE :: (a -&gt; b) -&gt; ETree a -&gt; ETree b
mapE f (Tip x)    = Tip (f x)
mapE f (Bin t u)  = Bin (mapE f t) (mapE f u) 
</code></pre><p>我們也有如下的歸納原則：</p><pre><code class="equation" title="ETree 上之歸納法：">  |(forall t :: ETree a . P t)  &lt;== <comment>{-"~\\\qquad"-}</comment>|
  |(forall x . P (Tip x)) ⋀ (forall t u . P (Bin t u) &lt;== P t ⋀ P u) |</code>    (2.13 )
</pre><p>作為例子，我們證明下列性質：</p><pre><code class="spec">  minE (mapE (x +) t) = x + minE t 
</code></pre><p>左手邊將樹中的每個元素都加上 <code class="haskell">x</code>, 然後取最小的。右手邊則告訴我們不必這麼麻煩，先取最小的，再加上 <code class="haskell">x</code> 即可！</p><div class="proof"><b>證明 </b><p>基底狀況 <code class="haskell">t := Tip y</code> 很容易成立。至於歸納狀況 <code class="haskell">t := Bin t u</code>,&shy;使其成立的關鍵性質是加法可分配至 <code class="haskell">(↓)</code> 中：<code class="haskell">x + (y ↓ z) = (x+y) ↓ (x+z)</code>:</p><pre><code class="haskell">    minE (mapE (x +) (Bin t u))
 ===   <comment>{- <code class="haskell">mapE</code> 與 <code class="haskell">minE</code> 之定義 -}</comment>
    minE (mapE (x+) t) ↓ minE (mapE (x+) u)
 ===   <comment>{- 歸納假設 -}</comment>
    (x + minE t) ↓ (x + minE u)
 ===   <comment>{- 算術：加法分配至 <code class="haskell">(↓)</code> 中 -}</comment>
    x + (minE t ↓ minE u)
 ===   <comment>{- <code class="haskell">minE</code> 之定義 -}</comment>
    x + minE (Bin t u) 
</code></pre></div><div class="exlist"><div class="exercise exer" id="ex:ITree-principle"><h5 class="exercise-title">練習 2.31 </h5><p>請寫出 <code class="haskell">ITree</code> 的歸納原則？</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-31" type="checkbox"/><label class="lbl-toggle" for="ans-2-31">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="equation" title="ITree 上之歸納法：">  |(forall t :: ITree a . P t)  &lt;== <comment>{-"~\\\qquad"-}</comment>|
    |(P Null ⋀ (forall x t u . P (Node x t u) &lt;== P t ⋀ P u) |</code>    (2.14 )
</pre></div></div><div class="exercise exer" id="ex:ITree-mapI"><h5 class="exercise-title">練習 2.32 </h5><p>定義函數 <code class="haskell">mapI :: (a -&gt; b) -&gt; ITree a -&gt; ITree b</code>, 使得 <code class="haskell">mapI f</code> 則將函數 <code class="haskell">f</code> 作用在樹中的每個元素上。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-32" type="checkbox"/><label class="lbl-toggle" for="ans-2-32">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">mapI :: (a -&gt; b) -&gt; ITree a -&gt; ITree b
mapI f Null          = Null
mapI f (Node x t u)  = Node (f x) (mapI f t) (mapI f u) 
</code></pre></div></div><div class="exercise exer" id="ex:ITree-tags"><h5 class="exercise-title">練習 2.33 </h5><p>試定義函數 <code class="haskell">tags :: ITree a -&gt; List a</code>, 由左至右傳回給定之 <code class="haskell">ITree</code> 的所有標籤。例如，若</p><pre><code class="spec">  t = Node 3  (Node 2 (Node 1 Null Null) Null)
              (Node 5  (Node 4 Null Null)
                       (Node 6 Null Null)) 
</code></pre><p>則 <code class="haskell">tags t = [1,2,3,4,5,6]</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-33" type="checkbox"/><label class="lbl-toggle" for="ans-2-33">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">tags :: ITree a -&gt; List a
tags Null          = []
tags (Node x t u)  = tags t ++ [x] ++ tags u 
</code></pre></div></div><div class="exercise exer" id="ex:ITree-size"><h5 class="exercise-title">練習 2.34 </h5><p>試定義函數 <code class="haskell">size :: ITree a -&gt; Int</code>, 傳回給定的 <code class="haskell">ITree</code> 之標籤數目 --- 例如 <code class="haskell">size Null = 0</code>, <code class="haskell">size (Node 3 Null (Node 4 Null Null)) = 2</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-34" type="checkbox"/><label class="lbl-toggle" for="ans-2-34">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">size :: ITree a -&gt; Nat
size Null          = Zero
size (Node x t u)  = Suc (size t + size u) 
</code></pre></div></div><div class="exercise exer" id="ex:ITree-length-size"><h5 class="exercise-title">練習 2.35 </h5><p>接續前兩題，證明 <code class="haskell">length (tags t) = size t</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-35" type="checkbox"/><label class="lbl-toggle" for="ans-2-35">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>在 <code class="haskell">t</code> 之上做歸納。當 <code class="haskell">t := Null</code>，顯然等號兩邊都歸約為 <code class="haskell">0</code>.&shy;當 <code class="haskell">t := Node x t u</code>:</p><pre><code class="haskell">      length (tags (Node x t u))
 ===    <comment>{- <code class="haskell">length</code> 與 <code class="haskell">leaves</code> 之定義 -}</comment>
      Suc (length (tags t) + length (tags u))
 ===    <comment>{- 歸納假設 -}</comment>
      Suc (size t + size u)
 ===    <comment>{- <code class="haskell">size</code> 之定義 -}</comment>
      size (Node x t u) 
</code></pre></div></div></div><h2 class="section" id="sec:induction-set-theory">2.9 由集合論看歸納法</h2><p>歸納證明為何成立？本節試圖以集合論的角度理解歸納法，試圖建立幾個觀念：當我們說某型別是「歸納定義」的，常常代表它是具有某個結構的最小集合。而歸納證明可以理解為證明某型別是所有滿足某性質的事物的子集。本節於初次閱讀時可跳過。</p><p><b>序理論回顧</b> &emsp; 為了本章的完整性，我們在這兒回顧一些重要定義。&shy;對學過序理論或抽象代數的讀者來說，以下概念應不陌生。&shy;如果您還不熟悉這些定義，由於它們在程式語言語意中常常使用，值得花些時間弄懂。</p><div class="theorem" id="def:preorder" title="前序、偏序"><h5 class="theorem-title">定義 2.6  前序、偏序 </h5><p>給定集合$S$, 令 $(\leq)$ 為 $S$ 上的一個二元關係。如果 $(\leq)$ 滿足：</p><ul><li><p><em>自反律</em>：對所有 $x \in S$, <code class="haskell">x &lt;= x</code>.<span id="ix-2-15"></span></p></li><li><p><em>遞移律</em>：對所有 $x,y,z \in S$, <code class="haskell">x &lt;= y ⋀ y &lt;= z ==&gt; x &lt;= z</code>,<span id="ix-2-16"></span></p></li></ul><p>則 $(\leq)$ 被稱為$S$ 上的一個<em>前序</em>(<em>preorder</em>).&shy;<span id="ix-2-17"></span>&shy;如果 $(\leq)$ 除上述兩性質外還滿足：</p><ul><li><p><em>反對稱律</em>：對所有 $x,y \in S$, <code class="haskell">x &lt;= y ⋀ y &lt;= x ==&gt; x = y</code>.</p></li></ul><p>則 $(\leq)$ 被稱為$S$ 上的一個<em>偏序</em>(<em>partial order</em>).&shy;<span id="ix-2-18"></span>&shy;如果 $S$ 上有偏序 $(\leq)$, 我們常把它們放在一起，稱 $(S,(\leq))$ 為一個<em>偏序集合</em>(<em>partially ordered set</em>, 或 <em>poset</em>).&shy;<span id="ix-2-19"></span>&shy;<span id="ix-2-20"></span></p></div><div class="theorem" id="def:min-max-bound" title="最小上界、最大下界"><h5 class="theorem-title">定義 2.7  最小上界、最大下界 </h5><p>給定偏序集合 $(S,(\leq))$，考慮其子集 $T \subseteq S$:</p><ul><li><p>如果 $x \in S$ 滿足 $(\forall y \in T: y \leq x)$, 則 $x$ 是 $T$ 的一個<em>上界</em>(<em>upper bound</em>).&shy;<span id="ix-2-21"></span></p></li><li><p>如果 $T$ 的所有上界中存在「最小」的，該值稱作 $T$ 的<em>最小上界</em>(<em>supremum</em>, 或 <em>least upper bound</em>), 記為 $\Varid{sup}~T$.&shy;<span id="ix-2-22"></span>&shy;<span id="ix-2-23"></span>&shy;依據定義，$\Varid{sup}~T$ 滿足 $(\forall y \in T: y \leq x) \Rightarrow \Varid{sup}~T \leq x$.</p></li><li><p>如果 $x \in S$ 滿足 $(\forall y \in T: y \geq x)$, 則 $x$ 是 $T$ 的一個<em>下界</em>(<em>lower bound</em>).&shy;<span id="ix-2-24"></span></p></li><li><p>如果 $T$ 的所有下界存在「最大」的，該值稱作 $T$ 的<em>最大下界</em>(<em>infimum</em>, 或<em>greatest lower bound</em>), 記為 $\Varid{inf}~T$.&shy;<span id="ix-2-25"></span>&shy;<span id="ix-2-26"></span>&shy;依據定義，$\Varid{inf}~T$ 滿足 $(\forall y \in T: y \geq x) \Rightarrow \Varid{inf}~T \geq x$.</p></li></ul></div><div class="theorem" id="def:lattice" title="格、完全格"><h5 class="theorem-title">定義 2.8  格、完全格 </h5><p>考慮偏序集合 $(S,(\leq))$:</p><ul><li><p>如果對任何 $x, y \in S$, <code class="haskell">sup {x,y}</code> 和 <code class="haskell">inf {x,y}</code> 均存在且都在 $S$ 之中，則 $(S,(\leq))$ 是一個格 (lattice)。&shy;<span id="ix-2-27"></span></p></li><li><p>如果對任何 $T \subseteq S$，$\Varid{sup}~T$ 和 $\Varid{inf}~T$ 均存在且都在 $S$ 之中，則 $(S,(\leq))$ 是一個完全格 (complete lattice)。&shy;<span id="ix-2-28"></span></p></li></ul></div><p>在本節之中我們只會考慮一種格。令 $D$ 代表所有範式（如 <code class="haskell">Zero</code>, <code class="haskell">Suc Zero</code>, <code class="haskell">True</code>, <code class="haskell">1 : 2 : []</code>, <code class="haskell">(\x -&gt; x)</code>...）的集合，我們考慮的格是 ${\cal P}D$，即 $D$ 的所有子集形成的集合。其上的偏序就是子集關係 $(\subseteq)$.</p><p><b>定點</b> &emsp; 再回顧一些與<em>定點</em>相關的理論。</p><div class="theorem" id="def:fixed-point" title="定點"><h5 class="theorem-title">定義 2.9  定點 </h5><p>給定完全格 <code class="haskell">(A, (&lt;=))</code> 和函數 <code class="haskell">f :: A -&gt; A</code>,</p><ol><li><p>如果 <code class="haskell">f x &lt;= x</code>, 我們說 <code class="haskell">x</code> 是 <code class="haskell">f</code> 的一個<em>前定點</em> (<em>prefixed point</em>).&shy;<span id="ix-2-29"></span></p></li><li><p>如果 <code class="haskell">f x = x</code>, 我們說 <code class="haskell">x</code> 是 <code class="haskell">f</code> 的一個<em>定點</em> (<em>fixed point</em>).<span id="ix-2-30"></span></p></li><li><p>如果 <code class="haskell">f x &gt;= x</code>, 我們說 <code class="haskell">x</code> 是 <code class="haskell">f</code> 的一個<em>後定點</em> (<em>postfixed point</em>).</p></li></ol></div><div class="theorem" id="def:mu-nu" title="最小前定點、最大後定點"><h5 class="theorem-title">定義 2.10  最小前定點、最大後定點 </h5><p>給定完全格 <code class="haskell">(A, (&lt;=))</code> 和函數 <code class="haskell">f :: A -&gt; A</code>,</p><ul><li><p>如果 <code class="haskell">f</code> 的前定點之中存在最小值，我們將它記為 <code class="haskell">mu f</code>.&shy;根據此定義，<code class="haskell">mu f</code> 滿足 <code class="haskell">f x &lt;= x ==&gt; mu f &lt;= x</code>.&shy;<span id="ix-2-31"></span></p></li><li><p>如果 <code class="haskell">f</code> 的後定點之中存在最大值，我們將它記為 <code class="haskell">nu f</code>.&shy;根據此定義，<code class="haskell">nu f</code> 滿足 <code class="haskell">x &lt;= f x ==&gt; x &lt;= nu f</code>.&shy;<span id="ix-2-32"></span></p></li></ul></div><div class="theorem" id="thm:f-muf"><h5 class="theorem-title">定理 2.11  </h5><p>給定完全格 <code class="haskell">(A, (&lt;=))</code> 和函數 <code class="haskell">f :: A -&gt; A</code>,</p><ul><li><p><code class="haskell">f</code> 的最小前定點 <code class="haskell">mu f</code> 也是最小的定點，</p></li><li><p><code class="haskell">f</code> 的最小前定點 <code class="haskell">nu f</code> 也是最大的定點。</p></li></ul></div><p><b>歸納定義</b> &emsp; 回顧自然數的定義：</p><pre><code class="spec">  data Nat = Zero | Suc Nat 
</code></pre><p>第<a href="Induction.html#sec:math-induction">2.1 </a>節對這行定義的解釋是：</p><ol><li><p><code class="haskell">Zero</code> 的型別是 <code class="haskell">Nat</code>;</p></li><li><p>如果 <code class="haskell">n</code> 的型別是 <code class="haskell">Nat</code>, <code class="haskell">Suc n</code> 的型別也是 <code class="haskell">Nat</code>;</p></li><li><p>此外，沒有其他型別是 <code class="haskell">Nat</code> 的東西。</p></li></ol><p>如果我們把一個型別視作一個集合，上述條件定出了怎麼樣的集合呢？&shy;<input class="toggle" id="footnote-2-9-10" type="checkbox"/><label class="fnote-toggle" for="footnote-2-9-10">(註10) </label><span class="collapsible-footnote">請注意：「把型別視為集合」僅在簡單的語意之中成立。本書後來將會討論更複雜的語意，屆時型別並不只是集合。</span>&shy;用 <code class="haskell">Nat</code> 表示我們定出的這個新型別。上述第 1.點告訴我們 <code class="haskell">Zero</code> 是 <code class="haskell">Nat</code> 的成員，也就是 <code class="haskell">{Zero} ⊆ Nat</code>. 第 2.點則表示，從 <code class="haskell">Nat</code> 這個集合中取出任一個元素 <code class="haskell">n</code>, 加上 <code class="haskell">Suc</code>, 得到的結果仍會在 <code class="haskell">Nat</code> 之中。也就是說 <code class="haskell">{Suc n | n ∈ Nat} ⊆ Nat</code>. 集合基本定理告訴我們 <code class="haskell">X ⊆ Z ⋀ Y ⊆ Z</code> 和&shy;<code class="haskell">X ∪ Y ⊆ Z</code> 是等價的，所以：%&shy;<input class="toggle" id="footnote-2-9-11" type="checkbox"/><label class="fnote-toggle" for="footnote-2-9-11">(註11) </label><span class="collapsible-footnote"><code class="haskell">X ⊆ Z ⋀ Y ⊆ Z &lt;=&gt; X ∪ Y ⊆ Z</code> 被稱為「<code class="haskell">(∪)</code> 的泛性質」。</span></p><pre><code class="equation" id="eq:Nat-Ind-0">    |{Zero} ∪ { Suc n || n ∈ Nat }| & ~\subseteq~ |Nat| \mbox{~~.}</code>    (2.15 )
</pre><p>意思是說，如果我們定義一個<em>集合到集合</em>的函數 <code class="haskell">NatF</code>:</p><pre><code class="spec">  NatF X = {Zero} ∪ { Suc n | n ∈ X } 
</code></pre><p>那麼 ([RefUndefined]) 可以改寫為</p><pre><code class="equation">   |NatF Nat| &~\subseteq~ |Nat| \mbox{~~,}</code>    (2.16 )
</pre><p>也就是說，<code class="haskell">Nat</code> 是 <code class="haskell">NatF</code> 的一個前定點！</p><p>至於 3.呢？它告訴我們 <code class="haskell">Nat</code> 僅含恰巧能滿足 1.和 2.的元素，沒有多餘。&shy;意即，<code class="haskell">Nat</code> 是<em>滿足 1.和 2.的集合之中最小的</em>。&shy;若有另一個集合 <code class="haskell">Z</code> 也滿足 1.和 2., 我們必定有 <code class="haskell">Nat ⊆ Z</code>.&shy;也就是說 <code class="haskell">Nat</code> 是 <code class="haskell">NatF</code> 的最小前定點：<code class="haskell">Nat = mu NatF</code>!</p><p>給定述語<code class="haskell">P</code>, 我們把所有「滿足 <code class="haskell">P</code> 的值形成的集合」也記為 <code class="haskell">P</code>.&shy;<input class="toggle" id="footnote-2-9-12" type="checkbox"/><label class="fnote-toggle" for="footnote-2-9-12">(註12) </label><span class="collapsible-footnote">對任何 <code class="haskell">A</code>, 函數 <code class="haskell">P :: A -&gt; Bool</code> 和「滿足 <code class="haskell">P</code> 的 <code class="haskell">A</code> 形成的集合」是同構的。我們可把它們等同視之。</span>&shy;數學歸納法的目的是證明所有自然數都滿足 <code class="haskell">P</code>。&shy;但，「所有自然數都滿足 <code class="haskell">P</code>」其實就是 <code class="haskell">Nat ⊆ P</code>.</p><p>如何證明 <code class="haskell">Nat ⊆ P</code>? 如前所述，<code class="haskell">Nat</code> 是 <code class="haskell">NatF</code> 的最小前定點。&shy;如果 <code class="haskell">P</code> 恰巧也是 <code class="haskell">NatF</code> 的一個前定點，<code class="haskell">Nat ⊆ P</code> 一定得成立。&shy;寫成推論如下：</p><pre><code class="spec">    Nat ⊆ P
&lt;==   <comment>{- <code class="haskell">Nat</code> 是 <code class="haskell">NatF</code> 的最小前定點，定義\ref{def:mu-nu} -}</comment>
    NatF P ⊆ P
&lt;=&gt;   <comment>{- <code class="haskell">NatF</code> 的定義 -}</comment>
    {Zero} ∪ {Suc n | n ∈ P}  ⊆   P
&lt;=&gt;   <comment>{- <code class="haskell">(∪)</code> 的泛性質：<code class="haskell">X ∪ Y ⊆ Z  &lt;=&gt;  X ⊆ Z ⋀ Y ⊆ Z</code> -}</comment>
    {Zero} ⊆ P  ⋀  {Suc n | n ∈ P} ⊆ P 
</code></pre><p>也就是說，如果證出<code class="haskell">{Zero} ⊆ P</code> 和 <code class="haskell">{Suc n | n ∈ P} ⊆ P</code>，我們就有 <code class="haskell">Nat ⊆ P</code>。其中，</p><ol><li><p><code class="haskell">{Zero} ⊆ P</code> 翻成口語便是「<code class="haskell">P</code> 對 <code class="haskell">Zero</code> 成立」，</p></li><li><p><code class="haskell">{Suc n | n ∈ P} ⊆ P</code> 則是「若 <code class="haskell">P</code> 對 <code class="haskell">n</code> 成立，<code class="haskell">P</code> 對 <code class="haskell">Suc n</code> 亦成立」。</p></li></ol><p>正是數學歸納法的兩個前提！</p><p>原來，<em>數學歸納法之所以成立，是因為自然數被定義為某函數的最小前定點</em>。&shy;事實上，當我們說某型別是「歸納定義」的，意思便是它是某個函數的最小前定點。</p><p>以串列為例。為單純起見，先考慮元素皆為 <code class="haskell">Nat</code> 的串列。&shy;如下的定義</p><pre><code class="spec">data ListNat  =  []  |  Nat : ListNat 
</code></pre><p>可理解為 <code class="haskell">ListNat = mu ListNatF</code>，而 <code class="haskell">ListNatF</code> 定義為：</p><pre><code class="spec">  ListNatF X = { [] } ∪ { n : xs | xs ∈ X, n ∈ Nat  } 
</code></pre><p>至於如下定義的、有型別參數的串列，</p><pre><code class="spec">data List a  =  []  |  a : List a 
</code></pre><p>則可理解為 <code class="haskell">List a = mu(ListF a)</code> --- <code class="haskell">List a</code> 是 <code class="haskell">ListF a</code> 的最小前定點，其中 <code class="haskell">ListF</code> 定義如下：</p><pre><code class="spec">  ListF A X = { [] } ∪ { x : xs | xs ∈ X, x ∈ A } 
</code></pre><p>給定某型別 <code class="haskell">A</code>, 當我們要證明某性質 <code class="haskell">P</code> 對所有 <code class="haskell">List A</code> 都成立，實質上是想要證明 <code class="haskell">List A ⊆ P</code> （同樣地，此處 <code class="haskell">P</code> 代表所有使述語 <code class="haskell">P</code> 成立的值之集合）。我們推論如下：</p><pre><code class="spec">  List A ⊆ P
&lt;==   <comment>{- <code class="haskell">List a = mu(ListF a)</code> -}</comment>
  ListF A P ⊆ P
&lt;=&gt;   <comment>{- <code class="haskell">ListF</code> 之定義 -}</comment>
  { [] } ∪ { x : xs | xs ∈ P, x ∈ A } ⊆ P
&lt;=&gt;   <comment>{- <code class="haskell">(∪)</code> 的泛性質 -}</comment>
  {[]} ⊆ P   ⋀  { x : xs | xs ∈ P, x ∈ A } ⊆ P 
</code></pre><p>其中 <code class="haskell">{[]} ⊆ P</code> 翻成口語即是「<code class="haskell">P []</code> 成立」；&shy;<code class="haskell">{ x : xs | xs ∈ P, x ∈ A } ⊆ P</code> 則是&shy;「若 <code class="haskell">P xs</code> 成立，對任何 <code class="haskell">x::A</code>, <code class="haskell">P (x:xs)</code> 成立」。</p><p>我們之所以能做自然數與串列的歸納證明，因為它們都是歸納定義出的型別 ---&shy;它們都被定義成某函數的最小前定點。若非如此，歸納證明就不適用了。&shy;那麼，有不是歸納定義出的型別嗎？</p><p>讀者可能注意到，本節起初同時談到最小前定點與最大後定點，但後來只討論了前者。&shy;事實上，我們也可以把一個資料型別定義為某函數的最大後定點。&shy;這時我們說該資料型別是個<em>餘歸納</em>(<em>coinductive</em>)定義，如此訂出的型別稱為<em>餘資料</em>(<em>codata</em>)。&shy;<span id="ix-2-33"></span><span id="ix-2-34"></span>&shy;歸納定義出的資料結構是有限的，而餘歸納定義的型別可能包括無限長的資料結構。&shy;寫餘資料相關的證明，另有一套稱作餘歸納(coinduction)的方法，&shy;而餘歸納也影響到我們如何寫與餘資料相關的程式。&shy;餘歸納和歸納的相關理論剛好是漂亮的對偶。我們將在 \todo{where} 介紹餘歸納。</p><div class="exlist"><div class="exercise exer" id="ex:ITree-ETree-mu"><h5 class="exercise-title">練習 2.36 </h5><p>回顧第<a href="Basics.html#sec:user-defined-data">1.10 </a>節中介紹的兩種樹狀結構：</p><pre><code class="spec">data ITree a  = Null | Node a (ITree a) (ITree a) 
data ETree a  = Tip a | Bin (ETree a) (ETree a) 
</code></pre><p>說說看它們分別是什麼函數的最小前定點，並找出它們的歸納原則。</p></div></div><h2 class="section" id="sec:induction-variations">2.10 歸納定義的簡單變化</h2><p>目前為止，我們所認定「良好」的函數定義是這種形式：</p><pre><code class="spec">f Zero     = ...
f (Suc n)  = ... f n ...
</code></pre><p>我們知道這樣定義出的函數是個全函數、對所有輸入都會終止、和歸納法有密切關係...。&shy;以後的幾個章節中，我們將逐步放鬆限制，允許更有彈性的函數定義模式。&shy;我們先從歸納法的一些較簡單的變化開始。</p><p><b>基底狀況的變化</b> &emsp;&shy;有些函數的值域是「正整數」或「大於 b 的整數」。&shy;定義這些函數時我們可用這樣的模式：</p><pre><code class="spec">f1 One      = e                                   fb b        = e
f1 (Suc n)  = ... f1 n ... <comment>{-"~~,\qquad\qquad"-}</comment>  fb (Suc n)  = ... fb n ... 
</code></pre><p>我們可把 <code class="haskell">f1</code> 理解為：另外訂了一個資料型別 <code class="haskell">data NatP = One | Suc NatP</code>,&shy;以 <code class="haskell">One</code> 為基底狀況，而 <code class="haskell">f1</code> 是 <code class="haskell">NatP</code> 之上的全函數。<code class="haskell">fb</code> 的情況也類似。&shy;與使用 <code class="haskell">Nat</code> 的函數混用時，我們就得在這兩個型別之間作轉換。這相當於檢查給 <code class="haskell">f1</code> 的輸入都是大於 <code class="haskell">1</code> 的整數。實務上為了方便，我們仍用同一個型別實作 <code class="haskell">Nat</code> 與 <code class="haskell">NatP</code>, 就如同實務上用 <code class="haskell">Int</code> 實作 <code class="haskell">Nat</code> 一樣。</p><p>串列的情形也類似。有些函數若能只定義在「不是空的串列」上，其定義會比較合理。&shy;對於這些函數，我們可想像有這麼一個「非空串列」資料型別&shy;<code class="haskell">data ListP a = [a] | a : ListP a</code>，&shy;只是為了方便，我們用普通串列實作它。&shy;<input class="toggle" id="footnote-2-10-13" type="checkbox"/><label class="fnote-toggle" for="footnote-2-10-13">(註13) </label><span class="collapsible-footnote">在一些型別系統更強大的語言中、進行更注重證明的應用時，我確實有將 <code class="haskell">NatP</code> 與 <code class="haskell">ListP</code> 做成與 <code class="haskell">Nat</code> 和 <code class="haskell">List</code> 不同的型別的經驗與需求。</span></p><div class="theorem" id="ex:maximumP"><h5 class="theorem-title">例 2.12  </h5><p>假設 <code class="haskell">x ↑ y</code> 傳回 <code class="haskell">x</code> 與 <code class="haskell">y</code> 中較大的值。&shy;函數 <code class="haskell">maximumP</code> 傳回一個非空串列中的最大元素：</p><pre><code class="haskell">maximumP :: ListP Int -&gt; Int
maximumP [x]     = x
maximumP (x:xs)  = x ↑ maximumP xs 
</code></pre><p>Haskell 標準函式庫中另有一個函數 <code class="haskell">maximum :: List Int -&gt; Int</code>, 但該函數需假設 <code class="haskell">Int</code> 中有一個相當於 $-\infty$ 的值存在，以便當作 <code class="haskell">maximum []</code> 的結果：</p><pre><code class="spec">maximum []      = -infty
maximum (x:xs)  = x ↑ maximum xs 
</code></pre></div><div class="theorem" id="ex:partsP"><h5 class="theorem-title">例 2.13  </h5><p>回顧第<a href="Induction.html#sec:fan-perm">2.6.4 </a>節提及的「劃分(partition)」：如果 <code class="haskell">concat yss = xs</code>, 且<code class="haskell">yss</code> 中的每個串列都不是空的，則 <code class="haskell">yss</code> 是 <code class="haskell">xs</code> 的一個劃分。&shy;<span id="ix-2-35"></span>&shy;如果我們限定 <code class="haskell">xss</code> 為非空串列，計算所有劃分的函數&shy;<code class="haskell">partsP :: ListP a -&gt; List (ListP (ListP a))</code> 可以寫得更簡潔：</p><pre><code class="haskell">partsP [x]     = [[[x]]]
partsP (x:xs)  = concat (map (extend x) (partsP xs)) 
  where extend x (ys:yss) = [[x]:ys:yss, (x:ys):yss] 
</code></pre><p>由於每個劃分一定是非空串列，<code class="haskell">extend</code> 不需考慮輸入為 <code class="haskell">[]</code> 的情況。</p></div><p><b>多個參數的歸納定義</b> &emsp;&shy;函數 <code class="haskell">take</code>/<code class="haskell">drop</code> 的功能與 <code class="haskell">takeWhile</code>/<code class="haskell">dropWhile</code> 很類似，&shy;但其定義方式卻有些不同：</p><pre><code class="haskell">take :: Nat -&gt; List a -&gt; List a
take Zero     xs      = []
take (Suc n)  []      = []
take (Suc n)  (x:xs)  = x : take n xs 

drop :: Nat -&gt; List a -&gt; List a
drop Zero     xs      = xs
drop (Suc n)  []      = []
drop (Suc n)  (x:xs)  = drop n xs 
</code></pre><p>我們可把 <code class="haskell">take</code>/<code class="haskell">drop</code> 想成在自然數上歸納定義成的高階函數：&shy;<code class="haskell">take (Suc n)</code> 的值是一個 <code class="haskell">List a -&gt; List a</code> 的函數。&shy;定義 <code class="haskell">take (Suc n)</code> 時，我們假設 <code class="haskell">take n</code> 已有定義。&shy;唯一的特殊處是我們另分出兩個子情況：串列為 <code class="haskell">[]</code>, 或串列為 <code class="haskell">x:xs</code>.</p><p>根據「使證明的結構符合程式的結構」的原則，如果要做關於&shy;<code class="haskell">take</code>/<code class="haskell">drop</code> 的證明，一種可能做法是也依循著它們的結構：&shy;先拆解自然數，在 <code class="haskell">n := Suc n</code> 的情況中再分析串列的值。&shy;作為例子，我們來驗證第頁提到的這個性質：</p><div class="theorem" id="thm:take-drop-id"><h5 class="theorem-title">定理 2.14  </h5><p>對所有 <code class="haskell">n</code> 與 <code class="haskell">xs</code>, <code class="haskell">take n xs ++ drop n xs = xs</code>.</p></div><div class="proof"><b>證明 </b><p>在 <code class="haskell">n</code> 上做歸納。在 <code class="haskell">n := []</code> 的情況下，等號兩邊都化簡為 <code class="haskell">[]</code>.&shy;在 <code class="haskell">n:=Suc n</code> 的情況中，我們再細分出兩種情形：</p><p><strong>狀況</strong> <code class="haskell">n := Suc n</code>, <code class="haskell">xs := []</code>. 顯然等號兩邊都化簡為 <code class="haskell">[]</code>.</p><p><strong>狀況</strong> <code class="haskell">n := Suc n</code>, <code class="haskell">xs := x:xs</code>:</p><pre><code class="spec">   take (Suc n) (x:xs) ++ drop (Suc n) (x:xs)
=    <comment>{- <code class="haskell">take</code> 與 <code class="haskell">drop</code> 之定義 -}</comment>
   x : take n xs ++ drop n xs
=    <comment>{- 歸納假設 -}</comment>
   x : xs 
</code></pre></div><p>然而，本章討論的是所有資料結構都是歸納定義、所有函數也都是全函數的世界。&shy;如果我們的世界中有不終止程式存在，上式便不見得成立了。</p><div class="exlist"><div class="exercise exer" id="ex:take-drop-non-termination"><h5 class="exercise-title">練習 2.37 </h5><p>請舉一個在允許不終止程式的 Haskell 中，&shy;<code class="haskell">take n xs ++ drop n xs = xs</code> 不成立的例子。</p></div><div class="exercise exer" id="ex:head-tail-id-neg"><h5 class="exercise-title">練習 2.38 </h5><p>對任何串列 <code class="haskell">xs</code>，<code class="haskell">head xs : tail xs = xs</code> 都成立嗎？請舉一個反例。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-38" type="checkbox"/><label class="lbl-toggle" for="ans-2-38">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p><code class="haskell">head [] : tail [] /= []</code>.</p></div></div><div class="exercise exer" id="ex:take-take"><h5 class="exercise-title">練習 2.39 </h5><p>證明對自然數 <code class="haskell">m</code>, <code class="haskell">n</code>, <code class="haskell">take m (take (m+n) xs) = take m xs</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-39" type="checkbox"/><label class="lbl-toggle" for="ans-2-39">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>針對 <code class="haskell">m</code> 做歸納。當 <code class="haskell">m := Zero</code>, 等號兩邊都歸約成 <code class="haskell">[]</code>。&shy;考慮<code class="haskell">m := Suc m</code>. 此時針對 <code class="haskell">xs</code> 做分析。&shy;當 <code class="haskell">xs := []</code>, 等號兩邊亦都歸約成 <code class="haskell">[]</code>。&shy;考慮 <code class="haskell">xs := x:xs</code> 的情況：</p><pre><code class="haskell">      take (Suc m) (take (Suc m + n) (x:xs))
 ===    <comment>{- <code class="haskell">(+)</code> 與 <code class="haskell">take</code> 之定義 -}</comment>
      take (Suc m) (x : take (m + n) xs)
 ===    <comment>{- <code class="haskell">take</code> 之定義 -}</comment>
      x : take m (take (m + n) xs)
 ===    <comment>{- 歸納假設 -}</comment>
      x : take m xs
 ===    <comment>{- <code class="haskell">take</code> 之定義 -}</comment>
      take (Suc m) xs 
</code></pre></div></div><div class="exercise exer" id="ex:drop-take"><h5 class="exercise-title">練習 2.40 </h5><p>證明對自然數 <code class="haskell">m</code>, <code class="haskell">n</code>, <code class="haskell">drop m (take (m + n) xs) = take n (drop m xs)</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-40" type="checkbox"/><label class="lbl-toggle" for="ans-2-40">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>針對 <code class="haskell">m</code> 做歸納。當 <code class="haskell">m := Zero</code>, 等號兩邊都歸約成 <code class="haskell">take n xs</code>。&shy;考慮<code class="haskell">m := Suc m</code>. 此時針對 <code class="haskell">xs</code> 做分析。&shy;當 <code class="haskell">xs := []</code>, 等號兩邊亦都歸約成 <code class="haskell">[]</code>。&shy;考慮 <code class="haskell">xs := x:xs</code> 的情況：</p><pre><code class="haskell">      drop (Suc m) (take (Suc m + n) (x:xs))
 ===    <comment>{- <code class="haskell">(+)</code> 與 <code class="haskell">take</code> 之定義 -}</comment>
      drop (Suc m) (x : take (m + n) xs)
 ===    <comment>{- <code class="haskell">take</code> 之定義 -}</comment>
      drop n (take (m + n) xs)
 ===    <comment>{- 歸納假設 -}</comment>
      take n (drop m xs)
 ===    <comment>{- <code class="haskell">take</code> 之定義 -}</comment>
      take n (drop (Suc m) (x:xs)) 
</code></pre></div></div><div class="exercise exer" id="ex:drop-drop"><h5 class="exercise-title">練習 2.41 </h5><p>證明對自然數 <code class="haskell">m</code>, <code class="haskell">n</code>, <code class="haskell">drop (m + n) xs) = drop n (drop m xs)</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-41" type="checkbox"/><label class="lbl-toggle" for="ans-2-41">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>針對 <code class="haskell">m</code> 做歸納。當 <code class="haskell">m := Zero</code>, 等號兩邊都歸約成 <code class="haskell">drop n xs</code>。&shy;考慮<code class="haskell">m := Suc m</code>. 此時針對 <code class="haskell">xs</code> 做分析。&shy;當 <code class="haskell">xs := []</code>, 等號兩邊亦都歸約成 <code class="haskell">[]</code>。&shy;考慮 <code class="haskell">xs := x:xs</code> 的情況：</p><pre><code class="haskell">      drop (Suc m + n) (x:xs)
 ===    <comment>{- <code class="haskell">(+)</code> 與 <code class="haskell">take</code> 之定義 -}</comment>
      drop (m + n) xs
 ===    <comment>{- 歸納假設 -}</comment>
      drop n (drop m xs)
 ===    <comment>{- <code class="haskell">drop</code> 之定義 -}</comment>
      drop n (drop (Suc m) (x:xs)) 
</code></pre></div></div></div><p>函數 <code class="haskell">zip</code> 是另一個例子。我們可把 <code class="haskell">zip xs ys</code> 視為 <code class="haskell">xs</code> 之上的歸納定義：</p><pre><code class="spec">zip :: List a -&gt; List b -&gt; List (a × b)
zip []      ys      = []
zip (x:xs)  []      = []
zip (x:xs)  (y:yz)  = (x,y) : zip xs ys 
</code></pre><div class="exlist"><div class="exercise exer" id="ex:zipWith-map-uncurry-zip"><h5 class="exercise-title">練習 2.42 </h5><p>試定義 <code class="haskell">zipWith :: (a -&gt; b -&gt; c) -&gt; List a -&gt; List b -&gt; List c</code>,&shy;並證明 <code class="haskell">zipWith f xs ys = map (uncurry f) (zip xs ys)</code>.</p></div></div><h2 class="section" id="sec:complete-induction">2.11 完全歸納</h2><p>說到遞迴定義，費氏數(Fibonacci number)&shy;<span id="ix-2-36"></span>是最常見的教科書例子之一。&shy;簡而言之，第零個費氏數是 <code class="haskell">0</code>, 第一個費氏數是 <code class="haskell">1</code>, 之後的每個費氏數是之前兩個的和。&shy;寫成遞迴定義如下：</p><pre><code class="spec">fib :: Nat -&gt; Nat
fib 0      = 0
fib 1      = 1
fib (2+n)  = fib (1+n) + fib n 
</code></pre><p>但這和我們之前談到的歸納定義稍有不同。&shy;我們已知定義 <code class="haskell">f (Suc n)</code> 時可假設 <code class="haskell">f</code> 在 <code class="haskell">n</code> 之上已有定義。&shy;但在 <code class="haskell">fib</code> 的定義中，<code class="haskell">fib (2+n)</code> 用到了 <code class="haskell">fib</code> 的前<em>兩個</em>值。這樣的定義是可以的嗎？</p><p>函數 <code class="haskell">fib</code> 的定義可以視為<em>完全歸納</em><span id="ix-2-37"></span>%&shy;（又稱作<em>強歸納</em>）的例子。&shy;回顧：先前介紹的數學歸納法中，使 <code class="haskell">P n</code> 成立的前提之一是「對所有 <code class="haskell">n</code>, 若 <code class="haskell">P n</code> 成立， <code class="haskell">P (Suc n)</code> 亦成立」。完全歸納則把這個前提增強如下：</p><blockquote><p>給定述語<code class="haskell">P :: Nat -&gt; Bool</code>. 若</p><ul><li><p>對所有小於 <code class="haskell">n</code> 的值 <code class="haskell">i</code>，<code class="haskell">P i</code> 皆 成立，則 <code class="haskell">P n</code> 亦成立，</p></li></ul><p>則我們可得知 <code class="haskell">P</code> 對所有自然數皆成立。</p></blockquote><p>以更形式化的方式可寫成：</p><pre><code class="equation" id="eq:complete-induction" title="完全歸納：">  |(forall n . P n)   &lt;==  (forall n . P n  &lt;== (forall i &lt; n . P i)) |</code>    (2.17 )
</pre><p>請注意：前提 <code class="haskell">P n  &lt;== (forall i &lt; n . P i)</code> 隱含 <code class="haskell">P 0</code> 成立，因為當 <code class="haskell">n := 0</code>, 由於沒有自然數 <code class="haskell">i</code> 滿足 <code class="haskell">i &lt; n</code>, 算式 <code class="haskell">(forall i &lt; n . P i)</code> 可化簡為 <code class="haskell">True</code>.</p><p>在完全歸納法之中，證明 <code class="haskell">P n</code> 時，我們可假設 <code class="haskell">P</code> 對<em>所有</em>小於 <code class="haskell">n</code> 的值都已成立了。&shy;對寫程式的人來說，有了完全歸納法，表示我們日後定義自然數上的函數 <code class="haskell">f :: Nat -&gt; a</code> 時，每個 <code class="haskell">f n</code> 都可以自由使用 <code class="haskell">f</code> 在<em>所有</em>小於 <code class="haskell">n</code> 的輸入之上的值。因此 <code class="haskell">fib (2+n)</code> 可以用到 <code class="haskell">fib (1+n)</code> 與 <code class="haskell">fib n</code>, 因為 <code class="haskell">n &lt; 1+n &lt; 2+n</code>.</p><div class="theorem" id="eg:complete-induction-example"><h5 class="theorem-title">例 2.15  </h5><p>關於完全歸納，離散數學教科書中的一個常見例子是「試證明所有自然數都可寫成不相同的二的乘冪的和」，例如 $50 = 2^5 + 2^4 + 2$.&shy;這可用完全歸納證明。我們以半形式的方式論述如下：&shy;令 <code class="haskell">P n</code> 為「$n$可寫成一串不相同的二的乘冪的和」. 對所有 <code class="haskell">n</code>, 我們想要證明 <code class="haskell">P n  &lt;== (forall i &lt; n . P i)</code>. 當 <code class="haskell">n</code> 為 <code class="haskell">Zero</code>, 這一串數字即是空串列。&shy;當 <code class="haskell">n</code> 大於零，</p><ul><li><p>我們可找到最接近 <code class="haskell">n</code> 但不超過 <code class="haskell">n</code> 的二之乘冪，稱之為 <code class="haskell">m</code>（也就是 $m = 2^k$ 而且 $m \leq n < 2\times m$）.</p></li><li><p>由於 $n$ 不是 <code class="haskell">Zero</code>, $m$ 也不是 <code class="haskell">Zero</code>. 也因此 <code class="haskell">n - m &lt; n</code>.</p></li><li><p>依據歸納假設 <code class="haskell">(forall i &lt; n . P i)</code>, 以及 <code class="haskell">n - m &lt; n</code>, <code class="haskell">P (n-m)</code> 成立 --- <code class="haskell">n - m</code> 可以寫成不相同的二的乘冪的和。</p></li><li><p>也因此 <code class="haskell">n</code> 可寫成不相同的二的乘冪的和 --- 把 <code class="haskell">n-m</code> 加上 $m$ 即可.</p></li></ul><p>上述證明僅用口語描述，因為如果形式化地寫下這個證明，就等同於寫個將自然數轉成一串二的乘冪的程式，並證明其正確性！下述函數 <code class="haskell">binary</code> 做這樣的轉換，例如，<code class="haskell">binary 50 = [32,16,2]</code>:</p><pre><code class="haskell">binary :: Nat -&gt; List Nat
binary Zero  = []
binary n     = m : binary (n - m) 
   where  m     = last (takeWhile (&lt;=n) twos)
          twos  = iterate (2 *:) 1 
</code></pre><p>函數 <code class="haskell">binary</code> 是一個完全歸納定義，和上述的證明對應得相當密切：串列 <code class="haskell">twos</code> 是 <code class="haskell">[1,2,4,8...]</code> 等等所有二的乘冪，<code class="haskell">m</code> 是其中最接近而不超過 <code class="haskell">n</code> 的。&shy;遞迴呼叫 <code class="haskell">binary (n - m)</code> 是許可的，因為 <code class="haskell">n - m &lt; n</code>, 而根據完全歸納，我們已假設對所有 <code class="haskell">i &lt; n</code>, <code class="haskell">binary i</code> 皆有定義。</p></div><p>有了完全歸納法，我們在定義自然數上的函數時可允許更靈活的函數定義：</p><pre><code class="spec">f :: Nat -&gt; a
f b = ....                 <comment>{- 一些基底情況 -}</comment>
f n = ... f m ... f k ...  <comment>{- 如果 <code class="haskell">m &lt; n</code> 且 <code class="haskell">k &lt; n</code> -}</comment>
</code></pre><p><code class="haskell">f n</code> 的右手邊可以出現不只一個遞迴呼叫，只要參數都小於 <code class="haskell">n</code>.&shy;但我們必須<em>確定上述定義中的幾個子句足以包含所有狀況，沒有狀況被遺漏</em>。&shy;例如，我們若 把 <code class="haskell">fib</code> 定義中的 <code class="haskell">fib 1 = ...</code> 基底狀況去掉，&shy;計算 <code class="haskell">fib 2 = fib 1 + fib 0</code> 時便會出錯。</p><div class="exlist"><div class="exercise exer" id="ex:sum-binary"><h5 class="exercise-title">練習 2.43 </h5><p>證明 <code class="haskell">sum (binary n) = n</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-43" type="checkbox"/><label class="lbl-toggle" for="ans-2-43">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>使用完全歸納。</p><p><strong>狀況</strong> <code class="haskell">n := Zero</code>: 等號兩邊都歸約為 <code class="haskell">[]</code>.</p><p><strong>狀況</strong> <code class="haskell">n &gt; Zero</code>。&shy;假設對於任何 <code class="haskell">0 &lt;= i &lt; n</code>, <code class="haskell">sum (binary i) = i</code>.</p><pre><code class="spec">   sum (binary n) =
=    <comment>{- 令 <code class="haskell">m = last (takeWhile (&lt;=n) twos)</code>, <code class="haskell">sum</code> 之定義 -}</comment>
   m + sum (binary (n - m))
=    <comment>{- 因 <code class="haskell">n - m &lt; n</code>, 歸納假設 -}</comment>
   m + (n - m)
=  n 
</code></pre></div></div><div class="exercise exer" id="ex:fib-alpha"><h5 class="exercise-title">練習 2.44 </h5><p>證明當 <code class="haskell">n &gt;= 1</code>, <code class="haskell">fib (2+n) &gt; {-"\alpha^n"-}</code>, 其中&shy;$\alpha = (1+\sqrt{5})/2$. 這個證明可用 <code class="haskell">n := 1</code> 和 <code class="haskell">n := 2</code> 當基底狀況。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-44" type="checkbox"/><label class="lbl-toggle" for="ans-2-44">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>本證明的關鍵性質是 $\alpha^2 = (3+\sqrt{5})/2 = \alpha + 1$.&shy;使用完全歸納證明 <code class="haskell">fib (2+n) &gt; {-"\alpha^n"-}</code>，以 <code class="haskell">n := 1</code> 和 <code class="haskell">n := 2</code> 當基底狀況。</p><p><strong>狀況</strong> <code class="haskell">n := 1</code>: <code class="haskell">fib 3 = 2 &gt; {-"\alpha"-}</code>.</p><p><strong>狀況</strong> <code class="haskell">n := 2</code>: <code class="haskell">fib 4 = 3 &gt; {-"(3+\sqrt{5})/2 = \alpha^2"-}</code>.</p><p><strong>狀況</strong> <code class="haskell">n := 2+n</code> 且 <code class="haskell">2+n &gt; 4</code>。&shy;假設對於任何 <code class="haskell">3 &lt;= i &lt; 2+n</code>, <code class="haskell">fib i &gt; {-"\alpha^{i-2}"-}</code>. 論證：</p><pre><code class="spec">    fib (2+n)
 =  fib (1+n) + fib n
 &gt;    <comment>{- 歸納假設 -}</comment>
    <comment>{-"\alpha^{n-1}"-}</comment> + <comment>{-"\alpha^{n-2}"-}</comment>
 =    <comment>{- 提出 $\alpha^{n-2}$-}</comment>
    <comment>{-"(\alpha + 1) \times \alpha^{n-2}"-}</comment>
 =    <comment>{- $\alpha^2 = \alpha + 1$ -}</comment>
    <comment>{-"\alpha^2 \times \alpha^{n-2}"-}</comment>
 =  <comment>{-"\alpha^n"-}</comment> 
</code></pre></div></div></div><p><b>完全歸納 vs 簡單歸納</b> &emsp;&shy;完全歸納有個較早的稱呼：<em>強歸納</em>(strong induction)。<span id="ix-2-38"></span>&shy;原本的歸納法則相對被稱呼為<em>簡單歸納</em>或<em>弱歸納</em>。&shy;強/弱歸納的稱呼可能使人以為完全歸納比簡單歸納更強 --- 意謂前者能證明出一些後者無法證明的定理。&shy;事實上，完全歸納與簡單歸納是等價的：能用一個方法證出的定理，用另一個方法也能證出。&shy;因此，使用哪一個純粹只是方便性的考量。</p><p>反應在程式設計上，給任一個完全歸納定義函數 <code class="haskell">f :: Nat -&gt; A</code>, 我們總能做出一個以簡單歸納定義的函數 <code class="haskell">fs :: Nat -&gt; List A</code>,&shy;滿足 <code class="haskell">fs n = map f [n, n-1, ... 0]</code>.&shy;例如，函數 <code class="haskell">fibs n</code> 傳回 <code class="haskell">[fib n, fib (n-1).., fib 0]</code>.</p><pre><code class="haskell">fibs :: Nat -&gt; List Nat
fibs 0        = [0]
fibs 1        = [1,0]
fibs (Suc n)  = (x1+x0) : x1 : x0 : xs  
    where (x1:x0:xs) = fibs n 
</code></pre><p>由 <code class="haskell">fib</code> 到 <code class="haskell">fibs</code> 的轉換可能令讀者想起演算法中的<em>動態規劃</em>(<em>dynamic programming</em>)<span id="ix-2-39"></span>。我們將在日後談到這個話題。</p><p><b>串列上的完全歸納</b> &emsp;&shy;串列與自然數是類似的資料結構。串列上的完全歸納原則便是將 <code class="haskell">Zero</code> 代換為 <code class="haskell">[]</code>,&shy;將 <code class="haskell">Suc</code> 代換為 <code class="haskell">(x:)</code>. 至於「小於」的關係，可定義為：</p><pre><code class="spec">ys &lt; xs  &lt;=&gt; ys ∈ tails xs ⋀ ys /= xs 
</code></pre><p>也就是說 <code class="haskell">ys</code> 是 <code class="haskell">xs</code> 的一個後段，但不是 <code class="haskell">xs</code> 自己。&shy;有了如上定義，串列上的完全歸納法是：</p><pre><code class="equation" title="串列的完全歸納：">|(forall xs . P xs)   &lt;==  (forall xs . P xs  &lt;== (forall ys &lt; xs . P ys)) |</code>    (2.18 )
</pre><p>應用在編程上，當定義 <code class="haskell">f (xs:)</code> 時，遞迴呼叫可作用在 <code class="haskell">xs</code> 的任何後段上。</p><p>但對許多串列上的函數而言，這樣的模式還不夠靈活。我們得用下一節說到的良基歸納。</p><h2 class="section" id="sec:well-founded-induction">2.12 良基歸納</h2><p><em>良基歸納</em>(<em>well-founded induction</em>)&shy;<span id="ix-2-40"></span>&shy;可視為完全歸納的再推廣。&shy;如果說完全歸納的主角是自然數，使用的是自然數上的「小於<code class="haskell">(&lt;)</code>」關係，良基歸納則將其推廣到任何型別，使用任一個<em>良基序</em>。</p><div class="theorem"><h5 class="theorem-title">定義 2.16  </h5><p>給定某型別 <code class="haskell">A</code> 之上的二元關係 <code class="haskell">(&lt;:)</code>。如果從任意一個 <code class="haskell">a0 :: A</code> 開始，均<em>不</em>存在無限多個滿足如下關係的 <code class="haskell">a1</code>, <code class="haskell">a2</code>\ldots :</p><pre><code class="equation">   \ldots |&lt;: a2 &lt;: a1 &lt;: a0| \mbox{~~,}</code>    (2.19 )
</pre><p>則 <code class="haskell">(&lt;:)</code> 可稱為一個<em>良基序</em>(<em>well-founded ordering</em>)<span id="ix-2-41"></span>。</p></div><p>把<code class="haskell">b &lt;: a</code> 簡稱為「<code class="haskell">b</code> 小於 <code class="haskell">a</code>」。&shy;上述定義可以這麼地直覺理解：&shy;給定任一個 <code class="haskell">a0 :: A</code>，我們找一個滿足 <code class="haskell">a1 &lt;: a0</code> 的值 <code class="haskell">a1</code>。&shy;這種 <code class="haskell">a1</code> 可能已不存在，但如果存在，我們再找一個滿足 <code class="haskell">a2 &lt;: a1</code> 的 <code class="haskell">a2</code>.&shy;說 <code class="haskell">(&lt;:)</code> 是個良基序的意思便是前述過程不可能永遠做下去：總有一天我們得停在一個「最小」的某<em>基底</em> <code class="haskell">an :: A</code>。</p><p>舉例說明：自然數上的「小於<code class="haskell">(&lt;)</code>」關係是個良基序，但整數上的<code class="haskell">(&lt;)</code>關係則不是 --- 由於負數的存在。實數上的<code class="haskell">(&lt;)</code>關係也不是。良基序並非得是個全序(total order)。例如，我們可定義序對上的比較關係如下：</p><pre><code class="spec">  (x1,y1) &lt;: (x2,y2)  &lt;=&gt;  x1 &lt; x2 ⋀ y1 &lt; y2 
</code></pre><p>其中 <code class="haskell">x1</code>, <code class="haskell">y1</code>, <code class="haskell">x2</code>, <code class="haskell">y2</code> 都是自然數。&shy;這麼一來，不論 <code class="haskell">(1,4) &lt;: (2,3)</code> 或 <code class="haskell">(2,3) &lt;: (1,4)</code> 都不成立，但 <code class="haskell">(&lt;:)</code> 仍是個良基序 --- 任何兩個自然數形成的序對不論以什麼方式遞減，最晚也得停在 <code class="haskell">(0,0)</code>.</p><p>如果 <code class="haskell">(&lt;:)</code> 是個良基序，我們便可在其上做歸納。以直覺來理解的話，如果某函數定義成如此的形式（假設這幾個子句已經包括參數的所有可能情況）：</p><pre><code class="spec">f :: A -&gt; B
f b = ....                 <comment>{- 一些基底情況 -}</comment>
f x = ... f y ... f z ...  <comment>{- 如果 <code class="haskell">y &lt;: x</code> 且 <code class="haskell">z &lt;: x</code> -}</comment>
</code></pre><p>由任何 <code class="haskell">f x</code> 開始，若 <code class="haskell">x</code> 不是基底情況之一，我們需遞迴呼叫 <code class="haskell">f y</code> 和 <code class="haskell">f z</code>。&shy;但 <code class="haskell">y</code> 和 <code class="haskell">z</code> 在 <code class="haskell">(&lt;:)</code> 這個序上比 <code class="haskell">x</code>「小」了一點。&shy;此後即使再做遞迴呼叫，每次使用的參數又更小了一點。&shy;而由於 <code class="haskell">(&lt;:)</code> 是良基序，<code class="haskell">f</code> 的參數不可能永遠「小」下去 --- <code class="haskell">f</code> 非得停在某個基底情況不可。&shy;因此 <code class="haskell">f</code> 必須正常終止。&shy;同樣的原則也用在證明上：</p><blockquote><p>給定述語<code class="haskell">P :: A -&gt; Bool</code> 以及 <code class="haskell">A</code> 之上的良基序 <code class="haskell">(&lt;:)</code>。若</p><ul><li><p>對所有滿足 <code class="haskell">y &lt;: x</code> 的值 <code class="haskell">y</code>，<code class="haskell">P y</code> 皆 成立，則 <code class="haskell">P x</code> 亦成立，</p></li></ul><p>則我們可得知 <code class="haskell">P</code> 對所有 <code class="haskell">A</code> 皆成立。</p></blockquote><p>或著可寫成如下形式：</p><pre><code class="equation" title="良基歸納：">|(forall x . P x)   &lt;==  (forall x . P x  &lt;== (forall y &lt;: x . P y)) <comment>{-"~~,\\"-}</comment>
<comment>{-"\qquad\mbox{其中 $(\lhd)$ 為一個良基序。}"-}</comment>|</code>    (2.20 )
</pre><p><b>終止證明與良基歸納</b> &emsp;&shy;我們已在許多地方強調：確定程式正常終止是很重要的。&shy;我們也知道以簡單歸納與完全歸納定義出的程式均是會正常終止的。&shy;但這兩種歸納定義的限制很多。雖然我們已舉了許多例子，仍有些程式難以套入它們所要求的模板中。&shy;相較之下，良基歸納寬鬆許多。大部分我們已知、會終止的程式都可視為良基歸納定義。</p><p>或著，上述段落應該反過來說。&shy;在函數程設中，欲證明某個遞迴定義的函數會終止，最常見的方式是證明該函數每次遞迴呼叫時使用的參數都在某個度量上「變小」了，而這個度量又不可能一直變小下去。&shy;因此該函數遲早得碰到基底狀況。&shy;換句話說，該函數每次遞迴呼叫的參數符合某個良基序；&shy;<em>當我們如此證明一個函數會終止，其實就相當於在論證該函數是一個良基歸納定義</em>。&shy;在指令式編程中證明某迴圈會終止的做法也類似。&shy;最常見的方式是證明該迴圈每多執行一次，某個量值就會變小，而該量值是不可能一直變小的。&shy;也就是說這些量值在每趟迴圈執行時的值符合某個良基序。</p><p>以下我們將看幾個遞迴定義的例子。請讀者們想想：這些函數總會正常終止嗎？為何？如果它們是良基歸納，使用的良基序是什麼？</p><div class="theorem" id="ex:quicksort" title="快速排序"><h5 class="theorem-title">例 2.17  快速排序 </h5><p>以下是大家熟悉的<em>快速排序</em>(quicksort)&shy;<span id="ix-2-42"></span>  <a href="Biblio.html#Hoare:62:Quicksort">[Hoare 1962]</a>:</p><pre><code class="spec">qsort :: List Int -&gt; List Int
qsort []      = []
qsort (x:xs)  = qsort ys ++ [x] ++ qsort zs 
  where (ys,zs) = (filter (&lt;=x) xs, filter (&lt;x) xs) 
</code></pre><p>空串列是已經排序好的。當輸入為非空串列 <code class="haskell">x:xs</code>，我們將 <code class="haskell">xs</code> 分為小於等於 <code class="haskell">x</code> 的，以及大於 <code class="haskell">xs</code> 的，分別遞迴排序，再將結果接在一起。</p><p>函數 <code class="haskell">qsort</code> 會正常終止，因為每次遞迴呼叫時，作為參數的串列都會減少至少一個元素（因為 <code class="haskell">x</code> 被取出了），而串列的長度又不可能小於 <code class="haskell">0</code>. 若要稍微形式地談這件事，可從良基歸納的觀點來看。如果定義：</p><pre><code class="spec">ys &lt;: xs  &lt;=&gt;  length ys &lt; length xs 
</code></pre><p>在 <code class="haskell">qsort (x:xs)</code> 子句中，<code class="haskell">ys &lt;: xs</code> 和 <code class="haskell">zs &lt;: xs</code> 均被滿足，而 <code class="haskell">(&lt;:)</code> 是一個良基序。因此 <code class="haskell">qsort</code> 是一個奠立在 <code class="haskell">(&lt;:)</code> 之上的良基歸納定義。</p></div><div class="theorem" id="eg:mergesort" title="合併排序"><h5 class="theorem-title">例 2.18  合併排序 </h5><p>在串列上，合併排序<span id="ix-2-43"></span>也是很常使用的排序方式。&shy;我們在第<a href="Basics.html#sec:wholemeal">1.9 </a>節中示範過以全麥編程方式寫成、由下往上的合併排序。&shy;此處的寫法則更接近大家一般的認知：拿到一個長度為 <code class="haskell">n</code> 的串列，將之分割為長度大致為 <code class="haskell">n/2</code> 的兩段，分別排序之後合併。&shy;同樣地，假設我們已有一個函數 <code class="haskell">merge :: List Int -&gt; List Int -&gt; List Int</code>,&shy;如果 <code class="haskell">xs</code> 與 <code class="haskell">ys</code> 已經排序好，<code class="haskell">merge xs ys</code> 將它們合併為一個排序好的串列。&shy;合併排序可寫成：</p><pre><code class="spec">msort :: List Int -&gt; List Int
msort []   = []
msort [x]  = [x]
msort xs   = merge (msort ys) (msort zs) 
  where (ys,zs) = (take (n `div` 2) xs, drop (n `div` 2) xs) 
</code></pre><p>要論證 <code class="haskell">msort</code> 會正常終止，或著說，要將 <code class="haskell">msort</code> 視為一個良基歸納定義，我們可用和例<a href="Induction.html#ex:quicksort">2.17 </a>中一樣的良基序<code class="haskell">(&lt;:)</code>.</p><p>但此處請讀者小心檢查：在 <code class="haskell">msort xs</code> 子句中，<code class="haskell">ys &lt;: xs</code> 和 <code class="haskell">zs &lt;: xs</code> 有被滿足嗎？&shy;當 <code class="haskell">length xs = n</code>, 串列 <code class="haskell">ys</code> 與 <code class="haskell">zs</code> 的長度分別是 <code class="haskell">n `div` 2</code> 和 <code class="haskell">n - n `div` 2</code>. 當 <code class="haskell">length xs = 1</code> 時，<code class="haskell">ys</code> 與 <code class="haskell">zs</code> 的長度分別是... <code class="haskell">0</code> 和 <code class="haskell">1</code> --- <code class="haskell">zs</code> 並沒有變短！</p><p>這是為何我們需要 <code class="haskell">msort [x]</code> 這個子句把 <code class="haskell">length xs = 1</code> 的情況分開處理。如果沒有這個子句，<code class="haskell">msort</code> 將有可能不終止 --- 讀者不妨試試看。</p></div><div class="theorem" id="eg:gcd" title="最大公因數"><h5 class="theorem-title">例 2.19  最大公因數 </h5><p>歐幾里得(Euclid)的《幾何原本》成書於西元前三百年，其中描述「計算最大公因數」<span id="ix-2-44"></span>的做法可能是世界上最古老的演算法。&shy;以下函數計算兩個自然數 <code class="haskell">(m,n)</code> 的最大公因數。&shy;如果兩數相等，它們的最大公因數也是自身。&shy;若兩數不相等，其最大公因數會是「大數減小數」與「小數」的最大公因數：</p><pre><code class="haskell">gcd :: (Nat × Nat) -&gt; Nat
gcd (m,n)  | m == n     = n
           | otherwise  = gcd ((m ↑ n) - (m ↓ n), m ↓ n) 
</code></pre><p>這個程式總會正常終止嗎？為什麼？</p><p>事實上，若 <code class="haskell">m</code> 或 <code class="haskell">n</code> 其中之一為 <code class="haskell">0</code>, <code class="haskell">gcd (m,n)</code> 是不會終止的 ---&shy;讀者不妨也試試看。&shy;若 <code class="haskell">m</code>, <code class="haskell">n</code> 均為<em>正</em>整數呢？&shy;首先我們先確立：如果初始的 <code class="haskell">m</code>, <code class="haskell">n</code> 均為正整數，<code class="haskell">gcd</code> 每次遞迴呼叫拿到的參數也都是正整數 ---&shy;確實如此，因為如果 <code class="haskell">m &gt; 0</code>, <code class="haskell">n &gt; 0</code>, 且 <code class="haskell">m /= n</code>, 那麼 <code class="haskell">(m ↑ n) - (m ↓ n)</code> 與 <code class="haskell">m ↓ n</code> 都不會是零或負數。&shy;接下來我們可論證：如果 <code class="haskell">m</code>, <code class="haskell">n</code> 均為正整數，每次遞迴呼叫中，<em>兩參數的和</em>都變小了一些。確實：</p><pre><code class="spec">   (m ↑ n) - (m ↓ n) + (m ↓ n)
=  m ↑ n
&lt;   <comment>{- <code class="haskell">m</code>, <code class="haskell">n</code> 均為正整數 -}</comment>
   m + n 
</code></pre><p>因此，我們可得知 <code class="haskell">gcd</code> 在 <code class="haskell">m</code>, <code class="haskell">n</code> 均為正整數時會正常終止。&shy;如果把 <code class="haskell">gcd</code> 當作一個良基歸納，我們用了如下的良基序：</p><pre><code class="spec">  (m1, n1) &lt;: (m2, n2)  &lt;=&gt;   m1+n1 &lt; m2+n2 
</code></pre><p>其中 <code class="haskell">m1</code>, <code class="haskell">n1</code>, <code class="haskell">m2</code>, <code class="haskell">n2</code> 均為正整數。</p></div><div class="theorem" id="ex:interleave" title="Curried 函數"><h5 class="theorem-title">例 2.20  Curried 函數 </h5><p>下述函數 <code class="haskell">interleave</code> 將兩個參數中的元素交錯放置。&shy;例如 <code class="haskell">interleave [1,2,3] [4,5] = [1,4,2,5,3]</code>.</p><pre><code class="haskell">interleave :: List a -&gt; List a -&gt; List a
interleave []      ys  = ys
interleave xs      []  = xs
interleave (x:xs)  ys  = x : interleave ys xs 
</code></pre><p>這可視為一個良基歸納定義嗎？&shy;若將 <code class="haskell">interleave</code> 做為傳回函數的高階函數看待，我們比較難看出它是定義在什麼良基序上的。&shy;但若把 <code class="haskell">interleave</code> 的兩個參數一起考慮，我們不難看出什麼度量在遞迴呼叫後「變小」了：兩個參數長度的和！</p><p>凡是遇到像 <code class="haskell">interleave</code> 的 curried 函數，我們也可考慮它的 uncurried 版本：</p><pre><code class="haskell">interleave' :: (List a × List a)-&gt; List a
interleave' ([],    ys)  = ys
interleave' (xs,    [])  = xs
interleave' (x:xs,  ys)  = x : interleave' (ys,xs) 
</code></pre><p>函數 <code class="haskell">interleave'</code> 是個良基定義 --- 參數中的兩個串列雖然交換位置，但它們長度的總和會變小。也就是說 <code class="haskell">interleave'</code> 可視為定義在這個良基序上的函數：</p><pre><code class="spec">  (xs1,ys1) &lt;: (xs2,ys2)  &lt;=&gt;  length xs1 + length ys1 &lt; length xs2 + length ys2 
</code></pre><p>凡是 <code class="haskell">interleave'</code> 有的性質，不難找出 <code class="haskell">interleave</code> 的相對應版本；&shy;證明 <code class="haskell">interleave</code> 的性質時，可當成是在證明 <code class="haskell">interleave'</code> 的相對性質。&shy;因此我們也會比較寬鬆地說 <code class="haskell">interleave</code> 也是 <code class="haskell">(&lt;:)</code> 之上的良基歸納定義。</p></div><div class="theorem" id="eg:McCarthy91"><h5 class="theorem-title">例 2.21  </h5><p>下列函數被稱作「McCarthy 91 函數」：</p><pre><code class="haskell">mc91 :: Nat -&gt; Nat
mc91 n  | n &gt; 100    = n - 10
        | otherwise  = mc91 (mc91 (n + 11)) 
</code></pre><p>讀者不妨先猜猜看 <code class="haskell">mc91</code> 會傳回什麼？答案是，<code class="haskell">mc</code> 和以下函數是等價的：</p><pre><code class="spec">mc91'  | n &gt; 100    = n - 10
       | otherwise  = 91 
</code></pre><p>\todo{finish this.}</p></div><h2 class="section" id="sec:lexicographic-induction">2.13 詞典序歸納</h2><p><span id="ix-2-45"></span>&shy;我們終於要定義第<a href="Basics.html#sec:wholemeal">1.9 </a>節與<a href="Induction.html#sec:well-founded-induction">2.12 </a>節中都提到的「合併」函數：將兩個已排序好的串列合而為一。&shy;函數 <code class="haskell">merge</code> 最自然的寫法可能是：</p><pre><code class="spec">merge :: List Int -&gt; List Int -&gt; List Int
merge []      ys      = ys
merge (x:xs)  []      = x:xs
merge (x:xs)  (y:ys)  = if x &lt;= y  then x : merge xs (y:ys)
                                   else y : merge (x:xs) ys 
</code></pre><p>如果兩個串列之中有一個為空串列，合併的結果是另一個。&shy;如果兩個都不是空串列，我們比較其第一個元素，以便決定將哪個當作合併後的第一個元素。</p><p>但，<code class="haskell">merge</code> 最後一個子句的第一個遞迴呼叫中，<code class="haskell">y:ys</code> 沒有變短；第二個遞迴呼叫中，<code class="haskell">x:xs</code> 沒有變短。&shy;這種程式會終止嗎？如果會，是哪種歸納定義呢？</p><p>一種看法是將 <code class="haskell">merge</code> 視作和例<a href="Induction.html#ex:interleave">2.20 </a>中的 <code class="haskell">interleave</code> 類似的歸納定義：兩個參數的長度和在遞迴呼叫中變小了。另一個可能是將函數 <code class="haskell">merge</code> 視作<em>詞典序歸納</em>(<em>lexicographic induction</em>)的例子 --- 詞典序歸納也是良基歸納的一個特例。</p><p>先介紹<em>詞典序</em>。我們怎麼決定兩個英文單字在詞典中的先後順序呢？&shy;通常是先比較其第一個字母，如果第一個字母便分出了大小，就以此大小為準，<em>不論剩下的字母為何</em>。如果第一個字母一樣，便從第二個字母開始比起。&shy;若要以形式化的方式寫下詞典序的定義，我們考慮一個較簡單的狀況：如何比較 <code class="haskell">x1 y1</code> 和 <code class="haskell">x2 y2</code> 兩個長度均為二的字串？如果 <code class="haskell">(&lt;)</code> 是比較單一字元大小的順序，我們把兩個字元的詞典序寫成 $(<;<)$，定義如下：</p><pre><code class="equation">    x_1 y_1 (&lt;;&lt;) x_2 y_2 ~~\equiv~~
       x_1 &lt; x_2 ~\vee~ (x_1 = x_2 \wedge y_1 &lt; y_2)  \mbox{~~.}</code>    (2.21 )
</pre><p>如前所述，先比較 <code class="haskell">x1</code> 與 <code class="haskell">x2</code>, 如果相等，再比較 <code class="haskell">y1</code> 與 <code class="haskell">y2</code>.</p><p>我們可以再稍微擴充一些，考慮 $x_i$ 與 $y_i$ 型別不同的情況：</p><div class="theorem" id="def:lhd-prec"><h5 class="theorem-title">定義 2.22  </h5><p>給定義在型別 <code class="haskell">A</code> 之上的序 $(\lhd)$ 和型別 <code class="haskell">B</code> 之上的序 $(\prec)$, 它們的<em>詞典序</em>(<em>lexicographic ordering</em>)，寫做 $(\lhd;\prec)$，是 <code class="haskell">(A × B)</code> 上的一個序，定義為：</p><pre><code class="equation">    (x_1, y_1) (\lhd;\prec) (x_2,y_2) ~~\equiv~~
       x_1 \lhd x_2 ~\vee~ (x_1 = x_2 \wedge y_1 \prec y_2)  \mbox{~~.}</code>    (2.22 )
</pre></div><p>上述定義也可擴充到三個、四個... 元素的序對上。此處便不把他們寫出來了。</p><p>關於詞典序的有趣性質相當多，此處僅用到下述性質</p><div class="theorem" id="thm:lhd-prec"><h5 class="theorem-title">定理 2.23  </h5><p>如果 $(\lhd)$ 與 $(\prec)$ 均為良基序，$(\lhd;\prec)$ 也是良基序。</p></div><p>因此，$(\lhd;\prec)$ 也可用來做歸納定義。&shy;我們把使用詞典序的良基序歸納稱作「詞典序歸納」。</p><p>回頭看 <code class="haskell">merge</code> 的定義。先考慮下述、在第<a href="Basics.html#sec:wholemeal">1.9 </a>節中出現的 uncurried 版本：</p><pre><code class="spec">merge' :: (List Int × List Int) -&gt; List Int
merge' ([],    ys)    = ys
merge' (x:xs,  [])    = x:xs
merge' (x:xs,  y:ys)  = if x &lt;= y  then  x : merge' (xs, y:ys)
                                   else  y : merge' (x:xs, ys) 
</code></pre><p>如果 <code class="haskell">(&lt;:)</code> 是比較串列長度的良基序，我們可說 <code class="haskell">merge'</code> 是在 $(\lhd;\lhd)$ 之上的歸納定義。確實，</p><ul><li><p><code class="haskell">(xs, y:ys) (&lt;:;&lt;:) (x:xs,  y:ys)</code>, 因為 <code class="haskell">xs &lt;: x:xs</code>;</p></li><li><p><code class="haskell">(x:xs, ys) (&lt;:;&lt;:) (x:xs,  y:ys)</code>, 因為 <code class="haskell">x:xs = x:xs</code> 且 <code class="haskell">ys &lt;: y:ys</code>.</p></li></ul><p>至於 <code class="haskell">merge</code> 則是 <code class="haskell">merge'</code> 的 curried 版本，因此也是定義良好的。</p><p>如前所述，函數 <code class="haskell">merge</code> 的定義不一定得看成辭典序歸納 --- 它也可和 <code class="haskell">interleave</code> 一樣看成另一種較簡單的良基歸納 --- 比較兩參數的長度之和。&shy;接下來的例子就得倚靠辭典序歸納了。</p><div class="theorem" id="eg:Ackermann-function"><h5 class="theorem-title">例 2.24  </h5><p>知名的 Ackermann 函數 (Ackermann's function)&shy;<span id="ix-2-46"></span>&shy;是一個遞增得相當快的函數。</p><pre><code class="haskell">ack :: Nat -&gt; Nat -&gt; Nat
ack 0        n        = Suc n
ack (Suc m)  0        = ack m 1
ack (Suc m)  (Suc n)  = ack m (ack (Suc m) n) 
</code></pre><p>該函數定義上的特殊處之一是 <code class="haskell">ack (Suc m) n</code> 的結果又被當作 <code class="haskell">ack m</code> 的參數，因此較難以用理解 <code class="haskell">interleave</code> 的方式理解。&shy;但它可以視為詞典序 <code class="haskell">(&lt;;&lt;)</code> 上的歸納：</p><ul><li><p><code class="haskell">(m,1) (&lt;;&lt;) (Suc m,0)</code>，因為 <code class="haskell">m &lt; Suc m</code>;</p></li><li><p><code class="haskell">(Suc m, n) (&lt;;&lt;) (Suc m, Suc n)</code>，因為 <code class="haskell">n &lt; Suc n</code>;</p></li><li><p><code class="haskell">(m, ack (Suc m) n) (&lt;;&lt;) (Suc m, Suc n)</code>，因為 <code class="haskell">m &lt; Suc m</code>.</p></li></ul></div><h2 class="section" id="sec:mutual-induction">2.14 交互歸納</h2><p>許多工作無法由一個函數獨立完成，而需要許多函數彼此呼叫。本章最後談談這類的<em>交互歸納</em>(mutual induction)定義。<span id="ix-2-47"></span>&shy;下列函數定義中，<code class="haskell">even</code> 判斷其輸入是否為偶數。第二個子句告訴我們：如果 <code class="haskell">n</code> 是奇數， <code class="haskell">Suc n</code> 便是偶數。但如何判斷一個數字是否為奇數？如果 <code class="haskell">n</code> 是偶數，<code class="haskell">Suc n</code> 便是奇數：</p><div class="multicols"><div class="mcol" width="0.5\textwidth"><pre><code class="spec">even :: Nat -&gt; Bool
even Zero     = True
even (Suc n)  = odd n  
</code></pre></div><div class="mcol" width="0.5\textwidth"><pre><code class="spec">odd :: Nat -&gt; Bool
odd Zero     = False
odd (Suc n)  = even n 
</code></pre></div></div><p>這類彼此呼叫的定義可以視為一整個大定義。&shy;為讓讀者習慣，我們先把 <code class="haskell">even</code> 與 <code class="haskell">odd</code> 的定義改寫為 $\lambda$ 算式與 <code class="haskell">case</code>:</p><div class="multicols"><div class="mcol" width="0.5\textwidth"><pre><code class="spec">even = \n -&gt;  case n of
                Zero   -&gt; True
                Suc n  -&gt; odd n  
</code></pre></div><div class="mcol" width="0.5\textwidth"><pre><code class="spec">odd = \n -&gt;  case n of
               Zero   -&gt; False
               Suc n  -&gt; even n 
</code></pre></div></div><p>上述的定義可以合併成一個：<code class="haskell">evenOdd</code> 是一個序對，其中有兩個函數 <code class="haskell">Nat -&gt; Bool</code>，其中是 <code class="haskell">fst evenOdd</code> 就是 <code class="haskell">even</code>，<code class="haskell">snd evenOdd</code> 就是 <code class="haskell">odd</code>:</p><pre><code class="haskell">evenOdd :: ((Nat -&gt; Bool) × (Nat -&gt; Bool))
evenOdd = (  \n -&gt; case n of<comment>{-"~~"-}</comment>  Zero   -&gt; True
                                      Suc n  -&gt; snd evenOdd n,
             \n -&gt; case n of<comment>{-"~~"-}</comment>  Zero   -&gt; False
                                      Suc n  -&gt; fst evenOdd n) 
</code></pre><div class="exlist"><div class="exercise exer" id="ex:zip-inits-tails"><h5 class="exercise-title">練習 2.45 </h5><p>證明 <code class="haskell">all (xs ==) (zipWith (++) (inits xs) (tails xs))</code>. (unfinished)</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-45" type="checkbox"/><label class="lbl-toggle" for="ans-2-45">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>在 <code class="haskell">xs</code> 上做歸納。</p><pre><code class="spec">    all ((x:xs) ==) (zipWith (++) (inits (x:xs)) (tails (x:xs)))
&lt;=&gt; all ((x:xs) ==) (zipWith (++) ([]: map (x:) (inits xs)) ((x:xs):tails xs))
&lt;=&gt; all ((x:xs) ==) (([] ++ (x:xs)) : zipWith (++) (map (x:) (inits xs)) (tails xs))
&lt;=&gt; ((x:xs) == (x:xs)) ⋀
    all ((x:xs) ==) (zipWith (++) (map (x:) (inits xs)) (tails xs))
</code></pre></div></div></div><h2 class="section" id="sec:induction-ref">2.15 參考資料</h2><p>快速排序<span id="ix-2-48"></span>最初由 Hoare 在 Communications of the ACM 的演算法專欄中發表為兩個獨立的演算法：&shy;將陣列分割為大、小兩塊的「演算法63: PARTITION」 <a href="Biblio.html#Hoare:61:Partition">[Hoare 1961]</a>，&shy;以及用前述演算法將陣列排序的「演算法64: QUICKSORT」 <a href="Biblio.html#Hoare:61:Quicksort">[Hoare 1961]</a>。&shy;至於「演算法65: FIND」 <a href="Biblio.html#Hoare:61:Find">[Hoare 1961]</a> 的功能則是：給定 <code class="haskell">k</code>，尋找一個陣列中第 <code class="haskell">k</code> 小的元素。&shy;該演算法也使用了 PARTITION, 我們現在常把它稱為「快速選擇(quickselect)」<span id="ix-2-49"></span>。&shy;該專欄要求作者使用 Algol 語言。Algol 支援遞迴，Hoare 也大方地用了遞迴。&shy;當時遞迴仍是新觀念，Hoare 在另一篇論文 <a href="Biblio.html#Hoare:62:Quicksort">[Hoare 1962]</a>中（以大量文字）描述不用遞迴的作法。</p><p>例<a href="Induction.html#ex:quicksort">2.17 </a>中的快速排序常被當作「函數編程（或 Haskell）漂亮又簡潔」的例證：快速排序用其他語言得寫得落落長，用 Haskell 可在兩三行內清楚地寫完。&shy;但這樣的比較並不很公平：例<a href="Induction.html#ex:quicksort">2.17 </a>排序的是串列，而拿來比較的對象通常是將陣列做排序的指令式語言程式。&shy;快速排序的主要挑戰之一，也是「演算法63: PARTITION」的重點，是在$O(n)$的時間、$O(1)$的額外空間之內完成陣列的分塊。&shy;這點在串列版本中並沒有（或不須）表達出來。</p><p><a href="Biblio.html#MannaMcCarthy:69:Properties">Manna and McCarthy [1969]</a>&shy;<a href="Biblio.html#MannaPnueli:70:Formalization">Manna and Pnueli [1970]</a></p></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
