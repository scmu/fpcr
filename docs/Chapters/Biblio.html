<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="ToC.html">目錄</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction">0.3 抽象化</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:correctness">0.5 正確性</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:relevant-information">0.7 相關資料</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:evaluation">1.1 值與求值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:function-defns">1.2 函數定義</a></li><li class="pure-menu-item"><a href="Basics.html#sec:higher-order-func">1.3 高階函數</a></li><li class="pure-menu-item"><a href="Basics.html#sec:func-comp">1.4 函數合成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:boolean">1.6.1 布林值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:char">1.6.2 字元</a></li><li class="pure-menu-item"><a href="Basics.html#sec:pairs">1.6.3 序對</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:weak-head-normal-form">1.7 弱首範式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:list-deconstruct">1.8.1 串列解構</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-generation">1.8.2 串列生成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:wholemeal">1.9 全麥編程</a></li><li class="pure-menu-item"><a href="Basics.html#sec:user-defined-data">1.10 自訂資料型別</a></li><li class="pure-menu-item"><a href="Basics.html#sec:refs-basics">1.11 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:math-induction">2.1 數學歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li><li class="pure-menu-item"><a href="Induction.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:list-segments">2.6.3 串列區段</a></li><li class="pure-menu-item"><a href="Induction.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li><li class="pure-menu-item"><a href="Induction.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li><li class="pure-menu-item"><a href="Induction.html#sec:complete-induction">2.11 完全歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:well-founded-induction">2.12 良基歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:mutual-induction">2.14 交互歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-ref">2.15 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.1 紅黑樹插入</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.2 紅黑樹之性質：高度</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.3 紅黑樹之性質：平衡</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.4 紅黑樹之性質：顏色</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics.html#sec:denotational-semantics">4.1 指稱語意</a></li><li class="pure-menu-item"><a href="Semantics.html#sec:operational-semantics">4.2 操作語意</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:efficiency-basics">5.2 關於執行效率</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:var-cons">5.4 變數換常數</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:steep">5.5.1 陡串列</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion">5.6.3 尾遞迴</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:difference-list">5.6.6 函數作為串列</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li><li class="pure-menu-item"><a href="Folds.html#sec:scan-lemma">6.2.3 掃描</a></li><li class="pure-menu-item"><a href="Folds.html#sec:banana-split">6.2.4 香蕉船定理</a></li><li class="pure-menu-item"><a href="Folds.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li><li class="pure-menu-item"><a href="Folds.html#sec:bring-in-context">6.2.6 引入脈絡</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldl">6.3.1 左摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:list-homomorphism">6.3.2 串列同構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldN">6.4 自然數的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:folds-ref">6.6 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-segment-sum">7.1 最大區段和</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:segProblems-ref">7.3 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:exceptions">8.1 例外處理</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-class-laws">8.2 單子與單子律</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:var-env-reader">8.3.1 變數與環境</a></li><li class="pure-menu-item"><a href="Monads.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:hanoi">8.4.1 河內塔問題</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#">8.5 參考資料</a></li></ul></li></ul></nav><p><a href="Ix.html">索引</a></p><p class="pure-menu-selected"><a href="Biblio.html">參考書目</a></p><p class="author-info"><a href="https://  homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div><div id="main"><div class="header"><h1>參考書目</h1></div><div class="content"><ul class="biblio"><li id="Abrial:96:B">Jean-Raymond Abrial. <span class="book title">The {B}-Book: Assigning Programs to Meanings</span>. Cambridge University Press, 1996.</li><li id="Backhouse:03:Program">Roland Carl Backhouse. <span class="book title">Program Construction: Calculating Implementations from
		  Specifications</span>. John Wiley {\&} Sons, Ltd., 2003.</li><li id="Backhouse:11:Algorithmic">Roland Carl Backhouse. <span class="book title">Algorithmic Problem Solving</span>. Wiley, 2011.</li><li id="Bentley:86:Programming">Jon Louis Bentley. <span class="book title">Programming Pearls</span>. Addison-Wesley, 1986.</li><li id="Bird:98:Introduction">Richard Simpson Bird. <span class="book title">Introduction to Functional Programming using Haskell</span>. Prentice Hall, 1998.</li><li id="Bird:10:Pearls">Richard Simpson Bird. <span class="book title">Pearls of Functional Algorithm Design</span>. Cambridge University Press, 2010.</li><li id="Bird:87:Introduction">Richard Simpson Bird. <span class="title">An introduction to the theory of lists</span>. In Broy, Manfred, editors, <span class="book">Logic of Programming and Calculi of Discrete Design</span>, NATO ASI Series F no. 36, pages 5-42. Springer-Verlag, 1987.</li><li id="Bird:84:Circular">Richard Simpson Bird. <span class="title">Using circular programs to eliminate multiple traversals
		  of data</span>. <span class="book">Acta Informatica</span>, 21(3):239-250, 1984.</li><li id="Bird:96:Generic">Richard Simpson Bird, Oege de Moor, and Paul F. Hoogendijk. <span class="title">Generic functional programming with types and relations</span>. <span class="book">Journal of Functional Programming</span>, 6(1):1-28, 1996.</li><li id="BurstallDarlington:77:Transformation">Rod M. Burstall and John Darlington. <span class="title">A transformation system for developing recursive
		  programs</span>. <span class="book">Journal of the ACM</span>, 24(1):44-67, 1977.</li><li id="Curry:80:Some">Haskell Brooks Curry. <span class="title">Some philosophical aspects of combinatory logic</span>. In Barwise, Jon and Keisler, H. Jerome and Kunen, Kenneth, editors, <span class="book">The Kleene Symposium</span>, pages 85-101. North-Holland, 1980.</li><li id="Dijkstra:00:Notational">Edsger Wybe Dijkstra. <span class="title">The notational conventions {I} adopted, and why</span>.  EWD 1300, 2000.</li><li id="Dijkstra:04:Next">Edsger Wybe Dijkstra. <span class="title">The next fifty years</span>.  EWD 1243, Eindhoven University of Technology, 2004.</li><li id="Dijkstra:74:Programming">Edsger Wybe Dijkstra. <span class="title">Programming as a discipline of mathematical nature</span>. <span class="book">American Mathematical Monthly</span>, 81(6):608-612, May 1974. EWD 361</li><li id="Dijkstra:86:OnNaming">Edsger Wybe Dijkstra and Antonetta Johanna Maria van Gasteren. <span class="title">On naming</span>.  AvG 67 / EWD 958, 1986.</li><li id="DijkstraScholten:90:Predicate">Edsger Wybe Dijkstra and Carel S. Scholten. <span class="book title">Predicate Calculus and Program Semantics</span>. Springer-Verlag, 1990.</li><li id="Frege:60:Function">Friedrich Ludwig Gottlob Frege. <span class="title">Function and concept. Translated by {P}eter {T}. {G}each</span>. In Geach, Peter T and Black, Max, editors, <span class="book">Translations from the Philosophical Writings of Gottlob
		  Frege</span>, pages 21-41. Basil Blackwell, 1960.</li><li id="Gibbons:97:Calculating">Jeremy Gibbons. <span class="title">Calculating Functional Programs</span>. In <span class="book">Proceedings of ISRG/SERG Research Colloquium</span>, November 1997.</li><li id="GibbonsHutton:01:When">Jeremy Gibbons, Graham Hutton, and Thorsten Altenkirch. <span class="title">When is a function a fold or an unfold?</span>. In Corradini, Andrea and Lenisa, Marina and Montanari, Ugo, editors, <span class="book">Workshop on Coalgebraic Methods in Computer Science</span>, Electronic Notes in Theoretical Computer Science no. 44.1, Elsevier Science Publishers, April 2001.</li><li id="GriesSchneider:03:Calculational">David Gries and Fred B. Schneider. <span class="title">Calculational logic</span>.  \url{https://www.cs.cornell.edu/gries/Logic/intro.html}, 2003.</li><li id="GriesSchneider:93:Logical">David Gries and Fred B. Schneider. <span class="book title">A Logical Approach to Discrete Math</span>. Springer, October 22, 1993.</li><li id="Hinze:09:La">Ralf Hinze. <span class="title">La tour D'{H}ano{\"{i}}</span>. In Tolmach, Andrew, editors, <span class="book">International Conference on Functional Programming</span>, pages 3-10. ACM Press, 2009.</li><li id="Hoare:62:Quicksort">Charles Anthony Richard Hoare. <span class="title">Quicksort</span>. <span class="book">The Computer Journal</span>, 5(1):10--16, January 1962.</li><li id="Hoare:61:Partition">Charles Anthony Richard Hoare. <span class="title">Algorithm 63: Partition</span>. <span class="book">Communications of the ACM</span>, 4(7):321, 1961.</li><li id="Hoare:61:Quicksort">Charles Anthony Richard Hoare. <span class="title">Algorithm 64: Quicksort</span>. <span class="book">Communications of the ACM</span>, 4(7):321, 1961.</li><li id="Hoare:61:Find">Charles Anthony Richard Hoare. <span class="title">Algorithm 65: Find</span>. <span class="book">Communications of the ACM</span>, 4(7):321-322, 1961.</li><li id="HuIwasaki:97:Tupling">Zhenjiang Hu, Hideya Iwasaki, Masato Takeichi, and Akihiko Takano. <span class="title">Tupling calculation eliminates multiple data traversals</span>. In Peyton Jones, Simon L. and Tofte, Mads, editors, <span class="book">International Conference on Functional Programming</span>, pages 164-175. ACM Press, 1997.</li><li id="Hudak:07:Being">Paul Hudak, R. John Muir Hughes, Simon L. Peyton Jones, and Philip Lee Wadler. <span class="title">A history of {H}askell: being lazy with class</span>. In Ryder, Barbara and Hailpern, Brent, editors, <span class="book">History of Programming Languages III</span>, pages 1-55. ACM Press, 2007.</li><li id="Hughes:86:Novel">R. John Muir Hughes. <span class="title">A novel representation of lists and its application to the
		  function ``reverse''</span>. <span class="book">Information Processing Letters</span>, 22:141-144, 1986.</li><li id="Hutton:16:Programming">Graham Hutton. <span class="book title">Programming in Haskell, 2nd Edition</span>. Cambridge University Press, 2016.</li><li id="Kaldewaij:90:Programming">Anne Kaldewaij. <span class="book title">Programming: the Derivation of Algorithms</span>. Prentice Hall, 1990.</li><li id="MannaMcCarthy:69:Properties">Zohar Manna and John McCarthy. <span class="title">Properties of programs and partial function logic</span>. In Meltzer, Bernard and Michie, Donald, editors, <span class="book">Machine Intelligence</span>, pages 27-37. Edinburgh University Press, 1969.</li><li id="MannaPnueli:70:Formalization">Zohar Manna and Amir Pnueli. <span class="title">Formalization of properties of functional programs</span>. <span class="book">Journal of the ACM</span>, 17(3):555-569, 1970.</li><li id="Mazur:14:Enlightening">Joseph Mazur. <span class="book title">Enlightening Symbols: A Short History of Mathematical
		  Notation and Its Hidden Powers</span>. Princeton University Press, 2014. 中譯本：啟蒙的符號：數學符號的誕生、演化和隱藏的力量。譯者：洪萬生,
		  洪贊天, 英家銘, 黃俊瑋, 黃美倫,
		  鄭宜瑾。臉譜出版社，2015.</li><li id="Misra:89:Visionary">Jayadev Misra. <span class="title">A visionary decision</span>. In Broy, Manfred, editors, <span class="book">Constructive Methods in Computing Science: International
		  Summer School directed by F.L. Bauer, M. Broy, E.W.
		  Dijkstra, C.A.R. Hoare</span>, pages 1-3. Springer-Verlag, 1989.</li><li id="Mu:08:Maximum">Shin-Cheng Mu. <span class="title">Maximum segment sum is back: deriving algorithms for two
		  segment problems with bounded lengths</span>. In Gl{\"{u}}ck, Robert and de Moor, Oege, editors, <span class="book">Symposium on Partial Evaluation and Semantics-based
		  Program Manipulation</span>, pages 31-39. ACM Press, jan 2008.</li><li id="MuBird:03:Theory">Shin-Cheng Mu and Richard Simpson Bird. <span class="title">Theory and applications of inverting functions as folds</span>. <span class="book">Science of Computer Programming (Special Issue for
		  Mathematics of Program Construction)</span>, 51:87-116, 2003.</li><li id="OToole:15:Great">Garson O'Toole. <span class="book title">Hemingway Didn't Say That: The Truth Behind Familiar
		  Quotations</span>, Chapter With great power comes great responsibility, Little A, 2017. Published online on Quote Investigator:
		  \url{https://quoteinvestigator.com/2015/07/23/great-power/}</li><li id="Okasaki:99:RedBlack">Chris Okasaki. <span class="title">Red-black trees in a functional setting</span>. <span class="book">Journal of Functional Programming</span>, 9(4):471-477, 1999.</li><li id="Sankar:97:Currying">Nandakumar Sankar, Lloyd Allis, Jonathan Seldi, Jack Camp, Stefan Kahr, Gary Leave, Richard Botti, Antoni Dill, David A. Turner, and James Picton-Warlow. <span class="title">Currying, or Schonfinkeling?</span>.  \url{http://computer-programming-forum.com/23-functional/976f118bb90d8b15.htm}, May 1997.</li><li id="Schonfinkel:24:Uber">Moses Sch{\"{o}}nfinkel. <span class="title">Ub{\"{e}}r die Bausteinen der mathematische Logik</span>. <span class="book">Mathematische Annalen</span>, 92:305-316, 1924. Translated by Stefan Bauer-Mengelberg as ``On the building
		  blocks of mathematical logic'' in Jean van Heijenoort,
		  1967. {\it A Source Book in Mathematical Logic},
		  1879--1931.</li><li id="Snepscheut:93:What">Jan L.A. van de Snepscheut. <span class="book title">What Computing Is All About</span>. Springer, 1993.</li><li id="Strachey:67:Fundamental">Christopher Strachey. <span class="title">Fundamental concepts in programming languages</span>. <span class="book">Higher-Order and Symbolic Computation</span>, 13:11-49, 1967.</li><li id="Wadler:92:Monads">Philip Lee Wadler. <span class="title">Monads for functional programming</span>. In Broy, Manfred, editors, <span class="book">Program Design Calculi: Marktoberdorf Summer School</span>, pages 233-264. Springer-Verlag, 1992.</li><li id="Zantema:92:Longest">Hans Zantema. <span class="title">Longest segment problems</span>. <span class="book">Science of Computer Programming</span>, 18(1):39-66, 1992.</li></ul></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
