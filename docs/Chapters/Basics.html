<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="ToC.html">目錄</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction">0.3 抽象化</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:correctness">0.5 正確性</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:relevant-information">0.7 相關資料</a></li></ul></li><li class="pure-menu-selected pure-menu-item"><a href="#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" checked type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:evaluation">1.1 值與求值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:function-defns">1.2 函數定義</a></li><li class="pure-menu-item"><a href="Basics.html#sec:higher-order-func">1.3 高階函數</a></li><li class="pure-menu-item"><a href="Basics.html#sec:func-comp">1.4 函數合成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:boolean">1.6.1 布林值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:char">1.6.2 字元</a></li><li class="pure-menu-item"><a href="Basics.html#sec:pairs">1.6.3 序對</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:weak-head-normal-form">1.7 弱首範式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:list-deconstruct">1.8.1 串列解構</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-generation">1.8.2 串列生成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:wholemeal">1.9 全麥編程</a></li><li class="pure-menu-item"><a href="Basics.html#sec:user-defined-data">1.10 自訂資料型別</a></li><li class="pure-menu-item"><a href="Basics.html#sec:refs-basics">1.11 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:math-induction">2.1 數學歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li><li class="pure-menu-item"><a href="Induction.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:list-segments">2.6.3 串列區段</a></li><li class="pure-menu-item"><a href="Induction.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li><li class="pure-menu-item"><a href="Induction.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li><li class="pure-menu-item"><a href="Induction.html#sec:complete-induction">2.11 完全歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:well-founded-induction">2.12 良基歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:mutual-induction">2.14 交互歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-ref">2.15 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.1 紅黑樹插入</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.2 紅黑樹之性質：高度</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.3 紅黑樹之性質：平衡</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.4 紅黑樹之性質：顏色</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics.html#sec:denotational-semantics">4.1 指稱語意</a></li><li class="pure-menu-item"><a href="Semantics.html#sec:operational-semantics">4.2 操作語意</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:efficiency-basics">5.2 關於執行效率</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:var-cons">5.4 變數換常數</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:steep">5.5.1 陡串列</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion">5.6.3 尾遞迴</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:difference-list">5.6.6 函數作為串列</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li><li class="pure-menu-item"><a href="Folds.html#sec:scan-lemma">6.2.3 掃描</a></li><li class="pure-menu-item"><a href="Folds.html#sec:banana-split">6.2.4 香蕉船定理</a></li><li class="pure-menu-item"><a href="Folds.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li><li class="pure-menu-item"><a href="Folds.html#sec:bring-in-context">6.2.6 引入脈絡</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldl">6.3.1 左摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:list-homomorphism">6.3.2 串列同構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldN">6.4 自然數的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:folds-ref">6.6 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-segment-sum">7.1 最大區段和</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:segProblems-ref">7.3 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:exceptions">8.1 例外處理</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-class-laws">8.2 單子與單子律</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:var-env-reader">8.3.1 變數與環境</a></li><li class="pure-menu-item"><a href="Monads.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:hanoi">8.4.1 河內塔問題</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#">8.5 參考資料</a></li></ul></li></ul></nav><p><a href="Ix.html">索引</a></p><p><a href="Biblio.html">參考書目</a></p><p class="author-info"><a href="https://  homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div><div id="main"><div class="header"><h1 class="chapter" id="ch:basics">1 值、函數、與定義</h1></div><div class="content"><p>語言是概念的載體。&shy;如第<a href="Introduction.html#ch:intro">0 </a>章所述，程式語言不僅用來表達概念，也用於演算，分擔我們思考的負擔。&shy;在本書中，為便於精確說明，我們也不得不選一個語言。</p><p>本書中使用的語言大致上基於 Haskell, 但為適合本書使用而經過簡化、修改。&shy;我們將在本章初步介紹 Haskell 語言的一小部分，包括在 Haskell 中何謂「計算」、值與函數的定義、常見的資料結構，以及串列上的常用函數。&shy;目的是讓讀者具備足夠的基本概念，以便進入之後的章節。&shy;也因此，本書中所介紹的語言並非完整的 Haskell, 本書也不應視作 Haskell 語言的教材。&shy;對於有此需求的讀者，我將在本章結尾推薦一些適合的教科書。</p><h2 class="section" id="sec:evaluation">1.1 值與求值</h2><p>Haskell 是個可被編譯(compile)、也可被直譯(interpret)的語言。Haskell 直譯器延續了 LISP 系列語言的傳統，是個「讀、算、印 (read, evaluate, pring)」的迴圈 --- 電腦從使用者端讀取一個算式，算出結果，把結果印出，然後再等使用者輸入下一個算式。一段與 Haskell 直譯器的對話可能是這樣：</p><pre><code class="spec">Main&gt; 3+4
7
Main&gt; sum [1..100]
5050
Main&gt;
</code></pre><p>在此例中，<code class="haskell">Main&gt;</code> 是 Haskell 直譯器的提示符號。&shy;<input class="toggle" id="footnote-1-1-1" type="checkbox"/><label class="fnote-toggle" for="footnote-1-1-1">(註1) </label><span class="collapsible-footnote">此處的人機互動紀錄擷取自 GHCi (Glasgow Haskell Compiler Interactive). GHC 為目前最被廣泛使用的 Haskell 實作。</span>&shy;使用者輸入 <code class="haskell">3+4</code>, Haskell 算出其值 <code class="haskell">7</code> 並印出.&shy;接著，使用者想得知 <code class="haskell">1</code> 到 <code class="haskell">100</code> 的和，Haskell 算出 <code class="haskell">5050</code>.</p><p>上例中的算式只用到 Haskell 已知的函數（如<code class="haskell">(+)</code>, <code class="haskell">sum</code>等）。&shy;使用者若要自己定義新函數，通常得寫在另一個檔案中，命令 Haskell 直譯器去讀取。&shy;例如，我們可把如下的定義寫在一個檔案中：</p><pre><code class="spec">double :: Int -&gt; Int
double x = x + x 
</code></pre><p>上述定義的第一行是個型別宣告。當我們寫 <code class="haskell">e :: t</code>, 代表 <code class="haskell">e</code> 具有型別 <code class="haskell">t</code>.&shy;<span id="ix-1-1"></span>&shy;<code class="haskell">Int</code> 是整數的型別，而箭號 <code class="haskell">(-&gt;)</code> 為函數型別的建構元。第一行 <code class="haskell">double :: Int -&gt; Int</code> 便是告知電腦我們將定義一個新識別字 <code class="haskell">double</code>, 其型別為「從整數(<code class="haskell">Int</code>)到整數的函數」。&shy;<input class="toggle" id="footnote-1-1-2" type="checkbox"/><label class="fnote-toggle" for="footnote-1-1-2">(註2) </label><span class="collapsible-footnote">Haskell 標準中有多種整數，其中 <code class="haskell">Int</code> 為有限大小（通常為該電腦中一個<em>字組</em>(word)）的整數，<code class="haskell">Integer</code> 則是所謂的<em>大整數</em>或<em>任意精度整數</em>，無大小限制。本書中只使用 <code class="haskell">Int</code>.</span>&shy;至於該函數的定義本體則在第二行 <code class="haskell">double x = x + x</code>, 告知電腦「凡看到 <code class="haskell">double x</code>, 均可代換成 <code class="haskell">x + x</code>.」</p><p><b>求值</b> &emsp;第<a href="Introduction.html#ch:intro">0 </a>章曾提及：一套程式語言是設計者看待世界的抽象觀點。程式通常用來表達計算，因此程式語言也得告訴我們：在其假想的世界中，「計算」是怎麼一回事。&shy;指令式語言的世界由許多容器般的變數組成，計算是將值在變數之間搬來搬去。&shy;邏輯編程<span id="ix-1-2"></span>中，描述一個問題便是寫下事物間的邏輯關係，計算是邏輯規則「歸結(resolution)」<span id="ix-1-3"></span>的附帶效果。&shy;共時(concurrent)<span id="ix-1-4"></span>程式語言著眼於描述多個同時執行的程式如何透過通道傳遞訊息，計算也靠此達成。</p><div class="infobox infobox" title="演算格式"><h5 class="infobox-title">演算格式</h5>%format expr0
%format expr1
%format expr2
%format exprn = "\Varid{expr}_{n}"
%format reason0
%format reason1<br/>
<p>本書中將使用如下的格式表達（不）等式演算或推論：</p><pre><code class="spec">   expr0
 =   { reason0 }
   expr1
 &gt;=  { reason1 }
   expr2
   :
 = exprn 
</code></pre><p>這是一個 <code class="haskell">expr0 &gt;= exprn</code> 的證明。式子 <code class="haskell">expr0 .. exprn</code> 用具有遞移律的運算子(如<code class="haskell">(=)</code>, <code class="haskell">(&gt;=)</code>等等)串起。放在大括號中的是註解，例如 <code class="haskell">reason0</code> 是 <code class="haskell">expr0 = expr1</code> 的原因，<code class="haskell">reason1</code> 是 <code class="haskell">expr1 &gt;= expr2</code> 的原因。</p><p>根據 <a href="Biblio.html#Snepscheut:93:What">van de Snepscheut [1993, p19]</a>, 此格式最早由 W.H.J. Feijen 所建議。</p></div><p>函數語言中，一個程式便是一個數學式，而「計算」便是依照該式子中各個符號的定義，反覆地展開、歸約，直到算出一個「值」為止。&shy;這個過程又稱作「求值(evaluation)」<span id="ix-1-5"></span>。&shy;在 Haskell 直譯器中，若 <code class="haskell">double</code> 的定義已被讀取，輸入 <code class="haskell">double (9 * 3)</code>, 電腦會算出 <code class="haskell">54</code>:</p><pre><code class="spec">Main&gt; double (9 * 3)
54
</code></pre><p>但 <code class="haskell">54</code> 這個值是怎麼被算出來的？以下是其中一種可能：</p><pre><code class="spec">  double (9 * 3)
=   <comment>{- <code class="haskell">(*)</code> 的定義 -}</comment>
  double 27
=   <comment>{- <code class="haskell">double</code> 的定義 -}</comment>
  27 + 27
=   <comment>{- <code class="haskell">(+)</code> 的定義 -}</comment>
  54 
</code></pre><p>上述演算的第一步將 <code class="haskell">9*3</code> 歸約成 <code class="haskell">27</code> --- 我們尚未定義 <code class="haskell">(*)</code> 與 <code class="haskell">(+)</code>, 但目前只需知道它們與大家所熟悉的整數乘法、加法相同。&shy;第二步將 <code class="haskell">double 27</code> 變成 <code class="haskell">27 + 27</code>, 根據的是 <code class="haskell">double</code> 的定義：<code class="haskell">double x = x + x</code>.&shy;最後，<code class="haskell">27 + 27</code> 理所當然地歸約成 <code class="haskell">54</code>.&shy;「歸約」<span id="ix-1-6"></span>一詞由 $\beta$-reduction 而來，在此處指將函數本體中的形式參數代換為實際參數。%&shy;<input class="toggle" id="footnote-1-1-3" type="checkbox"/><label class="fnote-toggle" for="footnote-1-1-3">(註3) </label><span class="collapsible-footnote">Reduction 的另一個常見譯名是「化簡」，然而，許多情況下，一個式子被 reduce 後變得更長而不「簡」，因此本書譯為「歸約」。</span>&shy;在上述例子中，我們遇到如 <code class="haskell">double (9*3)</code> 的函數呼叫，先將參數 (<code class="haskell">9*3</code>)化簡，再展開函數定義，可說是<em>由內到外</em>的歸約方式。&shy;大部分程式語言都依這樣的順序求值，讀者可能也對這種順序較熟悉。</p><p>但這並不是唯一的求值順序。我們能否由外到內，先把 <code class="haskell">double</code> 展開呢？</p><pre><code class="spec">  double (9 * 3)
=   <comment>{- <code class="haskell">double</code> 的定義 -}</comment>
  (9 * 3) + (9 * 3)
=   <comment>{- <code class="haskell">(*)</code> 的定義 -}</comment>
  27 + (9 * 3)
=   <comment>{- <code class="haskell">(*)</code> 的定義 -}</comment>
  27 + 27
=   <comment>{- <code class="haskell">(+)</code> 的定義 -}</comment>
  54 
</code></pre><p>以這個順序求值，同樣得到 <code class="haskell">54</code>.</p><p>一般說來，一個式子有許多種可能的求值順序：可能是由內往外、由外往內、或其他更複雜的順序。&shy;我們自然想到一個問題：這些不同的順序都會把該式子化簡成同一個值嗎？&shy;有沒有可能做出一個式子，使用一個順序會被化簡成 <code class="haskell">54</code>, 另一個順序化簡成 <code class="haskell">53</code>?</p><p>我們看看如下的例子。&shy;函數 <code class="haskell">three</code> 顧名思義，不論得到什麼參數，都傳回 <code class="haskell">3</code>；<code class="haskell">inf</code> 則是一個整數：</p><pre><code class="spec">three :: Int -&gt; Int
three x = 3 

inf :: Int
inf = 1 + inf 
</code></pre><p>在指令式語言中，<code class="haskell">inf</code> 的定義可能會被讀解為「將變數 <code class="haskell">inf</code> 的值加一」。&shy;但函數語言中「變數」的值是不能更改的。&shy;此處的意義應是：<code class="haskell">inf</code> 是一個和 <code class="haskell">1 + inf</code> 相等的數值。&shy;我們來看看 <code class="haskell">three inf</code> 會被為甚麼？&shy;如果我們由內往外求值：</p><pre><code class="spec">  three inf
=   <comment>{- <code class="haskell">inf</code> 的定義 -}</comment>
  three (1 + inf)
=   <comment>{- <code class="haskell">inf</code> 的定義 -}</comment>
  three (1 + (1 + inf))
=   <comment>{- <code class="haskell">inf</code> 的定義 -}</comment>
  ...
</code></pre><p>看來永遠停不下來！但如果我們由外往內，<code class="haskell">three inf</code> 第一步就可變成 <code class="haskell">3</code>：</p><pre><code class="spec">  three inf
=   <comment>{- <code class="haskell">three</code> 的定義 -}</comment>
  3 
</code></pre><p>我們該如何理解、討論這樣的現象呢？</p><p><b>範式與求值順序</b> &emsp;&shy;為描述、討論相關的現象，我們得非正式地介紹一些術語。&shy;用較直觀、不形式化的方式理解，一個式子中「接下來可歸約之處」稱作其<em>歸約點(redex)</em><span id="ix-1-7"></span>。例如<code class="haskell">(9*3) + (4*6)</code>中，<code class="haskell">9*3</code> 與 <code class="haskell">4*6</code> 都是歸約點。&shy;如果一個式子已沒有歸約點、無法再歸約了，我們說該式已是個<em>範式 (normal form)</em><span id="ix-1-8"></span>。</p><p>回頭看，經由之前的例子我們已得知：</p><ul><li><p>有些式子有範式(如 <code class="haskell">double (9*3)</code> 有個範式 <code class="haskell">54</code>)，有些沒有（如 <code class="haskell">inf</code>）。</p></li><li><p>同一個式子可用許多順序求值。有些求值順序會碰到範式，有些不會。</p></li></ul><p>給一個式子，我們很自然地希望知道它有沒有值，並算出其值。如果一個式子有很多個範式，我們便難說哪一個才是該式子的「值」。如此一來，立刻衍生出幾個問題。給定一個式子，我們是否能得知它有沒有範式呢？如果有，用哪個求值順序才能得到那個範式？以及，有沒有可能用一個求值順序會得到某範式，換另一個求值順序卻得到另一個範式？</p><p>很不幸地，第一個問題的答案是否定的：沒有一套固定的演算法可判定任意一個式子是否有範式。&shy;這相當於計算理論中常說到的<em>停機問題(halting problem)</em> --- 沒有一個演算法能準確判斷任意一個演算法（對某個輸入）是否能正常終止。</p><p>但對於另兩個問題，計算科學中有個重要的<em>Church-Rosser 定理</em><span id="ix-1-9"></span>。&shy;非常粗略地說，該定理告訴我們：在我們目前討論的這類語言中%&shy;<input class="toggle" id="footnote-1-1-4" type="checkbox"/><label class="fnote-toggle" for="footnote-1-1-4">(註4) </label><span class="collapsible-footnote">此處討論的可粗略說是以 $\lambda$-calculus 為基礎的函數語言。基於其他概念設計的程式語言當然可能不遵守 Church-Rosser 定理。</span></p><ul><li><p>一個式子<em>最多只有一個</em>範式。</p></li><li><p>如果一個式子有範式，使用由外到內的求值順序可得到該範式。</p></li></ul><p>如此一來，給定任一個式子，我們都可用由外到內的方式算算看。&shy;假設一算之下得到（例如）<code class="haskell">54</code>。&shy;用其他的求值順序可能得不到範式，但若有了範式，必定也是 <code class="haskell">54</code>.&shy;如果由外到內的順序得不到範式，用其他任何順序也得不到。</p><p>由於「由外到內」的求值順序有「最能保證得到範式」的性質，又被稱作「<em>範式順序</em> (<em>normal order evaluation</em>)」\index {evaluation 求值!normal order 範式順序}。&shy;「由內到外」的則被稱作「<em>應用順序</em>(<em>applicative order evaluation</em>)」\index {evaluation 求值!applicative order 應用順序}。&shy;以本書的目的而言，我們可大致把 Haskell 使用的求值方式視為範式順序。&shy;但請讀者記得這是個粗略、不盡然正確的說法 --- Haskell 實作上使用的求值方式經過了更多最佳化。&shy;正式的 $\lambda$-calculus 教科書中對於歸約點、求值順序、Church-Rosser 定理等概念會有更精確的定義。</p><p><b>被迫求值</b> &emsp;&shy;型別 <code class="haskell">Bool</code> 表示真假，有兩個值 <code class="haskell">False</code> 和 <code class="haskell">True</code>。&shy;常用的函數 <code class="haskell">not</code> 可定義如下：</p><pre><code class="spec">not :: Bool -&gt; Bool
not False  = True
not True   = False 
</code></pre><p>此處 <code class="haskell">not</code> 的定義依輸入值不同而寫成兩個條款。&shy;這種定義方式在 Haskell 中稱作<em>樣式配對</em>(<em>pattern matching</em>)：&shy;<code class="haskell">False</code> 與 <code class="haskell">True</code> 在此處都是樣式 (patterns)。<span id="ix-1-10"></span>&shy;遇到這樣的定義時，Haskell 將輸入<em>依照順序</em>與樣式們一個個比對。&shy;如果對得上，便傳回相對應的右手邊。&shy;本例中，若輸入為 <code class="haskell">False</code>，傳回值為 <code class="haskell">True</code>，否則傳回值為 <code class="haskell">False</code>。</p><p>我們來看看 <code class="haskell">not (5 &lt;= 3)</code> 該怎麼求值？若依照範式順序，照理來說應先將 <code class="haskell">not</code> 的定義展開。&shy;但若不知 <code class="haskell">5 &lt;= 3</code> 的值究竟是 <code class="haskell">False</code> 還是 <code class="haskell">True</code>, 我們不知該展開哪行定義！&shy;因此，要計算 <code class="haskell">not (5 &lt;= 3)</code>，也只好先算出 <code class="haskell">5 &lt;=3</code> 了：</p><pre><code class="spec">  not (5 &lt;= 3)
=   <comment>{- <code class="haskell">(&lt;=)</code> 之定義 -}</comment>
  not False
=   <comment>{- <code class="haskell">not</code> 之定義 -}</comment>
  True 
</code></pre><p>求值過程中若必須得知某子算式的值才能決定如何進行，只好先算那個子算式。&shy;在 Haskell 中有不少（有清楚定義的）場合得如此，&shy;包括遇上<code class="haskell">(&lt;=)</code>、<code class="haskell">(&gt;=)</code> 等運算子、樣式配對、<code class="haskell">case</code> 算式（將於第<a href="Basics.html#sec:boolean">1.6.1 </a>節中介紹）...等等。</p><div class="exlist"><div class="exercise exer" id="ex:myeven"><h5 class="exercise-title">練習 1.1 </h5><p>定義一個函數 <code class="haskell">myeven :: Int -&gt; Bool</code>，判斷其輸入是否為偶數。&shy;你可能用得到以下函數：<input class="toggle" id="footnote-1-1-5" type="checkbox"/><label class="fnote-toggle" for="footnote-1-1-5">(註5) </label><span class="collapsible-footnote">此處所給的並非這些函數最一般的型別。</span></p><pre><code class="spec">mod   :: Int -&gt; Int -&gt; Int 
(==)  :: Int -&gt; Int -&gt; Bool 
</code></pre><p>其中 <code class="haskell">mod x y</code> 為 <code class="haskell">x</code> 除以 <code class="haskell">y</code> 之餘數，<code class="haskell">(==)</code> 則用於判斷兩數是否相等。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-1" type="checkbox"/><label class="lbl-toggle" for="ans-1-1">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="spec">myeven   :: Int -&gt; Bool
myeven x = x `mod` 2 == 0  
</code></pre></div></div><div class="exercise exer" id="ex:circle-area"><h5 class="exercise-title">練習 1.2 </h5><p>定義一個函數 <code class="haskell">area :: Float -&gt; Float</code>, 給定一個圓的半徑，&shy;計算其面積。（可粗略地將 <code class="haskell">22/7</code> 當作圓周率。）</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-2" type="checkbox"/><label class="lbl-toggle" for="ans-1-2">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="spec">area    :: Float -&gt; Float
area r  = (22/7) * r * r 
</code></pre></div></div></div><p id="para:lazy-evaluation"><b>惰性求值</b> &emsp;&shy;<span id="ix-1-11"></span>&shy;實作上，Haskell 求值的方式還經過了更多的最佳化：&shy;例如將歸約過的算式改寫為它的值，避免重複計算。&shy;這套求值方式稱為<em>惰性求值</em>(<em>lazy evaluation</em>).</p><p>技術上說來，惰性求值和範式順序求值並不一樣。&shy;但前者可視為後者的最佳化實作 --- 惰性求值的結果必須和範式順序求值相同。&shy;因此，在本書之中大部分地方可忽略他們的差異。&shy;和惰性求值對偶的是<em>及早求值</em>(<em>eager evaluation</em>)&shy;<span id="ix-1-12"></span>，&shy;可視為應用順序求值的實作 --- 在呼叫一個函數之前，總是把其參數先算成範式。&shy;這也是一般程式語言較常見的計算方法。</p><p>本書中談到偏向實作面的議題時會用「惰性求值/及早求值」，&shy;在談不牽涉到特定實作的理論時則使用「範式順序求值/應用順序求值」。</p><h2 class="section" id="sec:function-defns">1.2 函數定義</h2><p>考慮如下的函數定義：</p><pre><code class="spec">smaller :: Int -&gt; Int -&gt; Int
smaller x y = if x &lt;= y then x else y 
</code></pre><p>我們可粗略地理解為：<code class="haskell">smaller</code> 是一個函數，拿兩個參數 <code class="haskell">x</code> 與 <code class="haskell">y</code>，傳回其中較小的那個。&shy;如 <code class="haskell">smaller (double 6) (3+4)</code> 的值為 <code class="haskell">7</code>.</p><div class="exlist"><div class="exercise exer" id="ex:smaller-normal-form"><h5 class="exercise-title">練習 1.3 </h5><p>用前一節介紹的求值順序，將<code class="haskell">smaller (double 6) (3+4)</code>化簡為範式。</p></div></div><p><b>守衛</b> &emsp; 如果函數本體做的第一件事就是條件判斷，Haskell 提供另一種語法：</p><pre><code class="spec">smaller :: Int -&gt; Int -&gt; Int
smaller x y  | x &lt;= y  = x
             | x &gt; y   = y 
</code></pre><p>這麼寫出的 <code class="haskell">smaller</code> 的行為仍相同：如果 <code class="haskell">x &lt;= y</code> 成立，傳回 <code class="haskell">x</code>；如果 <code class="haskell">x &gt; y</code>, 傳回 <code class="haskell">y</code>。&shy;但這種語法較接近一些數學教科書中定義函數的寫法。&shy;其中，放在 <code class="haskell">x &lt;=y</code> 和 <code class="haskell">x &gt; y</code> 等位置的必須是型別為 <code class="haskell">Bool</code> 的算式。&shy;它們擋在那兒，只在值為 <code class="haskell">True</code> 的時候才讓執行「通過」，因此被稱為<em>守衛</em>(<em>guard</em>)<span id="ix-1-13"></span>。&shy;如果有三個以上的選項，如下述例子，使用守衛比 <code class="haskell">if .. then.. else</code> 更清晰可讀：</p><pre><code class="spec">sign :: Int -&gt; Int
sign x  | x &gt; 0   = 1
        | x == 0  = 0
        | x &lt; 0   = -1 
</code></pre><p>遇到數個守衛時，Haskell 將<em>依照順序</em>嘗試每個選項，直到碰到第一個為真的守衛，然後只執行該項定義。&shy;也就是說， 即使我們把 <code class="haskell">sign</code> 定義中的 <code class="haskell">x == 0</code> 改為 <code class="haskell">x &gt;= 0</code>, <code class="haskell">sign 10</code> 的值仍會是 <code class="haskell">1</code>。&shy;若每個守衛都是 <code class="haskell">False</code>, 程式則將中斷執行（並傳回一個錯誤訊息）。&shy;在許多程式中，我們會希望最後一個守衛能捕捉所有的漏網之魚：如果其他條款都不適用，就執行最後一個。一種做法是讓一個守衛是 <code class="haskell">True</code>。或著，在 Haskell 中有個 <code class="haskell">otherwise</code> 關鍵字可讓定義讀來更口語化些：</p><pre><code class="spec">sign :: Int -&gt; Int
sign x  | x &gt; 0      = 1
        | x == 0     = 0
        | otherwise  = -1 
</code></pre><p>事實上，<code class="haskell">otherwise</code> 的定義就是 <code class="haskell">otherwise = True</code>.</p><p><b>區域識別字</b> &emsp; Haskell 提供兩種宣告區域識別字的語法：<code class="haskell">let</code> 與 <code class="haskell">where</code>.&shy;也許最容易理解的方式是用例子說明。</p><div class="theorem" id="eg:payment"><h5 class="theorem-title">例 1.1  </h5><p>工讀生每小時的時薪為新台幣 130 元。&shy;假設一週有五個工作天，每天有八小時上班時間。&shy;定義一個函數 <code class="haskell">payment :: Int -&gt; Int</code>，輸入某學生工作的週數，計算其薪資。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-3" type="checkbox"/><label class="lbl-toggle" for="ans-1-3">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>我們當然可直接用一個式子算出薪資。但為清楚起見，我們可用兩個區域識別字 <code class="haskell">days</code> 和 <code class="haskell">hours</code>,&shy;分別計算該學生工作的日數和時數。如果用 <code class="haskell">let</code>, 可這麼做。</p><pre><code class="spec">payment :: Int -&gt; Int
payment weeks =  let  days   = 5 * weeks
                      hours  = 8 * days
                 in 130 * hours 
</code></pre><p><code class="haskell">let</code> 算式的語法為</p><pre><code class="spec">  let  x1 = e1
       x2 = e2 ....
  in e 
</code></pre><p>其中 <code class="haskell">e</code> 為整個算式的值，而 <code class="haskell">x1</code>, <code class="haskell">x2</code> 等等為區域識別字。兩個區域識別字的有效範圍包括 <code class="haskell">e</code>, 以及 <code class="haskell">e1</code> 與 <code class="haskell">e2</code>。</p><p>另一種語法是 <code class="haskell">where</code> 子句。若用它定義 <code class="haskell">payment</code>, 可寫成這樣：</p><pre><code class="spec">payment :: Int -&gt; Int
payment weeks = 130 * hours 
  where  hours  = 8 * days
         days   = 5 * weeks 
</code></pre></div></div><p>該用 <code class="haskell">let</code> 或是 <code class="haskell">where</code>?&shy;大部份時候這可依個人習慣，看寫程式的人覺得怎麼說一件事情比較順。&shy;使用 <code class="haskell">let</code> 時，敘事的順序是由小到大，先給「工作日數」、「工作時數」等小元件的定義，再用他們組出最後的式子 <code class="haskell">130 * hours</code>。&shy;使用 <code class="haskell">where</code> 時則是由大到小，先說我們要算「工作時數乘以 130」，然後補充「其中，工作時數的定義是...」。</p><p>但，Haskell 之所以保留了兩種語法，是為了因應不同的用途。語法上，<code class="haskell">let</code> 是一個算式，可出現在算式中。如下的算式是合法的，其值為 <code class="haskell">24</code>:</p><pre><code class="spec">   (1 + 1) * (let y = double 5 in y + 2) 
</code></pre><p><code class="haskell">where</code> 子句的一般語法則如下例所示：</p><pre><code class="spec">f x0 = d0
   where y0 = e0
f x1 = d1
   where y1 = e1 
</code></pre><p>由語法設計上即可看出，子句 <code class="haskell">where y0 = e0</code> 只能放在 <code class="haskell">f x0 = ...</code> 的一旁當作補述，不能出現在 <code class="haskell">d0</code> 之中。&shy;這個例子中， <code class="haskell">y0</code> 的有效範圍含括 <code class="haskell">d0</code> 與 <code class="haskell">e0</code>。另，<code class="haskell">e0</code> 可以使用 <code class="haskell">x0</code>.</p><p>算式中只能用 <code class="haskell">let</code>. 相對地，也有些只能使用 <code class="haskell">where</code> 的場合。我們來看&shy;我們來看一個只能使用 <code class="haskell">where</code> 的例子：</p><div class="theorem" id="eg:payment2"><h5 class="theorem-title">例 1.2  </h5><p>延續例 <a href="Basics.html#eg:payment">1.1 </a>。&shy;今年起，新勞動法規規定工作超過 19 週的工讀生必須視為正式雇員，&shy;學校除了薪資外，也必須付給勞保、健保費用。&shy;學校需負擔的勞健保金額為雇員薪資的百分之六。請更新函數 <code class="haskell">payment</code>,&shy;輸入某工讀生工作週數，計算在新規定之下，學校需為工讀生付出的總額。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-3" type="checkbox"/><label class="lbl-toggle" for="ans-1-3">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>一種可能寫法是先使用守衛，判斷工作週數是否大於 19：</p><pre><code class="spec">payment :: Int -&gt; Int
payment weeks  | weeks &gt; 19  = round (fromIntegral baseSalary * 1.06)
               | otherwise   = baseSalary 
 where  baseSalary = 130 * hours
        hours  = 8 * days
        days   = 5 * weeks 
</code></pre><p>在 <code class="haskell">where</code> 子句中，我們先算出不含勞健保費用的薪資，用識別字 <code class="haskell">baseSalary</code> 表達。&shy;如果 <code class="haskell">weeks</code> 大於 <code class="haskell">19</code>, 我們得將 <code class="haskell">baseSalary</code> 乘以 <code class="haskell">1.06</code>；否則即傳回 <code class="haskell">baseSalary</code>.&shy;函數 <code class="haskell">fromIntegral</code> 把整數轉為浮點數，<code class="haskell">round</code> 則把浮點數四捨五入為整數。&shy;請注意：兩個被守衛的算式都用到了 <code class="haskell">baseSalary</code> ---&shy;<code class="haskell">where</code> 子句中定義的識別字是可以跨越守衛的。&shy;相較之下，<code class="haskell">let</code> 算式只能出現在等號的右邊，而在守衛 <code class="haskell">weeks &gt; 19 = ...</code> 之後出現的&shy;<code class="haskell">let</code> 所定義出的區域識別字，顯然無法在 <code class="haskell">otherwise = ...</code> 之中被使用，反之亦然。</p></div></div><p><b>巢狀定義</b> &emsp; <code class="haskell">let</code> 算式之中還可有 <code class="haskell">let</code> 算式，&shy;<code class="haskell">where</code> 子句中定義的識別字也可有自己的 <code class="haskell">where</code> 子句。&shy;我們看看兩個關於 <code class="haskell">let</code> 的例子：</p><div class="theorem" id="eg:nested-recursive"><h5 class="theorem-title">例 1.3  </h5><p>猜猜看 <code class="haskell">nested</code> 和 <code class="haskell">recursive</code> 的值分別是什麼。&shy;將他們載入 Haskell 直譯器，看看和你的猜測是否相同。</p><div class="multicols"><div class="mcol" width="0.4\textwidth"><pre><code class="spec">nested :: Int
nested =  let x = 3
          in (  let  x = 5
                in x + x) + x 
</code></pre></div><div class="mcol" width="0.4\textwidth"><pre><code class="spec">recursive :: Int
recursive =  let x = 3
             in  let x = x + 1
                 in x 
</code></pre></div></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-3" type="checkbox"/><label class="lbl-toggle" for="ans-1-3">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p><code class="haskell">nested</code> 的值是 <code class="haskell">13</code>，因為 <code class="haskell">x+x</code> 之中的 <code class="haskell">x</code> 在 <code class="haskell">let x = 5</code> 的範圍中,&shy;而 <code class="haskell">.. + x</code> 中的 <code class="haskell">x</code> 則在 <code class="haskell">let x = 3</code> 的範圍中。<input class="toggle" id="footnote-1-2-6" type="checkbox"/><label class="fnote-toggle" for="footnote-1-2-6">(註6) </label><span class="collapsible-footnote">在各種語言中，範圍的設計都是為了給程式員方便：在寫子算式時，可不用擔心是否與外層的識別字撞名。在教學時，我們難免舉各種撞名的例子作為說明。若把這些刁鑽例子當作考題，就是違反設計者本意的發展了。</span>&shy;至於 <code class="haskell">recursive</code> 的值，關鍵在於 <code class="haskell">x = x + 1</code> 中右手邊的 <code class="haskell">x</code> 指的是哪個。&shy;若是 <code class="haskell">x = 3</code> 的那個 <code class="haskell">x</code>, 整個算式的值將是 <code class="haskell">4</code>. 若 <code class="haskell">x = x + 1</code> 中，&shy;等號右手邊的 <code class="haskell">x</code> 也是左手邊的 <code class="haskell">x</code>, <code class="haskell">recursive</code> 就是 <code class="haskell">((..)+1)+1</code> , 沒有範式。&shy;這兩種設計都有其道理。&shy;Haskell 選了後者：在 <code class="haskell">let x = e in ...</code> 之中，<code class="haskell">x</code> 的有效範圍包括 <code class="haskell">e</code>.&shy;因此 <code class="haskell">recursive</code> 在 Haskell 中會無窮地求值下去。&shy;但也有些函數語言中的 <code class="haskell">let</code> 採用前者的設計。通常這類語言中會另有一個 $\Keyword{letrec}$&shy;結構，和 Haskell 的 <code class="haskell">let</code> 功能相同。</p></div></div></div><h2 class="section" id="sec:higher-order-func">1.3 高階函數</h2><p>目前為止，我們看過由整數到整數的函數、由整數到真假值的函數...&shy;那麼，可以有由函數到函數的函數嗎？&shy;函數語言將函數視為重要的構成元件，因此函數也被視為<em>一級公民</em>。&shy;如果整數、真假值... 可以當作參數、可以被函數傳回，函數當然也可以。&shy;一個「輸入或輸出也是函數」的函數被稱為<em>高階函數</em>(<em>higher order function</em>)<span id="ix-1-14"></span>。&shy;Haskell 甚至設計了許多鼓勵我們使用高階函數的機制。&shy;本書中我們將見到許多高階函數。其實，我們已經看過一個例子了。</p><div class="infobox infobox" title="一級公民"><h5 class="infobox-title">一級公民</h5><p>在程式語言中，若說某物/某概念是<em>一級公民</em>(<em>first-class citizen</em>)<span id="ix-1-15"></span>或「一級的」，&shy;通常指它和其他事物被同等對待：&shy;如果其他事物可被當作參數、可被當作傳回值、可被覆寫...那麼它也可以。&shy;這是一個沒有嚴格形式定義的說法，由 Christopher Strachey 在 1960 年代提出，&shy;可用在型別、值、物件、模組... 等等之上。</p><p>例如：OCaml 是個有「一級模組」的語言，因為 OCaml 模組也可當作參數，可定義從模組到模組的函數（OCaml 中稱之為 functor）。&shy;在 C 語言之中函數是次級的，因為函數不能當參數傳（能傳的是函數的指標，而非函數本身）。&shy;Strachey指出，在 Algol 中實數是一級的，而程序是次級的。</p></div><p><b>Currying</b> &emsp; 回顧<code class="haskell">smaller</code>的定義：</p><pre><code>smaller :: Int -&gt; Int -&gt; Int
smaller x y = if x &lt;= y then x else y 
</code></pre><p><a href="Basics.html#sec:function-defns">1.2 </a> 節中說「<code class="haskell">smaller</code> 是一個函數，拿兩個參數 <code class="haskell">x</code> 與 <code class="haskell">y</code>」。&shy;但這僅是口語上方便的說法。&shy;事實上，在 Haskell 中（如同在 $\lambda$-calculus 中），所有函數都只有一個參數。&shy;函數 <code class="haskell">smaller</code> 其實是一個\emph{傳回函數的函數}：</p><ul><li><p><code class="haskell">smaller</code> 的型別 <code class="haskell">Int -&gt; Int -&gt; Int</code> 其實應看成 <code class="haskell">Int -&gt; (Int -&gt; Int)</code>：&shy;這個函數拿到一個 <code class="haskell">Int</code> 後，會傳回一個型別為 <code class="haskell">Int -&gt; Int</code> 的函數。</p></li><li><p><code class="haskell">smaller 3</code> 的型別是 <code class="haskell">Int -&gt; Int</code>。這個函數還可拿一個 <code class="haskell">Int</code> 參數，將之和 <code class="haskell">3</code> 比大小，傳回較小的那個。</p></li><li><p><code class="haskell">smaller 3 4</code> 是一個 <code class="haskell">Int</code>。它其實是將函數 <code class="haskell">smaller 3</code> 作用在 <code class="haskell">4</code> 之上。也就是說，<code class="haskell">smaller 3 4</code> 其實應看成 <code class="haskell">(smaller 3) 4</code>. 根據定義，它可展開為 <code class="haskell">if 3 &lt;= 4 then 3 else 4</code>，然後化簡為 <code class="haskell">3</code>.</p></li></ul><div class="exlist"><div class="exercise exer" id="ex:smaller-inpt"><h5 class="exercise-title">練習 1.4 </h5><p>將 <code class="haskell">smaller</code> 的定義鍵入一個檔案，載入 Haskell 直譯器中。</p><ol><li><p><code class="haskell">smaller 3 4</code> 的型別是什麼？在 GHCi 中可用 {\tt :t e} 指令得到算式 <code class="haskell">e</code> 的型別。</p></li><li><p><code class="haskell">smaller 3</code> 的型別是什麼？</p></li><li><p>在檔案中定義 <code class="haskell">st3 = smaller 3</code>. 函數 <code class="haskell">st3</code> 的型別是什麼？</p></li><li><p>給 <code class="haskell">st3</code> 一些參數，觀察其行為。</p></li></ol></div></div><p>「用『傳回函數的函數』模擬『接收多個參數的函數』」這種做法稱作 <em>currying</em>.&shy;<span id="ix-1-16"></span><input class="toggle" id="footnote-1-3-7" type="checkbox"/><label class="fnote-toggle" for="footnote-1-3-7">(註7) </label><span class="collapsible-footnote">Currying 為動名詞，形容詞則為 <em>curried</em>。&shy;此詞來自於邏輯學家 Haskell B. Curry 的姓氏。&shy;詳見第 <a href="Basics.html#sec:refs-basics">1.11 </a> 節。</span>&shy;Haskell 鼓勵大家使用 currying --- 它的內建函數大多依此配合設計，&shy;語法設計上也很給 currying 方便。&shy;當型別中出現連續的 <code class="haskell">(-&gt;)</code> 時，預設為往右邊結合，例如&shy;<code class="haskell">Int -&gt; Int -&gt; Int</code> 應看成 <code class="haskell">Int -&gt; (Int -&gt; Int)</code>.&shy;這使得「傳回函數的函數」容易寫。&shy;而在值的層次，連續的函數應用往左結合。&shy;例如，<code class="haskell">(smaller 3) 4</code> 可寫成 <code class="haskell">smaller 3 4</code>。&shy;這讓我們能很方便地將參數一個個餵給 curried 函數。</p><p>另一方面，如果我們想使用 <code class="haskell">double</code> 兩次，計算 <code class="haskell">x</code> 的四倍，應寫成 <code class="haskell">double (double x)</code>.&shy;若寫 <code class="haskell">double double x</code> ，會被視為 <code class="haskell">(double double) x</code> --- <code class="haskell">double</code> 作用在自身之上，而這顯然是個型別錯誤。</p>%format poly1
%format poly2<br/>
<p>我們再看一個使用 currying 的練習：</p><div class="theorem" id="eg:polynomial"><h5 class="theorem-title">例 1.4  </h5><p>給定 <code class="haskell">a</code>, <code class="haskell">b</code>, <code class="haskell">c</code>, <code class="haskell">x</code>, 下述函數 <code class="haskell">poly</code> 計算 $ax^2 + bx + c$:</p><pre><code class="spec">poly :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int
poly a b c x = a * x * x + b * x + c 
</code></pre><p>請定義一個函數 <code class="haskell">poly1</code>, 使得 $poly_1~x = x^2 + 2x + 1$.&shy;函數 <code class="haskell">poly1</code> 需使用 <code class="haskell">poly</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-4" type="checkbox"/><label class="lbl-toggle" for="ans-1-4">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>一種作法是：</p><pre><code class="spec">poly1 :: Int -&gt; Int
poly1 x = poly 1 2 1 x 
</code></pre><p>但這相當於 <code class="haskell">poly1 x = (poly 1 2 1) x</code> ---&shy;<code class="haskell">poly</code> 拿到 <code class="haskell">x</code> 後，立刻把 <code class="haskell">x</code> 傳給 <code class="haskell">poly 1 2 1</code> 這個函數。&shy;因此 <code class="haskell">poly1</code> 可更精簡地寫成：</p><pre><code class="spec">poly1 :: Int -&gt; Int
poly1 = poly 1 2 1 
</code></pre><p>兩種寫法都有人使用。&shy;有提及<code class="haskell">x</code>的寫法著重於描述拿到參數<code class="haskell">x</code>之後要對它進行什麼操作。&shy;而省略<code class="haskell">x</code>的寫法則是在函數的層次上思考：&shy;我們要定義一個函數，稱作<code class="haskell">poly1</code>。這個函數是什麼呢？&shy;<em>就是 <code class="haskell">poly</code> 拿到 <code class="haskell">1</code>, <code class="haskell">2</code>, <code class="haskell">1</code> 之後傳回的那個函數。</em></p><p>如果我們想用 <code class="haskell">poly</code> 定義出另一個函數&shy;$poly_2~a~b~c = a\times 2^2 + b \times 2 + 2$ 呢？&shy;最好理解的可能是不怎麼意外的寫法：</p><pre><code class="spec">poly :: Int -&gt; Int -&gt; Int -&gt; Int
poly2 a b c = poly a b c 2 
</code></pre><p>我們可以用一些技巧使 <code class="haskell">a</code>, <code class="haskell">b</code>, 和<code class="haskell">c</code>不出現在定義中，&shy;但如此得到的程式並不會更好懂。</p></div></div><p><b>二元運算子</b> &emsp;&shy;在進入其他主題前，我們交代一些語法細節。&shy;Haskell 鼓勵 currying 的使用，也把二元運算子都設計成 curried 的。&shy;例如加法的型別是 <code class="haskell">Int -&gt; Int -&gt; Int</code>.&shy;Haskell 也配套設計了種種關於二元運算子的特殊語法，希望讓它們更好用。&shy;但這些語法規則的存在都僅是為了方便我們寫出（主觀上）語法漂亮的程式，&shy;而不是非有不可、非學不可的規定。</p><p id="par:binary-operator-sectioning">&shy;假設某二元運算子 <code class="haskell">oplus</code> 的型別是 <code class="haskell">a -&gt; b -&gt; c</code>,&shy;<code class="haskell">(x ⊕)</code> 是給定了 <code class="haskell">oplus</code> 的第一個參數後得到的函數；&shy;<code class="haskell">(⊕ y)</code> 則是給定了 <code class="haskell">oplus</code> 的第二個參數後得到的函數：%&shy;<input class="toggle" id="footnote-1-3-8" type="checkbox"/><label class="fnote-toggle" for="footnote-1-3-8">(註8) </label><span class="collapsible-footnote">根據<a href="Biblio.html#Hudak:07:Being">Hudak et al. [2007]</a>，此種「<em>切片</em>」(<em>sectioning</em>)語法最早見於 David Wile 的博士論文。&shy;後來被包括 Richard Bird 在內的 IFIP WG 2.1 成員使用，並由 David A. Turner 實作在他的語言 Miranda 中。</span></p><pre><code class="spec">(x ⊕) y  = x ⊕ y  <comment>{-"\quad"-}</comment>  <comment>{- <code class="haskell">(x ⊕)</code> 的型別為 <code class="haskell">b -&gt; c</code>; -}</comment>
(⊕ y) x  = x ⊕ y               <comment>{- <code class="haskell">(⊕ y)</code> 的型別為 <code class="haskell">a -&gt; c</code>.-}</comment>
</code></pre><p>例如：</p><ul><li><p><code class="haskell">(2 *)</code> 和 <code class="haskell">(* 2)</code> 都是把一個數字乘以二的函數；</p></li><li><p><code class="haskell">(/ 2)</code> 則把輸入數字除以二；</p></li><li><p><code class="haskell">(1 /)</code> 計算輸入數字的倒數。</p></li></ul><p>名字以英文字母開頭的函數預設為前序的。例如，&shy;計算餘數的函數 <code class="haskell">mod</code> 使用時得寫成 <code class="haskell">mod 6 4</code>。&shy;若把它放在「倒引號(backquote)」中，表示將其轉為中序 ---&shy;如果我們比較喜歡把 <code class="haskell">mod</code> 放到中間，可以寫成 <code class="haskell">6 `mod` 4</code>.&shy;首字元非英文字母的函數（如 <code class="haskell">(+)</code>, <code class="haskell">(/)</code> 等）則會被預設為中序的二元運算子。&shy;若把一個中序二元運算子放在括號中，表示將其轉為前序運算子。&shy;例如，<code class="haskell">(+) 1 2</code> 和 <code class="haskell">1 + 2</code> 的意思相同。</p><p>在 Haskell 的設計中，函數應用的優先順序比中序運算子高。&shy;因此 <code class="haskell">double 3 + 4</code> 會被視作 <code class="haskell">(double 3) + 4</code>, 而不是 <code class="haskell">double (3+4)</code>.&shy;將中序運算子放在括號中也有「讓它不再是個中序運算子，只是個一般識別字」的意思。&shy;例如算式 <code class="haskell">f + x</code> 中，<code class="haskell">f</code> 和 <code class="haskell">x</code> 是中序運算子 <code class="haskell">(+)</code> 的參數。&shy;但在 <code class="haskell">f (+) x</code> 中，<code class="haskell">(+)</code> 和 <code class="haskell">x</code> 都是 <code class="haskell">f</code> 的參數&shy;（這個式子可以讀解為 <code class="haskell">(f (+)) x</code>）。</p><p><b>以函數為參數</b> &emsp; 下述函數 <code class="haskell">square</code> 計算輸入的平方：</p><pre><code class="haskell">square :: Int -&gt; Int
square x = x * x 
</code></pre><p>我們可另定義一個函數 <code class="haskell">quad :: Int -&gt; Int</code>，把 <code class="haskell">square</code> 用兩次，&shy;使得 <code class="haskell">quad x</code> 算出 $x^4$.</p><pre><code class="haskell">quad :: Int -&gt; Int
quad x = square (square x)   
</code></pre><p>但，「把某函數用兩次」是個常見的編程模式。&shy;我們能不能把 <code class="haskell">quad</code> 與 <code class="haskell">square</code> 抽象掉，單獨談「用兩次」這件事呢？&shy;下面的函數 <code class="haskell">twice</code> 把參數 <code class="haskell">f</code> 在 <code class="haskell">x</code> 之上用兩次：</p><pre><code class="haskell">twice      :: (a -&gt; a) -&gt; (a -&gt; a)
twice f x  = f (f x) 
</code></pre><p>有了 <code class="haskell">twice</code>, 我們可以這麼定義 <code class="haskell">quad</code>:</p><pre><code class="spec">quad :: Int -&gt; Int
quad = twice square 
</code></pre><p>函數 <code class="haskell">twice</code> 是本書中第一個「以函數為參數」的函數。&shy;我們可看到「讓函數可作為參數」對於抽象化是有益的：&shy;我們可以把「做兩次」這件事單獨拿出來說，把「做什麼」抽象掉。</p><p>「函數可以當作參數」意味著我們可以定義<em>作用在函數上的運算子</em>。&shy;<code class="haskell">twice</code> 就是這麼一個運算子：&shy;它拿一個函數 <code class="haskell">f</code>，把它加工一下，做出另一個函數（後者的定義是把 <code class="haskell">f</code> 用兩次）。</p><p><b>參數式多型</b> &emsp;&shy;函數 <code class="haskell">twice</code> 也是本書中第一個<em>多型</em>函數。&shy;在 Haskell 的型別中，小寫開頭的識別字（如其中的 <code class="haskell">a</code>）是型別層次的參數。&shy;讀者可想像成在 <code class="haskell">twice</code> 的型別最外層有一個省略掉的 <code class="haskell">forall a</code>.&shy;也就是說, <code class="haskell">twice</code> 的完整型別是 <code class="haskell">forall a . (a -&gt; a) -&gt; (a -&gt; a)</code> ---&shy;對所有的型別 <code class="haskell">a</code>, <code class="haskell">twice</code> 都可拿一個型別為 <code class="haskell">a -&gt; a</code> 的函數，&shy;然後傳回一個型別為 <code class="haskell">a -&gt; a</code> 的函數。</p><p>在 <code class="haskell">twice</code> 的型別 <code class="haskell">(a -&gt; a) -&gt; (a -&gt; a)</code> 中，</p><ul><li><p>第一個 <code class="haskell">a -&gt; a</code> 是參數 <code class="haskell">f</code> 的型別，</p></li><li><p>在第二個 <code class="haskell">a -&gt; a</code> 中，第一個 <code class="haskell">a</code> 是 參數 <code class="haskell">x</code> 的型別，</p></li><li><p>第二個 <code class="haskell">a</code> 則是整個計算結果的型別。</p></li></ul><p>參數 <code class="haskell">f</code> 的型別必須是 <code class="haskell">a -&gt; a</code>: 輸出入型別必須一樣，因為 <code class="haskell">f</code> 的結果必須可當作 <code class="haskell">f</code> 自己的輸入。</p><p>在 <code class="haskell">twice</code> 被使用時，型別參數 <code class="haskell">a</code> 會依照上下文被<em>特化</em>(<em>instantiate</em>)成別的型別。&shy;例如 <code class="haskell">twice square</code> 中， 因為 <code class="haskell">square</code> 的型別是 <code class="haskell">Int -&gt; Int</code>,&shy;<em>這一個</em> <code class="haskell">twice</code> 的型別變成了 <code class="haskell">(Int -&gt; Int) -&gt; (Int -&gt; Int)</code> --- <code class="haskell">a</code> 被特化成 <code class="haskell">Int</code>.&shy;若某函數 <code class="haskell">k</code> 的型別是 <code class="haskell">Float -&gt; Float</code>, 在 <code class="haskell">twice k</code> 中，<code class="haskell">twice</code> 的型別是 <code class="haskell">(Float -&gt; Float) -&gt; (Float -&gt; Float)</code>。&shy;同一個函數 <code class="haskell">twice</code> 可能依其上下文而有許多不同的型別，但都是 <code class="haskell">(a -&gt; a) -&gt; (a -&gt; a)</code> 的特例。&shy;「一段程式可能有許多不同型別」的現象稱作<em>多型</em>(<em>polymorphism</em>)<span id="ix-1-17"></span>。&shy;多型又有許多種類，此處為其中一種。詳情見... \todo{}</p><div class="exlist"><div class="exercise exer" id="ex:twice-type"><h5 class="exercise-title">練習 1.5 </h5><p>為何 <code class="haskell">twice</code> 的型別不可以是 <code class="haskell">(a -&gt; b) -&gt; (a -&gt; b)</code>?</p></div></div><div class="theorem" id="eg:forktimes"><h5 class="theorem-title">例 1.5  </h5><pre><code class="haskell">forktimes f g x = f x * g x 
</code></pre><p>算式 <code class="haskell">forktimes f g x</code> 把 <code class="haskell">f x</code> 和 <code class="haskell">g x</code> 的結果乘起來。</p><ol><li><p>請想想 <code class="haskell">forktimes</code> 的型別該是什麼？</p></li><li><p>試定義函數 <code class="haskell">compute :: Int -&gt; Int</code>, 使用 <code class="haskell">forktimes</code> 計算 $x^2 + 3\times x  + 2$。 <strong>提示</strong>：$x^2 + 3\times x  + 2 = (x+1) \times (x+2)$.</p></li></ol></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-5" type="checkbox"/><label class="lbl-toggle" for="ans-1-5">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>如同 <code class="haskell">twice</code>, <code class="haskell">forktimes</code> 可以有很多型別，但都應該是&shy;<code class="haskell">(a -&gt; Int) -&gt; (a -&gt; Int) -&gt; a -&gt; Int</code> 的特例：&shy;在 <code class="haskell">forktimes f g x</code> 中， <code class="haskell">f</code> 和 <code class="haskell">g</code> 的型別可以是 <code class="haskell">a -&gt; Int</code>,&shy;其中 <code class="haskell">a</code> 可以是任何型別 <code class="haskell">a</code>，而 <code class="haskell">x</code> 的型別必須也是同一個 <code class="haskell">a</code>.&shy;函數 <code class="haskell">compute</code> 可定義如下：</p><pre><code class="haskell">compute :: Int -&gt; Int
compute = forktimes (+1) (+2) 
</code></pre><p>其中 <code class="haskell">forktimes</code> 型別中的 <code class="haskell">a</code> 被特化為 <code class="haskell">Int</code>.</p></div></div>%format lift2<br/>
<p>如前所述，<code class="haskell">forktimes f g x</code> 把 <code class="haskell">f x</code> 和 <code class="haskell">g x</code> 的結果乘起來。&shy;但，一定得是乘法嗎？我們當然可以再多做一點點抽象化。</p><div class="theorem" id="eg:lift2"><h5 class="theorem-title">例 1.6  </h5><p>考慮函數 <code class="haskell">lift2 h f g x = h (f x) (g x)</code>.</p><ol><li><p><code class="haskell">lift2</code> 的型別是什麼？</p></li><li><p>用 <code class="haskell">lift2</code> 定義 <code class="haskell">forktimes</code>.</p></li><li><p>用 <code class="haskell">lift2</code> 計算 $x^2 + 3\times x  + 2$.</p></li></ol></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-5" type="checkbox"/><label class="lbl-toggle" for="ans-1-5">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>我們把 <code class="haskell">lift2</code> 最泛用的型別和其定義重複如下：</p><pre><code class="haskell">lift2 :: (a -&gt; b -&gt; c) -&gt; (d -&gt; a) -&gt; (d -&gt; b) -&gt; d -&gt; c 
lift2 h f g x = h (f x) (g x) 
</code></pre><p>有了 <code class="haskell">lift2</code>, <code class="haskell">forktimes</code> 可定義為：</p><pre><code class="spec">forktimes :: (a -&gt; Int) -&gt; (a -&gt; Int) -&gt; a -&gt; Int
forktimes = lift2 (*) 
</code></pre><p>請讀者觀察：<code class="haskell">lift</code> 型別中的 <code class="haskell">a</code>, <code class="haskell">b</code>, <code class="haskell">c</code> 都特化成 <code class="haskell">Int</code>,&shy;<code class="haskell">d</code> 則改名為 <code class="haskell">a</code>.</p><p>我們也可用 <code class="haskell">lift2</code> 定義 <code class="haskell">compute</code>:</p><pre><code class="spec">compute :: Int -&gt; Int
compute = lift2 (*) (+1) (+2) 
</code></pre><p>函數 <code class="haskell">lift2</code> 可以看作一個作用在二元運算子上的運算子，功用是把&shy;二元運算子「提升」到函數層次。&shy;例如，原本 <code class="haskell">(*)</code> 只能拿兩個 <code class="haskell">Int</code> 當作參數，&shy;（例：<code class="haskell">1 * 2</code> 是「把 <code class="haskell">1</code> 和 <code class="haskell">2</code> 乘起來」），&shy;但現在 <code class="haskell">lift2 (*)</code> 可將函數 <code class="haskell">(+1)</code> 和 <code class="haskell">(+2)</code> 當參數了，&shy;意思為「把 <code class="haskell">(+1)</code> 和 <code class="haskell">(+2)</code> 的結果乘起來」。</p></div></div><h2 class="section" id="sec:func-comp">1.4 函數合成</h2><p>拿到一個函數 <code class="haskell">f</code>，我們能做的基本操作包括把 <code class="haskell">f</code> 作用在某個參數上、&shy;把 <code class="haskell">f</code> 傳給別的函數...&shy;此外，另一個常用的基本操作是將 <code class="haskell">f</code> 和別的函數<em>合成</em>(<em>compose</em>)&shy;<span id="ix-1-18"></span><span id="ix-1-19"></span>&shy;為一個新函數。&shy;<input class="toggle" id="footnote-1-4-9" type="checkbox"/><label class="fnote-toggle" for="footnote-1-4-9">(註9) </label><span class="collapsible-footnote">Robert Gl\"{u}ck 認為函數上應有三個基本操作：&shy;函數應用、函數合成、以及求一個函數的反函數。&shy;前兩者已經提到，第三者則是大部分語言欠缺的。</span>&shy;「合成」運算子在 Haskell 中寫成<code class="haskell">(.)</code>.&shy;這個運算子的形式定義如下（我們先看定義本體，待會兒再看型別）：</p><pre><code class="spec">(f . g) x  = f (g x) 
</code></pre><p>若用口語說，<code class="haskell">f . g</code> 是將 <code class="haskell">f</code> 和 <code class="haskell">g</code>兩個函數「串起來」得到的新函數：&shy;輸入 <code class="haskell">x</code> 先丟給 <code class="haskell">g</code>, 後者算出的結果再傳給 <code class="haskell">f</code>.</p><div class="theorem" id="eg:square-double"><h5 class="theorem-title">例 1.7  </h5><p><code class="haskell">square . double</code> 與 <code class="haskell">double . square</code> 都是由 <code class="haskell">Int</code> 到 <code class="haskell">Int</code> 的函數.&shy;直覺上，前者把輸入先給 <code class="haskell">double</code>, 其結果再給 <code class="haskell">square</code>。&shy;後者則反過來。&shy;如何了解它們的行為？既然它們是函數，我們便餵給它們一個參數，看看會展開成什麼！&shy;兩者分別展開如下：</p><div class="multicols"><div class="mcol" width="0.4\textwidth"><pre><code class="spec">   (square . double) x
=    <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
   square (double x)
=  (x + x) * (x + x) 
</code></pre></div><div class="mcol" width="0.4\textwidth"><pre><code class="spec">   (double . square) x
=    <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
   double (square x)
=  (x * x) + (x * x) 
</code></pre></div></div><p>所以，如果輸入為 <code class="haskell">x</code>, <code class="haskell">(square . double) x</code> 計算 $(2x)^2$;&shy;<code class="haskell">(double . square) x</code> 則是 $2x^2$.</p></div><p>但，並不是所有函數都可以串在一起：&shy;<code class="haskell">f . g</code> 之中，<code class="haskell">g</code> 的輸出型別和 <code class="haskell">f</code> 的輸入型別必須一致才行。&shy;運算子 <code class="haskell">(.)</code> 包括型別的完整定義為：</p><pre><code class="spec">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(f . g) x  = f (g x) 
</code></pre><p>如果 <code class="haskell">g</code> 的型別是 <code class="haskell">a -&gt; b</code>, <code class="haskell">f</code> 的型別是 <code class="haskell">b -&gt; c</code>, 將他們串接起來後，&shy;便得到一個型別為 <code class="haskell">a -&gt; c</code> 的函數。</p><p>有了<code class="haskell">(.)</code>, 函數 <code class="haskell">twice</code> 可以定義如下：</p><pre><code class="spec">twice    :: (a -&gt; a) -&gt; (a -&gt; a)
twice f  = f . f  
</code></pre><p>確實，根據 <code class="haskell">(.)</code> 的定義，<code class="haskell">twice f x = (f . f) x = f (f x)</code>，和 <code class="haskell">twice</code> 原來的定義相同。</p><p>為了討論函數合成的性質，我們先介紹一個函數 <code class="haskell">id</code>:</p><pre><code>id :: a -&gt; a
id x = x 
</code></pre><p>它又稱作<em>單位函數</em>或<em>恆等函數</em>。<span id="ix-1-20"></span>&shy;這是一個似乎沒有在做什麼的函數：給任何輸入，<code class="haskell">id</code> 都原封不動地把它送到輸出 ---&shy;這也反映在他的型別 <code class="haskell">a -&gt; a</code> 上。&shy;這個函數有什麼重要性呢？&shy;原來，<code class="haskell">(.)</code> 滿足結合律，並且以 <code class="haskell">id</code> 為單位元素（這也是「單位函數」這名字的由來）：</p><p>用數學術語來說的話，<code class="haskell">id</code> 與 <code class="haskell">(.)</code> 形成一個<em>幺半群</em> (<em>monoid</em>)。&shy;<span id="ix-1-21"></span>&shy;函數 <code class="haskell">id</code> 的重要性就如同 <code class="haskell">0</code> 在代數中的重要性（<code class="haskell">0</code> 與 <code class="haskell">(+)</code> 也是一個幺半群）。我們在許多計算、證明中都會見到它。</p><p>以下我們試著證明 <code class="haskell">(.)</code> 的結合律。我們想論證&shy;<code class="haskell">(f . g) . h = f . (g . h)</code>，但該如何下手？&shy;該等式的等號左右兩邊都是函數。&shy;當我們說兩個整數相等，意思很清楚：如果等號左邊是 <code class="haskell">0</code>, 右邊也是 <code class="haskell">0</code>;&shy;如果左邊是 <code class="haskell">1</code>, 右邊也是 <code class="haskell">1</code>... 但說兩個函數「相等」，是什麼意思呢？</p><div class="theorem" id="def:extensional-eq" title="外延相等(extensional equality)"><h5 class="theorem-title">定義 1.8  外延相等(extensional equality) </h5><p>給定兩個型別相同的函數 <code class="haskell">f</code> 和 <code class="haskell">g</code>, 當我們說它們<em>外延相等</em>(<em>extensionally equal</em>)<span id="ix-1-22"></span>，&shy;意思是給任何一個輸入，<code class="haskell">f</code> 和 <code class="haskell">g</code> 都算出相等的輸出。也就是：&shy;<code class="haskell">(forall x. f x = g x)</code>.</p><p>本書中，當我們寫兩個函數相等(<code class="haskell">f = g</code>)時，指的便是外延相等，除非例外註明。</p></div><p>在外延相等的假設下，證明 <code class="haskell">(f . g) . h = f . (g . h)</code> 也就是證明對任何一個 <code class="haskell">x</code>, <code class="haskell">((f . g) . h) x = (f . (g . h)) x</code> 均成立. 我們推論如下：</p><pre><code class="spec">  ((f . g) . h) x
=  <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
  (f . g) (h x)
=  <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
  f (g (h x))
=  <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
  f ((g . h) x) 
=  <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
  (f . (g . h)) x 
</code></pre><p>既然 <code class="haskell">(f . g) . h = f . (g . h)</code>，我們便可統一寫成 <code class="haskell">f . g . h</code>, 不用加括號了。</p><div class="exlist"><div class="exercise exer" id="ex:identity-law"><h5 class="exercise-title">練習 1.6 </h5><p>證明 <code class="haskell">id . f = f = f . id</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-6" type="checkbox"/><label class="lbl-toggle" for="ans-1-6">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>根據外延相等，我們需證明 <code class="haskell">(forall x . id . f = f = f . id)</code>.&shy;推論如下：</p><pre><code class="spec">   (id . f) x
=    <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
   id (f x)
=    <comment>{- <code class="haskell">id</code> 之定義 -}</comment>
   f x
=    <comment>{- <code class="haskell">id</code> 之定義 -}</comment>
   f (id x)
=    <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
   (f . id) x 
</code></pre></div></div></div><p>合成 <code class="haskell">(.)</code> 也是一個中序運算子。和其他中序運算子一樣，其優先性低於函數應用。&shy;因此，當我們寫 <code class="haskell">f . g x</code>, 指的是 <code class="haskell">f . (g x)</code> --- <code class="haskell">g x</code> 為一個函數，&shy;和 <code class="haskell">f</code> 合成，而不是 <code class="haskell">(f . g) x</code> （後者根據 <code class="haskell">(.)</code> 的定義，是 <code class="haskell">f (g x)</code>）。</p><div class="theorem" id="eg:smaller-square-legal"><h5 class="theorem-title">例 1.9  </h5><p>下列程式中，有些是合法的 Haskell 式子、有些則有型別錯誤。&shy;對每個程式，如果它是合法的，請找出它的型別，並說說看該程式做什麼。&shy;如果有型別錯誤，請簡述為什麼。</p><ol><li><p><code class="haskell">square . smaller 3</code>;</p></li><li><p><code class="haskell">smaller 3 . square</code>;</p></li><li><p><code class="haskell">smaller (square 3)</code>;</p></li><li><p><code class="haskell">smaller . square 3</code>.</p></li></ol></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-6" type="checkbox"/><label class="lbl-toggle" for="ans-1-6">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>前三者都是 <code class="haskell">Int -&gt; Int</code>。</p><ol><li><p>根據 <code class="haskell">(.)</code> 的定義，<code class="haskell">(square . smaller 3) x = square (smaller 3 x)</code>.&shy;因此 <code class="haskell">square . smaller 3</code> 是一個函數，將其輸入和 <code class="haskell">3</code> 比較，取較小者的平方。</p></li><li><p><code class="haskell">(smaller 3 . square) x = smaller 3 (square x)</code>. 因此它讀入 <code class="haskell">x</code>, 並在 <code class="haskell">3</code> 或 <code class="haskell">x^2</code> 之中選較小的那個。</p></li><li><p><code class="haskell">smaller (square 3)</code> 是一個函數，讀入 <code class="haskell">x</code> 之後，選擇 <code class="haskell">x</code> 與 <code class="haskell">3^2</code> 之中較小的那個。</p></li><li><p><code class="haskell">smaller . square 3</code> 有型別錯誤： <code class="haskell">square 3</code> 不是一個函數（而是一個整數），&shy;無法和 <code class="haskell">smaller</code> 合成。</p></li></ol></div></div><p id="para:fun-apply"><b>函數應用運算子</b> &emsp;&shy;本書中有些時候會將許多函數組合成一串，例如 <code class="haskell">square . double . (+1) . smaller 3</code>&shy;。由於函數應用的優先順序比一般二元運算元高，把上述式子應用在參數 <code class="haskell">5</code> 之上時得寫成</p><pre><code class="spec">  (square . double . (+1) . smaller 7) 5 
</code></pre><p>（這個式子的值為 $(2\times(5+1))^2$。）&shy;每次都得加一對括號似乎有些累贅。Haskell 另有一個運算子<code class="haskell">($)</code>, 唸作 ``apply'', 代表函數應用：&shy;<span id="ix-1-23"></span></p><pre><code class="spec">($) :: (a -&gt; b) -&gt; a -&gt; b
f $ x = f x 
</code></pre><p><code class="haskell">f $ x</code> 和 <code class="haskell">f x</code> 意思一樣。那麼我們為何需要這個運算子呢？原因之一是&shy;<code class="haskell">($)</code> 的優先度比 <code class="haskell">(.)</code> 低，因此上式可省去括號改寫如下：</p><pre><code class="spec">  square . double . (+1) . smaller 7 $ 5 
</code></pre><p>運算子 <code class="haskell">($)</code> 的另一個重要意義是：「函數應用」這個動作有了符號，&shy;成為可以獨立討論的事物。例如，<code class="haskell">($)</code> 可以當作參數。&shy;一個這麼做的例子是習題 <a href="Basics.html#ex:uncurry-apply">1.11 </a>。</p><p id="para:const"><b>常量函數</b> &emsp;&shy;既然介紹了 <code class="haskell">id</code>, 本節也順便介紹一個以後將使用到的基本組件。&shy;給定 <code class="haskell">x</code> 之後，函數 <code class="haskell">const x</code> 是一個 <em>不論拿到什麼函數，都傳回 <code class="haskell">x</code></em>的函數。&shy;函數 <code class="haskell">const</code> 的定義如下：</p><pre><code class="spec">const :: a -&gt; b -&gt; a
const x y = x 
</code></pre><p>第<a href="Basics.html#sec:evaluation">1.1 </a>節開頭的範例 <code class="haskell">three</code> 可定義為 <code class="haskell">three = const 3</code>.</p><p>「無論如何都傳回 <code class="haskell">x</code>」聽來好像是個沒用的函數，&shy;但和 <code class="haskell">id</code> 一樣，我們日後會看到它在演算、證明中時常用上。&shy;事實上，<em>組件邏輯</em>理論告訴我們：所有函數都可以由 <code class="haskell">id</code>, <code class="haskell">const</code>, 和下述的 <code class="haskell">subst</code> 三個函數組合出來。</p><pre><code class="spec">subst :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
subst f g x = f x (g x) 
</code></pre><h2 class="section" id="sec:lambda-terms">1.5 $\lambda$ 算式</h2><p>雖說函數是一級市民，在本書之中，目前為止，仍有一項功能是其他型別擁有、函數卻還沒有的：寫出一個<em>未命名</em>的值的能力。&shy;整數、真假值都能不經命名、直接寫在算式中，例如，&shy;我們可寫 <code class="haskell">smaller (square 3) 4</code>, 而不需要先定義好</p>%format num1
%format num2
%format e1
%format e2<br/>
<pre><code class="spec">num1, num2 :: Int
num1  = 3
num2  = 4 
</code></pre><p>才能說 <code class="haskell">smaller (square num1) num2</code>. 但使用函數時，似乎非得&shy;先給個名字，才能使用它：</p><pre><code class="spec">square :: Int -&gt; Int
square x = ... 
quad = twice square 
</code></pre><p>如果為了某些原因（例如，如果在我們的程式中 <code class="haskell">square</code> 只會被用到一次），我們不想給 <code class="haskell">square</code> 一個名字，我們能不能直接把它寫出來呢？</p><p>$\lambda$ 算式便是允許我們這麼做的語法。&shy;以直觀的方式解釋，<code class="haskell">\x -&gt; e</code> 便是一個函數，其中 <code class="haskell">x</code> 是參數，&shy;<code class="haskell">e</code> 是函數本體。&shy;例如，<code class="haskell">(\x -&gt; x * x)</code> 是一個函數，計算其輸入(<code class="haskell">x</code>)的平方。&shy;如果我們不想給 <code class="haskell">square</code> 一個名字, 我們可將 <code class="haskell">quad</code> 定義為：</p><pre><code class="spec">quad = twice (\x -&gt; x * x) 
</code></pre><p>寫成 $\lambda$ 算式的函數也可直接作用在參數上，例如 <code class="haskell">(\x -&gt; e1) e2</code>。&shy;這個式子歸約的結果通常表示為<code class="haskell">e1[e2/x]</code>,&shy;意思是「將 <code class="haskell">e1</code> 之中的 <code class="haskell">x</code> 代換為 <code class="haskell">e2</code>」。&shy;例如，算式 <code class="haskell">(\x -&gt; x * x) (3+4)</code> 可歸約為 <code class="haskell">(3+4) * (3+4)</code>.</p><div class="theorem" id="lambda-examples"><h5 class="theorem-title">例 1.10  </h5><p>以下是一些 $\lambda$ 算式的例子：</p><ul><li><p>函數 <code class="haskell">(\x -&gt; 1 + x)</code> 把輸入遞增 --- 和 <code class="haskell">(1+)</code> 相同。&shy;其實，把 <code class="haskell">(1+)</code> 的語法糖去掉後，得到的就是這個 $\lambda$ 算式。</p></li><li><p><code class="haskell">(\x -&gt; \y -&gt; x + 2 * x * y)</code> 是一個傳回 $\lambda$ 算式的函數。</p><ul><li><p><code class="haskell">(\x -&gt; \y -&gt; x + 2 * x * y) (3+4)</code> 可歸約為&shy;<code class="haskell">(\y -&gt; (3+4) + 2 * (3+4) * y)</code>。注意 <code class="haskell">\x</code> 不見了，&shy;函數本體中的 <code class="haskell">x</code> 被代換成 <code class="haskell">3+4</code>，<code class="haskell">\y -&gt; ..</code> 則仍留著。</p></li><li><p><code class="haskell">(\x -&gt; \y -&gt; x + 2 * x * y) (3+4) 5</code> 可歸約為&shy;<code class="haskell">(3+4) + 2 * (3+4) * 5</code>.</p></li></ul></li><li><p>由於傳回函數的函數是常見的，Haskell (如同 $\lambda$-calculus)&shy;提供較短的語法。上述例子中的函數也可簡寫成：&shy;<code class="haskell">(\x y -&gt; x + 2 * x * y)</code>.</p></li><li><p>函數也可以當參數。例如，<code class="haskell">(\x -&gt; x 3 3) (+)</code> 可歸約為 <code class="haskell">(+) 3 3</code>, 或 <code class="haskell">3 + 3</code>.</p></li><li><p>以下是 <code class="haskell">(\f x -&gt; f x x) (\y -&gt; 2 * y) 3</code> 的求值過程：</p></li></ul><pre><code class="spec">   (\f x -&gt; f x x) (\y z -&gt; 2 * y + z) 3
=  (\x -&gt; (\y -&gt; 2 * y + z) x x) 3
=  (\y -&gt; 2 * y + z) 3 3
=  2 * 3 + 3
=  9 
</code></pre><ul><li><p>在 <code class="haskell">\x -&gt; e</code> 之中，<code class="haskell">x</code> 是範圍限於 <code class="haskell">e</code> 的區域識別字。&shy;因此：</p></li></ul><pre><code class="spec">   (\f x -&gt; x + f x) (\x -&gt; x + x) 3
=  (\x -&gt; x + (\x -&gt; x + x) x) 3
=  3 + (\x -&gt; x + x) 3
=  3 + 3 + 3
=  9 
</code></pre></div><p>有了 $\lambda$ 算式後，函數 <code class="haskell">smaller</code> 又有另一種寫法：</p><pre><code class="spec">smaller :: Int -&gt; Int -&gt; Int
smaller = \x y -&gt; if x &lt;= y then x else y 
</code></pre><p>事實上，$\lambda$ 算式可視為更基礎的機制 ---&shy;目前為止我們所介紹的種種語法結構都僅是 $\lambda$ 算式的語法糖，都可展開、轉譯為 $\lambda$ 算式。&shy;Haskell 的 $\lambda$ 算式源於一套稱為 <em>$\lambda$ 演算</em> (<em>$\lambda$ calculus</em>)的形式語言 --- 這是一個為了研究計算本質而發展出的理論，也是函數語言的理論核心。我們將在爾後的章節中做更詳盡的介紹。\todo{which?}</p><h2 class="section" id="sec:elementary-datatypes">1.6 簡單資料型態</h2><p>藉由一些例子，我們已經看過 Haskell 的一些數值型別：<code class="haskell">Int</code>, <code class="haskell">Float</code> 等等。&shy;在本節中我們將簡短介紹我們將用到的一些其他型別。</p><h3 class="subsection" id="sec:boolean">1.6.1 布林值</h3><p>布林值 (Boolean)<span id="ix-1-24"></span>常用於程式中表達真和假。&shy;在 Haskell 中，我們可假想有這樣的一個型別定義：</p><pre><code class="spec">data Bool = False | True 
</code></pre><p>其中，<code class="haskell">data</code> 是 Haskell 宣告新資料型別的保留字。&shy;上述定義可用口語描述成「定義一個稱作 <code class="haskell">Bool</code> 的新資料型別，&shy;有兩個可能的值，分別為 <code class="haskell">False</code> 和 <code class="haskell">True</code>.」&shy;<code class="haskell">False</code> 和 <code class="haskell">True</code> 是型別 <code class="haskell">Bool</code> 的<em>唯二</em>兩個<em>建構元</em> ---&shy;任何型別為 <code class="haskell">Bool</code> 的值，如果有正規式，必定是它們兩者之一。&shy;在 Haskell 之中，建構元必須以大寫英文字母或冒號(<code class="haskell">:</code>)開頭。</p><p><b>樣式配對</b> &emsp; <span id="ix-1-25"></span> 有了資料，我們來看看怎麼定義該型別上的函數。以布林值為輸入的函數中，&shy;最簡單又常用的可能是 <code class="haskell">not</code>:</p><pre><code class="spec">not :: Bool -&gt; Bool
not False  = True
not True   = False 
</code></pre><p>這和我們的的直覺理解一致：<code class="haskell">not False</code> 是 <code class="haskell">True</code>, <code class="haskell">not True</code> 是&shy;<code class="haskell">False</code>. 我們看到這個定義寫成兩行（正式說來是兩個「子句」），\emph{每一個子句分別對應到 <code class="haskell">Bool</code> 的一個可能的值}。&shy;以下則是邏輯上的「且」和「或」（分別寫作<code class="haskell">(⋀)</code>與<code class="haskell">(⋁)</code>）的定義：%&shy;<input class="toggle" id="footnote-1-6-10" type="checkbox"/><label class="fnote-toggle" for="footnote-1-6-10">(註10) </label><span class="collapsible-footnote">邏輯「且」又稱作合取(conjunction)<span id="ix-1-26"></span>；邏輯「或」又稱作析取(disjunction).<span id="ix-1-27"></span>&shy;在 Haskell 中，「且」與「或」需分別寫成 $(\mathtt{\&\&})$ 和 $(\mathtt{||||})$。本書中採用數學與邏輯領域較常使用的 <code class="haskell">(⋀)</code>與<code class="haskell">(⋁)</code>.</span></p><pre><code class="spec">(⋀), (||) :: Bool -&gt; Bool -&gt; Bool
False  ⋀ y  = False
True   ⋀ y  = y 

False  || y  = y
True   || y  = True 
</code></pre><p>運算子<code class="haskell">(⋀)</code>與<code class="haskell">(⋁)</code>的定義同樣是各兩個子句，每個子句分別考慮其第一個參數的值。&shy;以 <code class="haskell">x ⋀ y</code> 為例：如果 <code class="haskell">x</code> 是 <code class="haskell">False</code>, 不論 <code class="haskell">y</code> 的值為何，<code class="haskell">x ⋀ y</code> 都是 <code class="haskell">False</code>；&shy;如果 <code class="haskell">x</code> 是 <code class="haskell">True</code>, <code class="haskell">x & y</code> 的值和 <code class="haskell">y</code> 相同。<code class="haskell">(⋁)</code> 的情況類似。</p><div class="theorem" id="eg:leap-year"><h5 class="theorem-title">例 1.11  </h5><p>以下函數判斷給定年份 <code class="haskell">y</code> 是否為閏年。</p><pre><code class="haskell">leapyear :: Int -&gt; Bool
leapyear y =  (y `mod` 4 == 0) ⋀
               (y `mod` 100 /= 0 || y `mod` 400 == 0) 
</code></pre></div><p>我們來算算看 <code class="haskell">leapyear 2016</code>。依照定義展開為</p><pre><code class="spec">  (2016 `mod` 4 == 0) ⋀ (2016 `mod` 100 /= 0 || 2016 `mod` 400 == 0) 
</code></pre><p>接下來該怎麼做呢？函數 <code class="haskell">(⋀)</code> 的定義有兩個子句，我們得知道 <code class="haskell">2016 `mod` 4 == 0</code> 的值才能得知該歸約成哪個。因此只好先算 <code class="haskell">2016 `mod` 4 == 0</code>，得到 <code class="haskell">True</code>:</p><pre><code class="spec">  True ⋀ (2016 `mod` 100 /= 0 || 2016 `mod` 400 == 0) 
</code></pre><p>然後依照<code class="haskell">(⋀)</code> 的定義歸約為 <code class="haskell">2016 `mod` 100 /= 0 ⋁ 2016 `mod` 400 == 0</code>.&shy;接下來也依此類推。</p><p>我們發現這是第<a href="Basics.html#sec:evaluation">1.1 </a>節中所提及的<em>被迫求值</em>的例子：我們得先把參數算出，才知道接下來如何走。&shy;函數 <code class="haskell">not</code>, <code class="haskell">(⋀)</code>, <code class="haskell">(⋁)</code> 定義成許多個子句，每個都分析其參數的可能外觀，據此決定該怎麼走。這種定義方式稱作<em>樣式配對 (pattern matching)</em>：等號左手邊的 <code class="haskell">False</code>, <code class="haskell">True</code> 等等在此是樣式(pattern)。使用這些函數時，例如 <code class="haskell">x ⋀ y</code> 中， <code class="haskell">x</code> 得先被算到可以和這些樣式配對上的程度，才能決定接下來的計算如何進行。</p><p>樣式配對也可用在不止一個參數上。例如，以下的運算元 <code class="haskell">(==)</code> 判斷兩個布林值是否相等。</p><pre><code class="spec">(==) :: Bool -&gt; Bool -&gt; Bool
False  == False  = True
False  == True   = False
True   == False  = False
True   == True   = True 
</code></pre><p>讀者可能注意到我們用了同一個符號 <code class="haskell">(==)</code> 來表示整數與布林值的相等測試。&shy;請讀者暫且接受，相信 Haskell 有某些方式可得知任一個算式中的 <code class="haskell">(==)</code> 到底是什麼型別的相等。詳情 \todo{where?}</p><p>Haskell 中另有一個專用來做樣式配對的 <code class="haskell">case</code> 算式。例如，<code class="haskell">(⋀)</code> 也可寫成如下的形式：</p><pre><code class="spec">(⋀) :: Bool -&gt; Bool
x ⋀ y =  case x of
            False  -&gt; False
            True   -&gt; y 
</code></pre><p>由於 <code class="haskell">case</code> 是算式，如同 <code class="haskell">let</code> 一樣可出現在其他算式中，也可巢狀出現。</p><div class="exlist"><div class="exercise exer" id="ex:case-formula"><h5 class="exercise-title">練習 1.7 </h5><p>以 <code class="haskell">case</code> 算式定義 <code class="haskell">not</code>, <code class="haskell">(⋁)</code>, 和 <code class="haskell">(==)</code>.</p></div><div class="exercise exer" id="ex:equal-symbol-defn"><h5 class="exercise-title">練習 1.8 </h5><p>另一個定義 <code class="haskell">(==) :: Bool -&gt; Bool -&gt; Bool</code> 的方式是</p><pre><code class="spec">x == y = (x ⋀ y) || (not x ⋀ not y) 
</code></pre><p>請將 <code class="haskell">(x,y) := (False, False)</code>, <code class="haskell">(x,y) := (False, True)</code>&shy;等四種可能分別代入化簡，看看是否和本節之前的 <code class="haskell">(==)</code> 定義相同。</p></div></div><h3 class="subsection" id="sec:char">1.6.2 字元</h3><p>我們可把「字元」這個型別想成一個很長的 <code class="haskell">data</code> 宣告：</p><pre><code class="spec">data Char = 'a' | 'b' | ... | 'z' | 'A' | 'B' ....
</code></pre><p>其中包括所有字母、符號、空白... 目前的 Haskell 甚至有處理 Unicode 字元的能力。&shy;但無論如何，<code class="haskell">Char</code> 之中的字元數目是有限的。我們可用樣式配對定義字元上的函數。&shy;注意：字元以單引號括起來。</p><p>我們也可假設字元是有順序的，每個字元對應到一個內碼。&shy;關於 <code class="haskell">Char</code> 的常用函數中，<code class="haskell">ord</code> 將字元的內碼找出，<code class="haskell">chr</code> 則將內碼轉為字元：</p><pre><code class="spec">ord  :: Char -&gt; Int 
chr  :: Int -&gt; Char 
</code></pre><div class="theorem" id="eg:isupper"><h5 class="theorem-title">例 1.12  </h5><p>下列函數 <code class="haskell">isUpper</code> 判斷一個字元是否為大寫英文字母；<code class="haskell">toLower</code> 則將&shy;大寫字母轉成小寫字母，若輸入並非大寫字母則不予以變動。</p><pre><code class="haskell">isUpper :: Char -&gt; Bool
isUpper c = let x = ord c in ord 'A' &lt;= x ⋀ x &lt;= ord 'Z' 

toLower :: Char -&gt; Char
toLower c  | isUpper c  = chr (ord c - ord 'A' + ord 'a')
           | otherwise  = c 
</code></pre></div><h3 class="subsection" id="sec:pairs">1.6.3 序對</h3><p>數學上，將兩個值（如 <code class="haskell">3</code> 和 <code class="haskell">'a'</code>) 放在一起，就成了一個<em>有序對</em>(<em>ordered pair</em>)，可寫成<code class="haskell">(3,'a')</code>。<span id="ix-1-28"></span>&shy;之所以稱作「有序」對，因為其中兩個元素的順序是不可忽略的 --- <code class="haskell">(3,'a')</code> 與 <code class="haskell">('a',3)</code> 是不同的有序對。&shy;另一個常見譯名是「數對」。由於我們處理的不只是數字，本書將之簡稱為「序對」。</p><p>給兩個集合 <code class="haskell">A</code> 和 <code class="haskell">B</code>, 從 <code class="haskell">A</code> 之中任取一元素 <code class="haskell">x</code>，從 <code class="haskell">B</code> 之中也任取一元素 <code class="haskell">y</code>，&shy;兩者的序對 <code class="haskell">(x,y)</code> 形成的集合稱作 <code class="haskell">A</code> 和 <code class="haskell">B</code> 的<em>笛卡兒積</em>(<em>Cartesian product</em>)，寫成 <code class="haskell">A × B</code>:<span id="ix-1-29"></span></p><pre><code class="spec">   A × B = {(x,y) | x ∈ A, y ∈ B} 
</code></pre><p>Haskell 之中也有類似的構造。給定型別 <code class="haskell">a</code> 與 <code class="haskell">b</code>, 它們的序對的型別是 <code class="haskell">(a × b)</code>.&shy;<input class="toggle" id="footnote-1-6-11" type="checkbox"/><label class="fnote-toggle" for="footnote-1-6-11">(註11) </label><span class="collapsible-footnote">然而，由於「程式可能不終止」這個因素作怪，<code class="haskell">a × b</code> 的元素並不僅是 <code class="haskell">a</code> 與 <code class="haskell">b</code> （如果視做集合）的笛卡兒積。詳見 \todo{where?}</span>&shy;我們可以想像 Haskell 有這麼一個型別定義：</p><pre><code class="spec">data (a × b) = (a,b) 
</code></pre><p>以口語說的話，<code class="haskell">(a × b)</code> 是一個新型別，而具有此型別的值若有範式，必定是 <code class="haskell">(x,y)</code> 的形式，其中 <code class="haskell">x</code> 的型別是 <code class="haskell">a</code>, <code class="haskell">y</code> 的型別是 <code class="haskell">b</code>.&shy;<input class="toggle" id="footnote-1-6-12" type="checkbox"/><label class="fnote-toggle" for="footnote-1-6-12">(註12) </label><span class="collapsible-footnote">其實這個定義並不符合 Haskell 的語法，因此只是方便理解的想像。另，型別 <code class="haskell">(a × b)</code> 在 Haskell 中寫成 <code class="haskell">(a,b)</code>. 我的經驗中，讓型別與值的語法太接近，反易造成困惑。</span>&shy;序對的建構元寫成<code class="haskell">(,)</code>，型別為 <code class="haskell">a -&gt; b -&gt; (a × b)</code>.&shy;例如 <code class="haskell">(,) 4 'b' = (4,'b')</code>.</p><p>兩個常用的函數 <code class="haskell">fst</code> 與 <code class="haskell">snd</code> 分別取出序對中的第一個和第二個元素：</p><div class="multicols"><div class="mcol" width="0.4\textwidth"><pre><code class="spec">fst :: (a × b) -&gt; a
fst (x,y) = x 
</code></pre></div><div class="mcol" width="0.4\textwidth"><pre><code class="spec">snd :: (a × b) -&gt; b
snd (x,y) = y 
</code></pre></div></div><p>函數 <code class="haskell">fst</code> 與 <code class="haskell">snd</code> 的定義方式也是樣式配對：輸入值必須先計算成 <code class="haskell">(x,y)</code> 的形式。</p><div class="theorem" id="eg:pairs-examples"><h5 class="theorem-title">例 1.13  </h5><p>以下是一些序對與其相關函數的例子。</p><ul><li><p><code class="haskell">(3,'a')</code> 是一個型別為 <code class="haskell">(Int × Char)</code> 的序對。</p></li><li><p><code class="haskell">fst (3,'a') = 3</code>, <code class="haskell">snd (3,'a') = 'a'</code></p></li><li><p>函數 <code class="haskell">swap</code> 將序對中的元素調換：</p></li></ul><pre><code class="spec">swap :: (a × b) -&gt; (b × a)
swap (x,y) = (y,x) 
</code></pre><p>另一個定義方式是 <code class="haskell">swap p = (snd p, fst p)</code>.&shy;但這兩個定義並不盡然相同。詳見第<a href="Basics.html#sec:weak-head-normal-form">1.7 </a>節。</p></div><p>序對也可以巢狀構成。例如 <code class="haskell">((True,3), 'c')</code> 是一個型別為 <code class="haskell">((Bool × Int) × Char)</code> 的序對，而 <code class="haskell">snd (fst ((True,3), 'c')) = 3</code>. 在 Haskell 之中，<code class="haskell">((a × b) × c)</code> 與 <code class="haskell">(a × (b × c))</code> 被視為不同的型別，但他們是<em>同構</em>的 --- 我們可定義一對函數在這兩個型別之間作轉換：</p><pre><code class="haskell">assocr :: ((a × b) × c) -&gt; (a × (b × c))
assocr ((x,y),z) = (x,(y,z)) 

assocl :: (a × (b × c)) -&gt; ((a × b) × c)
assocl (x,(y,z)) = ((x,y),z) 
</code></pre><p>並且滿足 <code class="haskell">assocr . assocl = id</code>, 和 <code class="haskell">assocl . assocr = id</code>.</p><div class="exlist"><div class="exercise exer" id="ex:assocl-assocr"><h5 class="exercise-title">練習 1.9 </h5><p>試試看不用樣式配對，而以 <code class="haskell">fst</code> 和 <code class="haskell">snd</code> 定義 <code class="haskell">assocl</code> 和 <code class="haskell">assocr</code>:</p><pre><code class="spec">assocl  p = ...
assocr  p = ...
</code></pre></div></div><div class="infobox infobox" title="同構"><h5 class="infobox-title">同構</h5><p><span id="ix-1-30"></span>&shy;兩個集合<code class="haskell">A</code>與<code class="haskell">B</code> <em>同構</em>(<em>isomorphic</em>)，意思是&shy;<code class="haskell">A</code> 之中的 <em>每個</em>元素都<em>唯一地</em>對應到 <code class="haskell">B</code> 之中的<em>一個</em>元素，反之亦然。</p><p>一個形式定義是：<code class="haskell">A</code>與<code class="haskell">B</code>同構意謂我們能找到兩個全(total)函數&shy;<span id="ix-1-31"></span> <code class="haskell">to :: A -&gt; B</code> 和 <code class="haskell">from :: B -&gt; A</code>, 滿足</p><pre><code class="spec">from . to = id 
to . from = id 
</code></pre><p>此處的兩個 <code class="haskell">id</code> 型別依序分別為 <code class="haskell">A -&gt; A</code> 和 <code class="haskell">B -&gt; B</code>。&shy;將定義展開，也就是說，對所有 <code class="haskell">x :: A</code>，<code class="haskell">from (to x) = x</code>; 對所有 <code class="haskell">y :: B</code>, <code class="haskell">to (from y) = y</code>. 這個定義迫使對每個 <code class="haskell">x</code> 都存在一個唯一的 <code class="haskell">to x</code>, 反之亦然。</p><p>我們已有兩個例子：<code class="haskell">((a × b) × c)</code> 與 <code class="haskell">(a × (b × c))</code> 同構，此外，<code class="haskell">(a × b)</code> 與 <code class="haskell">(b × a)</code> 也同構，因為 <code class="haskell">swap . swap = id</code>.</p><p>如果集合<code class="haskell">A</code>與<code class="haskell">B</code>同構，不僅 <code class="haskell">A</code> 之中的每個元素都有個在 <code class="haskell">B</code> 之中相對的元素，給任一個定義在 <code class="haskell">A</code> 之上的函數 <code class="haskell">f</code>, 我們必可構造出一個 <code class="haskell">B</code> 之上的函數，具有和 <code class="haskell">f</code> 相同的性質。即使<code class="haskell">A</code>與<code class="haskell">B</code>並不真正相等，我們也可把它們視為<em>基本上沒有差別</em>的。在許多無法談「相等」的領域中，同構是和「相等」地位一樣的觀念。</p></div><p>另外可一提的是，Haskell 允許我們在 $\lambda$ 算式中做樣式配對。例如 <code class="haskell">fst</code> 的另一種寫法是：</p><pre><code class="spec">fst = \(x,y) -&gt; x 
</code></pre><p>Haskell 另有提供更多個元素形成的有序組，例如 <code class="haskell">(True, 3, 'c')</code> 是一個型別為 <code class="haskell">(Bool × Int × Char)</code> 的值。但本書暫時不使用他們。</p><p id="par:split-product"><b>分裂與積</b> &emsp;&shy;在我們將介紹的程式設計風格中，以下兩個產生序對的運算子相當好用。&shy;第一個運算子利用兩個函數產生一個序對：</p><pre><code class="haskell">fork :: (a -&gt; b) -&gt; (a -&gt; c) -&gt; a -&gt; (b × c)
(fork f g) x = (f x, g x) 
</code></pre><p>給定兩個函數 <code class="haskell">f :: a -&gt; b</code> 和 <code class="haskell">g :: a -&gt; c</code>,&shy;<code class="haskell">fork f g :: a -&gt; (b × c)</code> 是一個新函數，將 <code class="haskell">f</code> 和 <code class="haskell">g</code> 的結果&shy;收集在一個序對中。&shy;我們借用範疇論的詞彙，將此稱作<em>分裂</em>(<em>split</em>) ---&shy;<code class="haskell">fork f g</code> 可讀成「<code class="haskell">f</code> 與 <code class="haskell">g</code> 的分裂」。&shy;<span id="ix-1-32"></span></p><p>如果我們已經有了一個序對，我們可用 <code class="haskell">(f *** g)</code> 算出一個新序對：</p><pre><code class="spec">(***) :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; (a × c) -&gt; (b × d)
(f *** g) (x,y) = (f x, g x) 
</code></pre><p>函數<code class="haskell">(f *** g)</code> 將 <code class="haskell">f</code> 和 <code class="haskell">g</code> 分別作用在序對 <code class="haskell">(x,y)</code> 的兩個元素上。&shy;這個操作稱作「<code class="haskell">f</code> 和 <code class="haskell">g</code> 的乘績(product)」，同樣是借用範疇論的詞彙。&shy;<span id="ix-1-33"></span></p><p>關於分裂與乘積，有兩條重要的性質，將會在之後用到：</p><div class="equations"><ul><li><p id="eq:prod-split-absorb"><b>吸收律</b> &emsp; <code class="haskell">(f *** g) . fork h k</code> <code class="haskell">= fork (f . h) (g . k)</code></p></li><li><p id="eq:prod-fusion"><b>融合律</b> &emsp; <code class="haskell">(f *** g) . (h *** k)</code> <code class="haskell">= ((f . h) *** (g . k))</code></p></li></ul></div><p>目前 Haskell 的標準階層函式庫將分裂與乘積收錄在 \texttt{Control.Arrow} 中，&shy;<code class="haskell">fork f g</code> 寫作：\texttt{f \&\&\& g}, <code class="haskell">(f *** g)</code> 則寫作 \texttt{f *** g}.</p><p id="par:currying-uncurrying"><b>Currying 與 Uncurrying</b> &emsp;&shy;如前所述，Haskell 的每個函數都只拿一個參數。拿多個參數的函數可以&shy;傳回函數的函數來模擬，稱作 currying.&shy;有了序對之後，另一種模擬多參數的方式是把參數都包到一個序對中。&shy;例如，型別為 <code class="haskell">(a × b) -&gt; c)</code> 的函數可視為拿了兩個型別為 <code class="haskell">a</code> 與 <code class="haskell">b</code> 的參數。</p><p>函數 <code class="haskell">curry</code> 與 <code class="haskell">uncurry</code> 幫助我們在這兩種表示法之間轉換 ---&shy;<code class="haskell">curry</code> 將拿序對的函數轉換成 curried 函數，<span id="ix-1-34"></span>&shy;<code class="haskell">uncurry</code> 則讓 curried 函數改拿序對當作參數：<span id="ix-1-35"></span></p><pre><code class="spec">curry :: ((a × b) -&gt; c) -&gt; (a -&gt; b -&gt; c)
curry f x y = f (x,y) 

uncurry :: (a -&gt; b -&gt; c) -&gt; ((a × b) -&gt; c)
uncurry f (x,y) = f x y 
</code></pre><p>例：如果<code class="haskell">(==)</code> 的型別為 <code class="haskell">Int -&gt; Int -&gt; Bool</code>,&shy;<code class="haskell">uncurry (==)</code> 的型別為 <code class="haskell">(Int × Int) -&gt; Bool</code>。&shy;後者檢查一個序對中的兩個值是否相等（例：<code class="haskell">uncurry (==) (3,3) = True</code>）。</p><div class="exlist"><div class="exercise exer" id="ex:curry-uncurry-id"><h5 class="exercise-title">練習 1.10 </h5><p>事實上，<code class="haskell">curry</code> 與 <code class="haskell">uncurry</code> 的存在證明了 <code class="haskell">(a × b) -&gt; c</code>&shy;與 <code class="haskell">a -&gt; b -&gt; c</code> 是同構的。試證明&shy;<code class="haskell">curry . uncurry = id</code>, 以及 <code class="haskell">uncurry . curry = id</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-10" type="checkbox"/><label class="lbl-toggle" for="ans-1-10">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>欲證明 <code class="haskell">curry . uncurry = id</code>：</p><pre><code class="spec">     curry . uncurry = id
&lt;=&gt;    <comment>{- 外延相等及 <code class="haskell">id</code> 之定義 -}</comment>
     (forall f : curry (uncurry f) = f)
&lt;=&gt;    <comment>{- 外延相等 -}</comment>
     (forall f x y : curry (uncurry f) x y = f x y) 
</code></pre><p>因此我們證明 <code class="haskell">curry (uncurry f) x y = f x y</code> 如下：</p><pre><code class="spec">   curry (uncurry f) x y
=   <comment>{- <code class="haskell">curry</code> 之定義 -}</comment>
   uncurry f (x,y)
=   <comment>{- <code class="haskell">uncurry</code> 之定義 -}</comment>
   f x y  
</code></pre><p>與此相似，欲證明 <code class="haskell">uncurry . curry = id</code> 我們須證明&shy;<code class="haskell">uncurry (curry f) (x,y) = f (x,y)</code>，其證明也與上面的證明類似。</p></div></div><div class="exercise exer" id="ex:uncurry-apply"><h5 class="exercise-title">練習 1.11 </h5><p>請說明 <code class="haskell">map (uncurry ($))</code> 的型別與功能。&shy;關於 <code class="haskell">($)</code> 請參考第\pageref{para:fun-apply}頁。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-11" type="checkbox"/><label class="lbl-toggle" for="ans-1-11">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p><code class="haskell">map (uncurry ($)) :: List ((a -&gt; b) × a) -&gt; List b</code>.&shy;它拿一個內容均為「(函數 $\times$ 參數)」序對的串列，將每個函數作用在其參數上。&shy;例如：</p><pre><code class="spec">map (uncurry ($)) [((1+), 3), (square, 4), (smaller 5, 3)]
</code></pre><p>會得到 <code class="haskell">[1+3,4*4,3]</code>.</p></div></div></div><h2 class="section" id="sec:weak-head-normal-form">1.7 弱首範式</h2><p>我們現在可把第<a href="Basics.html#sec:evaluation">1.1 </a>節中提及的求值與範式談得更仔細些。&shy;第一次閱讀的讀者可把本節跳過。&shy;回顧 <code class="haskell">fst</code> 使用樣式配對的定義 <code class="haskell">fst (x,y) = x</code>.&shy;假設我們把 <code class="haskell">swap</code> 定義如下：</p><pre><code class="spec">swap p = (snd p, fst p) 
</code></pre><p>考慮 <code class="haskell">fst (swap (3,'a'))</code> 該怎麼求值：</p><pre><code class="spec">   fst (swap (3,'a'))
=   <comment>{- <code class="haskell">swap</code> 的定義 -}</comment>
   fst (snd (3,'a'), fst (3,'a'))
=   <comment>{- <code class="haskell">fst</code> 的定義 -}</comment>
   snd (3,'a')
=   <comment>{- <code class="haskell">snd</code> 的定義 -}</comment>
   'a' 
</code></pre><p>在第一步中，由於 <code class="haskell">fst</code> 使用樣式配對，我們得先把 <code class="haskell">swap (3,'a')</code> 算出來。&shy;若把 <code class="haskell">swap (3,'a')</code> 算到底，得到的範式是 <code class="haskell">('a',3)</code>.&shy;但如第一步中所顯示，如果目的只是為了配對 <code class="haskell">(x,y)</code> 這個樣式，&shy;我們並不需要把 <code class="haskell">swap (3,'a')</code> 算完，只需算到 <code class="haskell">(snd (3,'a'), fst (3,'a'))</code>&shy;即可 --- <code class="haskell">x</code> 可對應到 <code class="haskell">snd (3,'a')</code>, <code class="haskell">y</code> 可對應到 <code class="haskell">fst (3,'a')</code>,&shy;<code class="haskell">fst</code> 的計算便可以進行。在下一步中，子算式 <code class="haskell">fst (3,'a')</code> 便被丟棄了，&shy;並沒有必要算出來。</p><p>做樣式配對時，Haskell 只會把算式歸約到剛好足以與樣式配對上的程度。&shy;當樣式的深度只有一層（如<code class="haskell">(x,y)</code>）時，與之配對的式子會被歸約成一種&shy;稱作<em>弱首範式</em>(<em>weak head normal form</em>)%&shy;<span id="ix-1-36"></span>的形式。&shy;弱首範式有其嚴格定義，但本書讀者只需知道：算式會被歸約到<em>露出最外面的建構元</em>，（在此例中是被歸約成 <code class="haskell">(_,_)</code> 的形式），然後便停下來。</p><div class="theorem" id="eg:swap"><h5 class="theorem-title">例 1.14  </h5><p>回顧 <code class="haskell">swap</code> 的兩種定義方式，分別命名為</p><pre><code class="spec">swap1 (x,y)  = (y,x)  
swap2 p      = (snd p, fst p) 
</code></pre><p>若考慮不終止的參數，兩者的行為並不盡然相同。&shy;定義 <code class="haskell">three (x,y) = 3</code>, 並&shy;假設 <code class="haskell">undefined</code> 是一個沒有範式的式子 --- 一旦開始對 <code class="haskell">undefined</code> 求值，便停不下來。&shy;試計算 <code class="haskell">three (swap1 undefined)</code> 和 <code class="haskell">three (swap2 undefined)</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-11" type="checkbox"/><label class="lbl-toggle" for="ans-1-11">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>由於 <code class="haskell">three</code> 使用樣式配對，計算 <code class="haskell">three (swap1 undefined)</code> 時得把 <code class="haskell">swap1 undefined</code> 歸約成弱首範式。&shy;同理，計算 <code class="haskell">swap1 undefined</code> 時，第一步便是先試圖把 <code class="haskell">undefined</code> 歸約成弱首範式，然後便停不下來了。</p><p>至於 <code class="haskell">three (swap2 undefined)</code> 則可如下地求值：</p><pre><code class="spec">   three (swap2 undefined)
=   <comment>{- <code class="haskell">swap2</code> 之定義 -}</comment>
   three (snd undefined, fst  undefined)
=   <comment>{- <code class="haskell">three</code> 之定義 -}</comment>
   3 
</code></pre><p>第一步中，<code class="haskell">swap2 undefined</code> 則依照範式順序求值的原則展開為 <code class="haskell">(snd undefined, fst  undefined)</code> --- 這是一個序對，只是該序對含有兩個沒有範式的元素。&shy;該序對可對應到樣式 <code class="haskell">(x,y)</code>, 因此整個式子歸約為 <code class="haskell">3</code>.</p><p>附帶一提，<code class="haskell">three undefined</code> 是一個不停止的計算。</p></div></div><h2 class="section" id="sec:lists">1.8 串列</h2><p>一個\emph{串列}(list)<span id="ix-1-37"></span>&shy;抽象說來便是<em>將零個或多個值放在一起變成一串</em>。&shy;串列是函數語言傳統上的重要資料結構：&shy;早期的函數語言 LISP 便是 LISt Processing 的縮寫。&shy;Haskell 中的串列多了一個限制：串列中的每個元素必須有同樣的型別。&shy;本書中將「元素型別均為 <code class="haskell">a</code> 的串列」的型別寫成 <code class="haskell">List a</code>.&shy;<input class="toggle" id="footnote-1-8-13" type="checkbox"/><label class="fnote-toggle" for="footnote-1-8-13">(註13) </label><span class="collapsible-footnote">Haskell 中的寫法是 <code class="haskell">[a]</code>. 同樣地，在我的教學經驗中，將中括號同時使用在值與型別上造成不少誤解。例如學生可能認為 <code class="haskell">[1,2]</code> 的型別是 <code class="haskell">[Int,Int]</code> --- 其實應該是 <code class="haskell">[Int]</code>.</span>&shy;Hasekell 以中括號表示串列，其中的元素以逗號分隔。&shy;例如，<code class="haskell">[1,2,3,4]</code> 是一個型別為 <code class="haskell">List Int</code> 的串列，其中有四個元素；&shy;<code class="haskell">[True, False, True]</code> 是一個型別為 <code class="haskell">List Bool</code> 的串列，有三個元素。&shy;至於 <code class="haskell">[]</code> 則是沒有元素的<em>空串列</em>（通常唸做 ``nil''），其最通用的型別為 <code class="haskell">List a</code>，&shy;其中 <code class="haskell">a</code> 可以是任何型別。</p><p>串列的元素也可以是串列。例如 <code class="haskell">[[1,2,3],[],[4,5]]</code> 的型別是 <code class="haskell">List (List Int)</code>,&shy;含有三個元素，分別為 <code class="haskell">[1,2,3]</code>, <code class="haskell">[]</code>, 和 <code class="haskell">[4,5]</code>.</p><p>事實上，上述的寫法只是語法糖。我們可想像 Haskell 有這樣的型別定義：</p><pre><code class="spec">data List a  =  []  |  a : List a 
</code></pre><p>意謂一個元素型別為 <code class="haskell">a</code> 的串列只有兩種可能構成方式：&shy;可能是空串列 <code class="haskell">[]</code>，也可能是一個元素 (<code class="haskell">a</code>) 接上另一個串列 (<code class="haskell">List a</code>)。&shy;後者的情況中，元素和串列之間用符號 <code class="haskell">(:)</code> 銜接。&shy;<span id="ix-1-38"></span>&shy;<span id="ix-1-39"></span></p><p>符號 <code class="haskell">(:)</code> 唸作 ``cons'', 為「建構(construct)」的字首。&shy;其型別為 <code class="haskell">a -&gt; List a -&gt; List a</code> ---&shy;它總是將一個型別為 <code class="haskell">a</code> 的元素接到一個 <code class="haskell">List a</code> 之上，造出另一個 <code class="haskell">List a</code>.&shy;上述的 <code class="haskell">[1,2,3,4]</code> 其實是 <code class="haskell">1 : (2 : (3 : (4 : [])))</code>&shy;的簡寫：由空串列 <code class="haskell">[]</code> 開始，將元素一個個接上去。&shy;為了方便，Haskell 將 <code class="haskell">(:)</code> 運算元視做右相依的，&shy;因此我們可將括號省去，寫成&shy;<code class="haskell">1 : 2 : 3 : 4 : []</code>。</p><div class="infobox infobox" title="|(:)| 與 |(::)|"><h5 class="infobox-title">|(:)| 與 |(::)|</h5><p><span id="ix-1-40"></span><span id="ix-1-41"></span>&shy;大部分有型別的函數語言（如 ML, Agda 等）之中，&shy;<code class="haskell">(:)</code> 表示型別關係，<code class="haskell">(::)</code> 則是串列的建構元。&shy;Haskell 的前身之一是 David A. Turner 的語言 Miranda.&shy;在其 Hindley-Milner 型別系統中，Miranda 使用者幾乎不需寫出程式的型別 ---&shy;型別可由電腦自動推導。而串列是重要資料結構。&shy;把兩個符號調換過來，使常用的符號較短一些，似乎是合理的設計。</p><p>Haskell 繼承了 Miranda 的語法。&shy;然而，後來 Haskell 的型別發展得越來越複雜，&shy;使用者偶爾需要寫出型別來幫助編譯器。&shy;即使型別簡單，程式語言界也漸漸覺得將函數的型別寫出是好習慣。&shy;而串列建構元的使用量並不見得比型別關係多。&shy;但此時想改符號也為時已晚了。</p></div><p>無論如何，這樣的串列表示法是偏一邊的 ---&shy;元素總是從左邊放入，最左邊的元素也最容易取出。&shy;如果一個串列不是空的，其最左邊的元素稱作該串列的<em>頭</em>(<em>head</em>)，&shy;剩下的元素稱作其<em>尾</em>(<em>tail</em>)。&shy;例如，<code class="haskell">[1,2,3,4]</code> 的頭是 <code class="haskell">1</code>, 尾是 <code class="haskell">[2,3,4]</code>.</p><p>Haskell 中將字串當作字元形成的串列。標準函式庫中這麼定義著：</p><pre><code class="spec">type String = List Char 
</code></pre><p>意謂 <code class="haskell">String</code> 就是 <code class="haskell">List Char</code>。&shy;在 Haskell 中，<code class="haskell">data</code> 用於定義新型別，而 <code class="haskell">type</code> 並不產生一個新的型別，&shy;只是給現有的型別一個較方便或更顯出當下意圖的名字。&shy;此外，Haskell 另提供一個語法糖，用雙引號表達字串。&shy;因此，<code class="haskell">"fun"</code> 是 <code class="haskell">['f','u','n']</code> 的簡寫，&shy;後者又是 <code class="haskell">'f':'u':'n':[]</code> 的簡寫。</p><p>本節接下來將介紹許多與串列相關的內建函數。</p><h3 class="subsection" id="sec:list-deconstruct">1.8.1 串列解構</h3><p>我們先從拆解串列的函數開始。函數 <code class="haskell">head</code> 和 <code class="haskell">tail</code> 分別取出一個串列的頭和尾：</p><div class="multicols"><div class="mcol" width="0.4\textwidth"><pre><code class="spec">head :: List a -&gt; a
head (x:xs) = x 
</code></pre></div><div class="mcol" width="0.4\textwidth"><pre><code class="spec">tail :: List a -&gt; List a
tail (x:xs) = xs 
</code></pre></div></div><p>注意其型別：<code class="haskell">head</code> 傳回一個元素，<code class="haskell">tail</code> 則傳回一個串列。&shy;例：<code class="haskell">head "fun"</code> 和 <code class="haskell">tail "fun"</code> 分別是字元 <code class="haskell">'f'</code> 和字串 <code class="haskell">"un"</code>.&shy;函數 <code class="haskell">head</code> 和 <code class="haskell">tail</code> 都可用樣式配對定義，但此處的樣式並不完整，尚缺 <code class="haskell">[]</code> 的情況。&shy;如果將空串列送給 <code class="haskell">head</code> 或 <code class="haskell">tail</code>，則會出現執行時錯誤。&shy;因此，<code class="haskell">head</code> 和 <code class="haskell">tail</code> 都是<em>部分函數</em>(<em>partial functions</em>) --- 它們只將某些值（非空的串列）對應到輸出，某些值（空串列）則沒有。<span id="ix-1-42"></span></p><p>函數 <code class="haskell">null</code> 判斷一個串列是否為空串列。它也可用樣式配對定義如下：</p><pre><code class="spec">null :: List a -&gt; Bool
null []      = True
null (x:xs)  = False 
</code></pre><p>本書依循 <a href="Biblio.html#Bird:98:Introduction">Bird [1998]</a> 中的變數命名習慣，&shy;將型別為串列的變數以 <code class="haskell">s</code> 做結尾，例如 <code class="haskell">xs</code>, <code class="haskell">ys</code> 等等。&shy;至於「元素為串列的串列」則命名為 <code class="haskell">xss</code>, <code class="haskell">yss</code> 等等。&shy;但這只是為方便理解而設計的習慣。Haskell 本身並無此規定。</p><p>除了 <code class="haskell">head</code> 與 <code class="haskell">tail</code>，也有另一組函數 <code class="haskell">last</code> 與 <code class="haskell">init</code> 分別取出一個串列<em>最右邊</em>的元素，以及剩下的串列：</p><pre><code class="spec">last  :: List a -&gt; a 
init  :: List a -&gt; List a 
</code></pre><p>例：<code class="haskell">last "fun"</code> 與 <code class="haskell">init "fun"</code> 分別為字元 <code class="haskell">'n'</code> 與字串 <code class="haskell">"fu"</code>.&shy;但 <code class="haskell">last</code> 與 <code class="haskell">init</code> 的定義比起 <code class="haskell">head</code> 與 <code class="haskell">tail</code> 來得複雜：&shy;記得我們的串列表示法是偏向一邊的，從左邊存取元素容易，從右邊存取元素則較麻煩。&shy;我們會在 \todo{where} 之中談到 <code class="haskell">last</code> 與 <code class="haskell">init</code> 的定義。</p><h3 class="subsection" id="sec:list-generation">1.8.2 串列生成</h3><p>第<a href="Basics.html#sec:list-deconstruct">1.8.1 </a>節中的函數均將串列拆開。&shy;本節之中我們來看一些生成串列的方法。&shy;如果元素的型別是有順序的（例如<code class="haskell">Int</code>, <code class="haskell">Char</code>等型別），Haskell 提供了一個&shy;方便我們依序生成串列的語法。以例子說明：</p><div class="theorem" id="eg:list-gen-examples"><h5 class="theorem-title">例 1.15  </h5><p>以下為 Haskell 的列舉語法的一些例子：</p><ul><li><p><code class="haskell">[0..10]</code> 可展開為 <code class="haskell">[0,1,2,3,4,5,6,7,8,9,10]</code>.</p></li><li><p>可用頭兩個元素來指定間隔量。例如 <code class="haskell">[0,3..10] = [0,3,6,9]</code>. 注意該串列的元素不超過右界 <code class="haskell">10</code>.</p></li><li><p>在 <code class="haskell">[10..0]</code> 之中，<code class="haskell">10</code> 一開始就超過了右界 <code class="haskell">0</code>, 因此得到 <code class="haskell">[]</code>. 如果想要產生由 <code class="haskell">10</code> 倒數到 <code class="haskell">0</code> 的串列，可這樣指定間隔：<code class="haskell">[10,9..0]</code>.</p></li><li><p>字元也是有順序的，因此 <code class="haskell">['a'..'z']</code> 可展開為含所有英文小寫字母的串列。</p></li><li><p>至於沒有右界的 <code class="haskell">[0..]</code> 則會展開為含 <code class="haskell">[0,1,2,3...]</code> 的無限長串列。</p></li></ul></div><p>函數 <code class="haskell">iterate :: (a -&gt; a) -&gt; a -&gt; List a</code> 用於產生無限長的串列：&shy;<code class="haskell">iterate f x</code> 可展開為 <code class="haskell">[x, f x, f (f x), f (f (f x))... ]</code>.</p><div class="theorem" id="eg:iterate-example"><h5 class="theorem-title">例 1.16  </h5><p>一些 <code class="haskell">iterate</code> 的例子：</p><ul><li><p><code class="haskell">iterate (1+) 0</code> 展開為 <code class="haskell">[0,1,2,3...]</code>. 其實 <code class="haskell">[n..]</code> 可視為 <code class="haskell">iterate (1+) n</code> 的簡寫。</p></li><li><p>在例[RefUndefined]中我們會看到 <code class="haskell">[m..n]</code> 也可用 <code class="haskell">iterate</code> 與其他函數做出。</p></li><li><p><code class="haskell">iterate not False</code> 可得到無窮串列 <code class="haskell">[False, True, False...]</code>.</p></li></ul></div><p>數學中描述集合時常使用一種稱作集合建構式(set comprehension)的語法。例如，&shy;<code class="haskell">{x * x | x ∈ S, odd x}</code> 表示收集所有 <code class="haskell">x*x</code> 形成的集合，其中&shy;<code class="haskell">x</code> 由集合 S 中取出，並且必須為奇數。Haskell 將類似的語法用在串列上。&shy;同樣以例子說明：</p><div class="theorem" id="eg:list-comprehension-examples"><h5 class="theorem-title">例 1.17  </h5><p>串列建構式(list comprehension)的例子：<span id="ix-1-43"></span></p><ul><li><p><code class="haskell">[x | x &lt;- [0..9]]</code> 表示「從<code class="haskell">[0..9]</code>之中取出 <code class="haskell">x</code>, 並收集 <code class="haskell">x</code>」，可展開為 <code class="haskell">[0,1,2,3,4,5,6,7,8,9]</code>.</p></li><li><p><code class="haskell">[x*x | x &lt;- [0..10]]</code> 的 <code class="haskell">x</code> 來源和之前相同，但收集的是 <code class="haskell">x*x</code>，得到 <code class="haskell">[0,1,4,9,25,36,49,64,81]</code>.</p></li><li><p><code class="haskell">[(x,y) | x &lt;- [0..2], y &lt;- "abc"]</code> 展開得到&shy;<code class="haskell">[(0,'a'),</code> <code class="haskell">(0,'b'),</code> <code class="haskell">(0,'c'),</code> <code class="haskell">(1,'a'),</code> <code class="haskell">(1,'b'),</code> <code class="haskell">(1,'c'),</code> <code class="haskell">(2,'a'),</code> <code class="haskell">(2,'b'),</code> <code class="haskell">(2,'c')]</code>.&shy;注意序對出現的順序：先固定 <code class="haskell">x</code>，將 <code class="haskell">y</code> 跑過一遍，再換成下一個 <code class="haskell">x</code>.</p></li><li><p><code class="haskell">[x*x | x &lt;- [0..10], odd x]</code> 從<code class="haskell">[0..10]</code>之中取出 <code class="haskell">x</code>，但只挑出滿足 <code class="haskell">odd x</code> 的那些，得到 <code class="haskell">[1,9,25,49,81]</code>.</p></li></ul></div><div class="theorem" id="eg:list-comprehension-examples2"><h5 class="theorem-title">例 1.18  </h5><p>以下算式的值分別為何？</p><ol><li><p><code class="haskell">[(a,b) | a &lt;- [1..3], b &lt;- [1..2]]</code>.</p></li><li><p><code class="haskell">[(a,b) | b &lt;- [1..2], a &lt;- [1..3]]</code>.</p></li><li><p><code class="haskell">[(i, j) | i &lt;- [1..4], j &lt;- [(i + 1)..4]]</code>. 這是一個有了 <code class="haskell">i &lt;- ..</code> 之後，<code class="haskell">i</code> 即可在右方被使用的例子。</p></li><li><p><code class="haskell">[(i, j) | i &lt;- [1..4], even i, j &lt;- [(i + 1)..4], odd j]</code>.</p></li><li><p><code class="haskell">['a' |i &lt;- [0..10]]</code>. 這個例子顯示 <code class="haskell">i</code> 並不一定非得出現在被收集項目中。</p></li></ol></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-11" type="checkbox"/><label class="lbl-toggle" for="ans-1-11">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>分別展開如下：</p><ol><li><p><code class="haskell">[(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)]</code>.</p></li><li><p><code class="haskell">[(1,1),(2,1),(3,1),(1,2),(2,2),(3,2)]</code>.</p></li><li><p><code class="haskell">[(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]</code>.</p></li><li><p><code class="haskell">[(2,3)]</code>.</p></li><li><p><code class="haskell">"aaaaaaaaaaa"</code>.</p></li></ol></div></div><p>串列建構式在寫程式時相當好用，但它也僅是個語法糖 ---&shy;所有的串列建構式都可轉換為後面的章節將介紹的 <code class="haskell">map</code>, <code class="haskell">concat</code>, <code class="haskell">filter</code> 等函數的組合。</p><h3 class="subsection" id="sec:list-combinators">1.8.3 串列上的種種組件函數</h3><p>我們將在本節介紹大量與串列有關的函數。&shy;它們常被稱做<em>組件</em>(<em>combinators</em>)<span id="ix-1-44"></span>函數。&shy;每一個組件都負責一項單一、但具通用性而容易重用的功能。&shy;它們常用來彼此結合以組出更大的程式。</p><p>介紹這些函數有兩個原因。首先，它們可用來組出許多有趣的程式。&shy;我們將一邊逐一介紹這些函數，一邊以例子示範，&shy;同時也逐漸帶出本章鼓勵的一種特殊編程風格。&shy;另一個原因是在日後的章節中我們也都將以這些函數作為例子，&shy;討論並證明關於它們的性質。</p><p>第一次閱讀的讀者可能訝異：這麼多函數，怎麼記得住？&shy;事實上，這些組件大都僅是把常見的編程模式具體地以形式方式表達出來。&shy;辨識出這些模式後，不僅會發現它們其實很熟悉，對於我們日後了解其他程式也有助益。</p><p><b>長度</b> &emsp; 函數 <code class="haskell">length :: List a -&gt; Int</code> 計算串列的長度。&shy;空串列 <code class="haskell">[]</code> 的長度為 <code class="haskell">0</code>. 例：<code class="haskell">length "function" = 8</code>.</p><p><b>索引</b> &emsp; 函數 <code class="haskell">(!!)</code> 的型別為 <code class="haskell">List a -&gt; Int -&gt; a</code>.&shy;給定串列 <code class="haskell">xs</code> 和整數 <code class="haskell">i</code>, 如果 <code class="haskell">0 &lt;= i &lt; length xs</code>,&shy;<code class="haskell">xs !! i</code> 為 <code class="haskell">xs</code> 中的第 <code class="haskell">i</code> 個元素，但由 <code class="haskell">0</code> 起算。&shy;例 <code class="haskell">"function" !! 0 = 'f'</code>, <code class="haskell">"function" !! 3 = 'c'</code>.&shy;如果 <code class="haskell">i &gt; length xs</code>, 則會成為執行期錯誤。&shy;注意：如果 <code class="haskell">length xs = n</code>，其中的元素編號分別為 <code class="haskell">0</code>, <code class="haskell">1</code> .. <code class="haskell">n-1</code>.</p><p>在指令式語言中，索引是處理陣列常用的基本操作。&shy;處理陣列的常見模式是用一個變數<code class="haskell">i</code>指向目前正被處理的元素，將<code class="haskell">a[i]</code>的值讀出或覆寫，&shy;然後更新<code class="haskell">i</code>的值。&shy;但由接下來的許多範例中，讀者會發現本章盡量避免這種做法。&shy;也因此 <code class="haskell">(!!)</code> 在本章中使用的機會不多。</p><p><b>連接</b> &emsp; 函數 <code class="haskell">(++) :: List a -&gt; List a -&gt; List a</code> 將兩個串列相接。&shy;例：<code class="haskell">[1,2,3] ++ [4,5] = [1,2,3,4,5]</code>.</p><p>函數 <code class="haskell">(++)</code> 和 <code class="haskell">(:)</code> 似乎都是把串列接上東西。兩者有什麼不同呢？&shy;答案是：<code class="haskell">(:) :: a -&gt; List a -&gt; List a</code> 永遠把<em>一個</em>元素接到串列的左邊，&shy;而 <code class="haskell">(++)</code> 把兩個串列接在一起，兩個串列都有可能含有零個或多個元素。&shy;例：<code class="haskell">[] ++ [4,5] = [4,5]</code>. 事實上，<code class="haskell">(:)</code> 是比 <code class="haskell">(++)</code> 更基礎的操作。&shy;在第<a href="Induction.html#sec:induction-lists-defn">2.4.1 </a>節中，我們會看到 <code class="haskell">(++)</code> 是用 <code class="haskell">(:)</code> 定義而成的。</p><p>另一個關於連接的函數是 <code class="haskell">concat :: List (List a) -&gt; List a</code>：它以一個元素都是串列的串列作為輸入，將其中的串列接在一起。例：<code class="haskell">concat [[1,2,3],[],[4],[5,6]]</code> <code class="haskell">=</code> <code class="haskell">[1,2,3,4,5,6]</code>. 它和 <code class="haskell">(++)</code> 的不同之處在哪呢？顯然，<code class="haskell">(++)</code> 總把兩個串列接在一起，&shy;而 <code class="haskell">concat</code> 的參數中可含有零個或多個串列。&shy;在第<a href="Induction.html#sec:induction-lists-defn">2.4.1 </a>節中，我們會看到 <code class="haskell">concat</code> 是用 <code class="haskell">(++)</code> 定義而成的。</p><p><b>取與丟</b> &emsp; <code class="haskell">take</code> 的型別為 <code class="haskell">Int -&gt; List a -&gt; List a</code>.&shy;<code class="haskell">take n xs</code> 取 <code class="haskell">xs</code> 的前 <code class="haskell">n</code> 個元素。若 <code class="haskell">xs</code> 的長度不到 <code class="haskell">n</code>,&shy;<code class="haskell">take n xs</code> 能拿幾個就拿幾個. 例：<code class="haskell">take 3 "function" = "fun"</code>,&shy;<code class="haskell">take 5 "ox" = "ox"</code>.</p><p>相對地，<code class="haskell">drop n xs</code> 丟掉 <code class="haskell">xs</code> 的前 <code class="haskell">n</code> 個元素。若 <code class="haskell">xs</code> 的長度不到 <code class="haskell">n</code>,&shy;<code class="haskell">drop n xs</code> 能丟幾個就拿幾個. 例：<code class="haskell">drop 3 "function" = "ction"</code>,&shy;<code class="haskell">take 5 "ox" = ""</code>. 函數 <code class="haskell">drop</code> 的型別也是 <code class="haskell">Int -&gt; List a -&gt; List a</code>.</p><p>函數 <code class="haskell">take</code> 和 <code class="haskell">drop</code> 顯然有些關聯，但它們的關聯該怎麼具體地寫下來呢？&shy;一個可能是：對所有的 <code class="haskell">n</code> 和 <code class="haskell">xs</code>,</p><p>乍看之下似乎言之成理。但這個性質真的成立嗎？&shy;我們將在第<a href="Induction.html#ch:induction">2 </a>章中討論到。</p><p><b>映射</b> &emsp; <code class="haskell">map :: (a -&gt; b) -&gt; List a -&gt; List b</code> 是串列上&shy;一個很重要的高階函數：<code class="haskell">map f xs</code> 將 <code class="haskell">f</code> 作用在 <code class="haskell">xs</code> 的每一個元素上。&shy;例：</p><p>回憶我們之前關於高階函數的討論，另一個理解方式是：&shy;<code class="haskell">map</code> 是一個處理函數的操作。給一個「將 <code class="haskell">a</code> 變成 <code class="haskell">b</code>」的函數 <code class="haskell">f :: a -&gt; b</code>，&shy;<code class="haskell">map</code> 將這個函數<em>提升</em>到串列的層次，&shy;得到一個「將 <code class="haskell">List a</code> 變成 <code class="haskell">List b</code>」的函數 <code class="haskell">map f :: List a -&gt; List b</code>.</p><div class="theorem" id="ex:inits"><h5 class="theorem-title">例 1.19  </h5><p>如果一個串列 <code class="haskell">xs</code> 可分解為 <code class="haskell">ys ++ zs</code>, 我們說 <code class="haskell">ys</code> 是 <code class="haskell">xs</code> 的一個<em>前段(prefix)</em>,<span id="ix-1-45"></span>&shy;<code class="haskell">zs</code> 則是 <code class="haskell">xs</code> 的一個<em>後段</em>(<em>suffix</em>). <span id="ix-1-46"></span>&shy;例如，串列 <code class="haskell">[1,2,3]</code> 的前段包括 <code class="haskell">[]</code>, <code class="haskell">[1]</code>, <code class="haskell">[1,2]</code>, 與<code class="haskell">[1,2,3]</code> （注意：<code class="haskell">[]</code>是一個前段，<code class="haskell">[1,2,3]</code> 本身也是）, 後段則包括 <code class="haskell">[1,2,3]</code>, <code class="haskell">[2,3]</code>, <code class="haskell">[3]</code>, 與 <code class="haskell">[]</code>。</p><p>試定義函數 <code class="haskell">inits :: List a -&gt; List (List a)</code>, 計算輸入串列的所有前段。&shy;<input class="toggle" id="footnote-1-8-14" type="checkbox"/><label class="fnote-toggle" for="footnote-1-8-14">(註14) </label><span class="collapsible-footnote">請注意該函數的名字是 <code class="haskell">inits</code>, 和之前介紹過的 <code class="haskell">init</code> 不同。這是 Haskell 函式庫中使用的命名。</span>&shy;{\bf 提示}：目前我們可以用 <code class="haskell">map</code>, <code class="haskell">take</code> 和其他函數組出 <code class="haskell">inits</code>.&shy;在第<a href="Induction.html#sec:more-inductive-defns">2.6 </a>節中將會介紹另一個做法。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-11" type="checkbox"/><label class="lbl-toggle" for="ans-1-11">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>一種使用 <code class="haskell">map</code> 和 <code class="haskell">take</code> 的可能作法如下：</p><pre><code class="spec">inits :: List a -&gt; List (List a)
inits xs = map (\n -&gt; take n xs) [0 .. length xs] 
</code></pre><p>或著也可用串列建構式寫成 <code class="haskell">[take n xs | n &lt;- [0.. length xs]]</code>.&shy;讀者可能已發現：<code class="haskell">[f x | x &lt;- xs]</code> 就是 <code class="haskell">map f xs</code>.</p></div></div><div class="exlist"><div class="exercise exer" id="ex:tails"><h5 class="exercise-title">練習 1.12 </h5><p>定義函數 <code class="haskell">tails :: List a -&gt; List (List a)</code>,&shy;計算輸入串列的所有後段。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-12" type="checkbox"/><label class="lbl-toggle" for="ans-1-12">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="spec">tails :: List a -&gt; List (List a)
tails xs = map (\n -&gt; drop n xs) [0 .. length xs] 
</code></pre></div></div></div><p><b>過濾</b> &emsp;&shy;一個型別為 <code class="haskell">a -&gt; Bool</code> 的函數稱作一個「述語」(predicate).&shy;<span id="ix-1-47"></span>&shy;給定述語 <code class="haskell">p</code>, <code class="haskell">filter p xs</code> 將 <code class="haskell">xs</code> 之中滿足 <code class="haskell">p</code> 的元素挑出。&shy;函數 <code class="haskell">filter</code> 的型別為 <code class="haskell">(a -&gt; Bool) -&gt; List a -&gt; List a</code>。&shy;例：<code class="haskell">filter even [2,5,1,7,6] = [2,6]</code>.</p><div class="theorem" id="eg:numUpper"><h5 class="theorem-title">例 1.20  </h5><p>該怎麼得知一個字串中大寫字母的個數？&shy;將大寫字母過濾出來，計算所得串列的長度即可。如下所示：</p><pre><code class="spec">numUpper :: String -&gt; Int
numUpper = length . filter isUpper 
</code></pre></div><div class="theorem" id="eg:map-square"><h5 class="theorem-title">例 1.21  </h5><p>下列算式求出$0^2$ 到 $50^2$ 的平方數（能寫成 $n^2$ 的數字）中，&shy;結尾為 $25$ 的數字。</p><pre><code class="spec">  filter ((==25) . (`mod` 100)) (map square [0..50]) 
</code></pre><p>歸約後得到 <code class="haskell">[25,225,625,1225,2025]</code>.&shy;其中 <code class="haskell">(==25) . (`mod` 100)</code> 部分使用了第頁&shy;中提到的語法。如果覺得不習慣，也可用 $\lambda$ 算式寫成：</p><pre><code class="spec">  filter (\ n -&gt; n `mod` 100 == 25) (map square [0..50]) 
</code></pre></div><div class="theorem" id="eg:map-square-2"><h5 class="theorem-title">例 1.22  </h5><p>接續上例。另一個可能寫法是先過濾出「平方之後結尾為 <code class="haskell">25</code>」的數字，&shy;再算這些數字的平方：</p><pre><code class="spec">  map square (filter ((==25) . (`mod` 100) . square) [0..50]) 
</code></pre><p>這個算式也歸約出一樣的結果：<code class="haskell">[25,225,625,1225,2025]</code>。</p><p>稍微推廣一些，這個例子暗示我們 <code class="haskell">filter p . map f</code> 和 <code class="haskell">map f . filter (p . f)</code> 似乎是等價的。&shy;但確實如此嗎？我們也將在第<a href="Induction.html#ch:induction">2 </a>章中討論。</p></div><div class="theorem" id="eg:map-square-fork"><h5 class="theorem-title">例 1.23  </h5><p>接續上例。如果我們不僅希望找到結尾為 $25$ 的平方數，也希望知道它們是什麼數字的平方，&shy;一種寫法如下：</p><pre><code class="spec">  filter ((==25) . (`mod` 100) . snd) (map (fork id square) [0..50]) 
</code></pre><p>我們用 <code class="haskell">map (fork id square)</code> 將每個數字與他們的平方放在一個序對中，&shy;得到<code class="haskell">[(0,0), (1,1), (2,4), (3,9)...]</code>.&shy;而 <code class="haskell">filter</code> 的述語多了一個 <code class="haskell">snd</code>, 表示我們只要那些「第二個元素符合條件」的序對。&shy;上式化簡後可得到 <code class="haskell">[(5,25),</code> <code class="haskell">(15,225),</code> <code class="haskell">(25,625),</code> <code class="haskell">(35,1225),</code> <code class="haskell">(45,2025)]</code>.&shy;運算元 <code class="haskell">fork</code> 的定義詳見第頁。</p><p>述語 <code class="haskell">(==25) . (`mod` 100) . snd</code> 可以展開為 <code class="haskell">(\(i,n) -&gt; n `mod` 100 == 25)</code>.</p></div><p><b>取、丟、與過濾</b> &emsp; 函數 <code class="haskell">takeWhile</code>, <code class="haskell">dropWhile</code> 和 <code class="haskell">filter</code> 有一樣的型別。</p><pre><code class="spec">takeWhile  :: (a -&gt; Bool) -&gt; List a -&gt; List a 
dropWhile  :: (a -&gt; Bool) -&gt; List a -&gt; List a 
</code></pre><p>它們之間的差異也許用例子解釋得最清楚：</p><pre><code class="spec">filter     even [6,2,4,1,7,8,2] = [6,2,4,8,2] 
takeWhile  even [6,2,4,1,7,8,2] = [6,2,4] 
dropWhile  even [6,2,4,1,7,8,2] = [1,7,8,2] 
</code></pre><p><code class="haskell">filter p</code> 挑出所有滿足 <code class="haskell">p</code> 的元素；&shy;<code class="haskell">takeWhile p</code> 由左往右逐一取出元素，直到遇上第一個不滿足 <code class="haskell">p</code> 的元素，並將剩下的串列丟棄；&shy;<code class="haskell">dropWhile p</code> 則與 <code class="haskell">takeWhile p</code> 相對，將元素丟棄，直到遇上第一個不滿足 <code class="haskell">p</code> 的元素。&shy;直覺上，後兩者似乎也應該滿足 <code class="haskell">takeWhile p xs ++ dropWhile p xs = xs</code>, 但這仍尚待驗證。</p><div class="theorem" id="eg:fromto-takeWhile-iterate"><h5 class="theorem-title">例 1.24  </h5><p>給定整數 <code class="haskell">m</code> 與 <code class="haskell">n</code>, <code class="haskell">[m..n]</code> 可視為 <code class="haskell">takeWhile (&lt;= n) (iterate (1+) m)</code> 的簡寫。</p></div><div class="theorem" id="eg:takeWhile-dropWhile-until"><h5 class="theorem-title">例 1.25  </h5><p>讀者也許覺得 <code class="haskell">takeWhile</code> 或 <code class="haskell">dropWhile</code> 似乎和迴圈有密切關係。&shy;確實，利用 <code class="haskell">iterate</code> 與 <code class="haskell">dropWhile</code>，我們可定義出類似 <code class="haskell">while</code> 迴圈的操作：</p><pre><code class="haskell">until :: (a -&gt; Bool) -&gt; (a -&gt; a) -&gt; a -&gt; a
until p f = head . dropWhile (not . p) . iterate f
</code></pre><p><code class="haskell">until p f x</code> 由 <code class="haskell">x</code> 算出 <code class="haskell">f x</code>, 由 <code class="haskell">f x</code> 算出 <code class="haskell">f (f x)</code> ...&shy;直到 <code class="haskell">p (f (f .. x))</code> 成立為止。例：&shy;<code class="haskell">until ((&gt; 50) . square) (1+) 0</code> 得到 <code class="haskell">8</code>, 因為 $8^2 = 64$,&shy;是第一個平方大於 $50$ 的非負整數。&shy;由於惰性求值，<code class="haskell">iterate f</code> 在意義上雖然是個無窮串列，&shy;但只會被執行到 <code class="haskell">dropWhile (not . p)</code> 擷取的長度為止。</p><p>下述函數則實作了用輾轉相減法求最大公因數的古典演算法。函數 <code class="haskell">minus</code> 不斷&shy;將大數減去小數，直到兩數相等為止：</p><pre><code class="haskell">gcd :: (Int × Int) -&gt; Int
gcd = fst . until (uncurry (==)) minus 
  where minus (x,y)  | x &gt; y = (y, x-y)
                     | x &lt; y = (y-x, x) 
</code></pre><p>關於 <code class="haskell">uncurry</code> 詳見第頁。</p></div><div class="exlist"><div class="exercise exer" id="ex:squaresUpTo"><h5 class="exercise-title">練習 1.13 </h5><p>試定義一個函數&shy;<code class="haskell">squaresUpTo :: Int -&gt; List Int</code>, 使得 <code class="haskell">squaresUpTo n</code> 傳回&shy;所有不大於 <code class="haskell">n</code> 的平方數。例：<code class="haskell">squaresUpTo 10 = [1,4,9]</code>,&shy;<code class="haskell">squaresUpTo (-1) = []</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-13" type="checkbox"/><label class="lbl-toggle" for="ans-1-13">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">squaresUpTo :: Int -&gt; List Int
squaresUpTo n = takeWhile (&lt;= n) (map square [0..]) 
</code></pre></div></div></div><p><b>拉鍊</b> &emsp;&shy;函數 <code class="haskell">zip :: List a -&gt; List b -&gt; List (a × b)</code> 的作用可由下述例子示範：</p><pre><code class="spec">zip [1,2,3]  "abc"  = [(1,'a'), (2,'b'), (3,'c')] 
zip [1,2]    "abc"  = [(1,'a'), (2,'b')] 
zip [1,2,3]  "ab"   = [(1,'a'), (2,'b')] 
zip [1..]    "abc"  = [(1,'a'), (2,'b'), (3,'c')] 
zip [1..]    [2..]  = [(1,2), (2,3), (3,4) ..] 
</code></pre><p><code class="haskell">zip xs ys</code> 將串列 <code class="haskell">xs</code> 與 <code class="haskell">ys</code> 相對應的元素放在序對中。&shy;如果兩個串列長度不同，<code class="haskell">zip</code> 將其中一個用完後即停止。&shy;<code class="haskell">zip</code> 也能處理無限長的串列。&shy;由於這個動作看來像是把<code class="haskell">xs</code>與<code class="haskell">ys</code>當作拉鍊的兩側「拉起來」，因此用拉拉鍊的狀聲詞 ``zip'' 命名。</p><p>相對地，也有一個函數 <code class="haskell">unzip :: List (a × b) -&gt; (List a × List b)</code>，&shy;將「拉鍊」拉開。例：<code class="haskell">unzip [(1,'a'), (2,'b'), (3,'c')]</code> 可得到&shy;<code class="haskell">([1,2,3],"abc")</code>.</p><p>許多情況下，我們不想要把兩兩對應的元素放到序對中，而是分別餵給一個二元運算子。&shy;這時可用另一個相關函數 <code class="haskell">zipWith</code>, 例：&shy;<code class="haskell">zipWith (+) [1,2,3] [4,5,6] = [5,7,9]</code>&shy;函數 <code class="haskell">zipWith</code> 可以這樣定義：</p><pre><code class="spec">zipWith :: (a -&gt; b -&gt; c) -&gt; List a -&gt; List b -&gt; List c
zipWith f = map (uncurry f) . zip 
</code></pre><div class="exlist"><div class="exercise exer" id="ex:zipWith-defn-zip"><h5 class="exercise-title">練習 1.14 </h5><p>用 <code class="haskell">zipWith</code> 定義 <code class="haskell">zip</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-14" type="checkbox"/><label class="lbl-toggle" for="ans-1-14">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>\Answer <code class="haskell">zip = zipWith (,)</code>, 或 <code class="haskell">zip = zipWith (\x y -&gt; (x,y))</code>.</p></div></div></div><div class="theorem" id="eg:positions"><h5 class="theorem-title">例 1.26  </h5><p>試定義函數 <code class="haskell">positions :: Char -&gt; String -&gt; List Int</code>, 使得&shy;<code class="haskell">positions z xs</code> 傳回 <code class="haskell">z</code> 在 <code class="haskell">xs</code> 中出現的所有位置。&shy;例：<code class="haskell">positions 'o' "hoola hooligans" = [1,2,7,8]</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-14" type="checkbox"/><label class="lbl-toggle" for="ans-1-14">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>一種可能寫法如下：</p><pre><code class="haskell">positions z = map fst . filter ((==z) . snd) . zip [0..] 
</code></pre><p>我們用 <code class="haskell">zip [0..]</code> 為輸入串列標上位置，用 <code class="haskell">filter ((==z) . snd)</code>&shy;取出第二個元素等於 <code class="haskell">z</code> 的序對，最後用 <code class="haskell">map fst</code> 取出所有位置。&shy;注意函數合成與 currying 的使用。</p></div></div><div class="theorem" id="eg:positions-fst"><h5 class="theorem-title">例 1.27  </h5><p>接續上例。如果我們僅想要 <code class="haskell">z</code> 出現的第一個位置呢？我們可以定義：</p><pre><code class="spec">pos :: Char -&gt; String -&gt; Int
pos z = head . positions z 
</code></pre><p>這是一個部分函數，<code class="haskell">pos z xs</code> 傳回 <code class="haskell">positions z xs</code> 的第一個結果。&shy;如果 <code class="haskell">z</code> 沒有出現，<code class="haskell">positions z xs</code> 傳回 <code class="haskell">[]</code>, <code class="haskell">pos z xs</code>&shy;會得到執行期錯誤。如果 <code class="haskell">z</code> 出現在 <code class="haskell">xs</code> 中，由於惰性求值，<code class="haskell">pos</code>&shy;得到第一個位置後 <code class="haskell">positions</code> 便會停下，不會把串列整個產生。</p><p>如果我們希望 <code class="haskell">pos</code> 在 <code class="haskell">z</code> 沒有出現時傳回 <code class="haskell">-1</code>, 可以這麼做：</p><pre><code class="spec">pos :: Char -&gt; String -&gt; Int
pos z xs = case positions z xs of
            []      -&gt; -1
            (i:is)  -&gt; i 
</code></pre></div><h2 class="section" id="sec:wholemeal">1.9 全麥編程</h2><p>讀者至此應已注意到本章採用的特殊編程風格。&shy;一般說到串列，大家會先想到資料結構課程中常提到的連結串列(linked list)。&shy;介紹連結串列的範例程式大多用迴圈或遞迴追蹤著指標，一個一個地處理串列中的元素。&shy;在指令式語言中做關於陣列的操作時，也常用變數或指標指著「目前的」元素，&shy;並在一個迴圈中將該變數逐次遞增或減。&shy;總之，我們處理聚合型資料結構時，總是將其中元素一個個取出來處理。&shy;但本章的做法不同：我們將整個串列視為一個整體，對整個串列做 <code class="haskell">map</code>, <code class="haskell">filter</code>, <code class="haskell">dropWhile</code> 等動作，或將它和另一個串列整個 <code class="haskell">zip</code> 起來...。</p><p>這種編程方式被稱作<em>全麥編程</em>(<em>wholemeal programming</em>)，<span id="ix-1-48"></span>&shy;第<a href="Basics.html#sec:refs-basics">1.11 </a>節中將解釋此詞的由來。&shy;全麥編程的提倡者們認為：一個個地處理元素太瑣碎，而鼓勵我們拉遠些，&shy;使用組件，以更抽象的方式組織程式的結構。</p><p>諸如 <code class="haskell">map</code>, <code class="haskell">filter</code>, <code class="haskell">iterate</code>, <code class="haskell">zipWith</code> 等等組件其實都是常見的編程模式。&shy;它們可被視為<em>為了特定目的已先寫好的迴圈</em>。&shy;拜高階函數與惰性求值之賜，這些組件能容易地被重用在許多不同脈絡中。&shy;這麼做的好處之一是：諸如 <code class="haskell">map</code>, <code class="haskell">filter</code>, <code class="haskell">zip</code> 等組件的意義清楚，&shy;整個程式的意義也因此會比起自行在迴圈中一個個處理元素來得容易理解。&shy;事實上，這麼做可以養成我們思考演算法的新習慣。&shy;一些常見的編程模式現在是有名字的，我們<em>把編程模式抽象出來</em>了。&shy;而如同第<a href="Introduction.html#ch:intro">0 </a>章所述，抽象化是我們理解、掌握、操作事物的重要方法。&shy;我們現在有了更多詞彙去理解、討論程式與演算法：&shy;「這個演算法其實就是先做個 <code class="haskell">map</code>，把結果 <code class="haskell">concat</code> 起來，然後做 <code class="haskell">filter</code>...」</p><p>在本書其他章節中我們也將看到：這些抽象化方便我們去操作、轉換程式。&shy;具體說來，如果程式用這些組件拼湊成，我們對這些組件知道的性質都可用在我們的程式上。&shy;例如，如果我們知道 <code class="haskell">map f . map g = map (f . g)</code>，&shy;當我們看到程式中有兩個相鄰的 <code class="haskell">map</code>, 我們可用已知的性質把他們合併成一個 ---&shy;這相當於合併兩個迴圈。或著我們可以把一個 <code class="haskell">map</code> 拆成兩個，以方便後續的其他處理。&shy;程式的建構方法使得程式含有更多資訊，使我們有更多可操作的空間。</p><p>全麥編程之所以成為可能，有賴程式語言的支援。&shy;例如，高階函數使得我們能將與特定問題相關的部分&shy;（如 <code class="haskell">map f</code> 與 <code class="haskell">filter p</code> 中的 <code class="haskell">f</code> 與 <code class="haskell">p</code>）抽象出來；&shy;惰性求值使我們勇於使用大串列或無限串列作為中間值，不用擔心它們被不必要地真正算出。</p><p>此外，全麥編程也需要豐富的組件函式庫。設計良好的組件捕捉了常見的編程模式，&shy;有了它們的幫忙，我們的程式可寫得簡潔明暸 ---&shy;本章之中大部分的程式都是都是一行搞定的 ``one-liner''.&shy;但，這些組件不可能窮舉所有的編程模式。我們仍會需要自行從頭寫些函數。&shy;受到全麥編程影響，在自行寫函數時，我們也常會希望將它們寫得更通用些，&shy;藉此發現常見的編程模式，設計出可重用的組件。</p><p>全麥編程能寫出多實用的程式？&shy;第<a href="Basics.html#sec:refs-basics">1.11 </a>節中會提及其他學者嘗試過的，包含解密碼、解數獨在內的有趣例子。&shy;在本節，我們則想示範一個小練習：由下至上的合併排序(merge sort)。&shy;<span id="ix-1-49"></span></p><p><b>合併排序</b> &emsp; 假設我們已有一個函數 <code class="haskell">merge' :: (List Int × List Int) -&gt; List Int</code>,&shy;如果 <code class="haskell">xs</code> 與 <code class="haskell">ys</code> 已經排序好，<code class="haskell">merge' (xs,ys)</code> 將它們合併為一個排序好的串列。%&shy;<input class="toggle" id="footnote-1-9-15" type="checkbox"/><label class="fnote-toggle" for="footnote-1-9-15">(註15) </label><span class="collapsible-footnote">之所以取名為 <code class="haskell">merge'</code>，因為在第<a href="Induction.html#sec:well-founded-induction">2.12 </a>節中我們將使用一個類似且相關的函數 <code class="haskell">merge :: List Int -&gt; List Int -&gt; List Int</code>.</span>&shy;函數 <code class="haskell">merge'</code> 可用第<a href="Induction.html#sec:lexicographic-induction">2.13 </a>節的方式歸納寫成，&shy;也可使用將在第\todo{where}章提及的組件 <code class="haskell">unfoldr</code> 做出。&shy;我們如何用 <code class="haskell">merge'</code> 將整個串列排序好呢？</p><p>一般書中較常提及由上至下的合併排序：&shy;將輸入串列（或陣列）切成長度大致相等的兩半，分別排序，然後合併。&shy;本節則以由下至上的方式試試看。&shy;如果輸入串列為<code class="haskell">[4,2,3,5,8,0,1,7]</code>，我們先把&shy;每個元素都單獨變成串列，也就是變成<code class="haskell">[[4],[2],[3],[5],[8],[0],[1],[7]]</code>。&shy;然後把相鄰的串列兩兩合併：<code class="haskell">[[2,4],[3,5],[8,0],[1,7]]</code>，&shy;再兩兩合併成為 <code class="haskell">[[2,3,4,5],[0,1,8,7]]</code>，&shy;直到只剩下一個大串列為止。</p><p>如果我們定義兩個輔助函數：<code class="haskell">wrap</code> 將一個元素包成一個串列，&shy;<code class="haskell">isSingle</code> 判斷一個串列是否只剩下一個元素，</p><div class="multicols"><div class="mcol" width="0.4\textwidth"><pre><code class="haskell">wrap :: a -&gt; List a
wrap x = [x] 
</code></pre></div><div class="mcol" width="0.4\textwidth"><pre><code class="haskell">isSingle :: List a -&gt; Bool
isSingle [x]  = True
isSingle xs   = False 
</code></pre></div></div><p>那麼上述的合併排序可以寫成：</p><pre><code class="spec">msort = head . until isSingle mergeAdj . map wrap 
</code></pre><p>這幾乎只是把口語描述逐句翻譯：先把每個元素都包成串列，&shy;反覆做 <code class="haskell">mergeAdj</code> 直到只剩下一個大串列，然後將那個大串列取出來。</p><p>下一項工作是定義 <code class="haskell">mergeAdj :: List (List Int) -&gt; List (List Int)</code>,&shy;其功能是將相鄰的串列兩兩合併。&shy;如果我們能訂出一個函數 <code class="haskell">adjs :: List a -&gt; List (a × a)</code>,&shy;將相鄰的元素放在序對中，<code class="haskell">mergeAdj</code> 就可以寫成：</p><pre><code class="spec">mergeAdj = map merge' . adjs 
</code></pre><p>但 <code class="haskell">adjs</code> 該怎麼定義呢？&shy;對大部分讀者來說，最自然的方式也許是用第<a href="Induction.html#ch:induction">2 </a>章將討論的歸納法。&shy;但作為練習，我們姑且用現有的組件試試看。&shy;先弄清楚我們對 <code class="haskell">adjs</code> 的期待。&shy;當 <code class="haskell">xs = [x0,x1,x2,x3]</code>, 我們希望&shy;<code class="haskell">adjs xs = [(x0,x1),(x2,x3)]</code>.&shy;但當 <code class="haskell">xs</code> 有奇數個元素時，例如 <code class="haskell">xs = [x0,x1,x2,x3,x4]</code>,&shy;最後一個元素 <code class="haskell">x4</code> 便落單了。&shy;如果是為了合併排序，我們也許可以把 <code class="haskell">x4</code> 和 <code class="haskell">[]</code> 放在一起，&shy;<code class="haskell">adjs xs = [(x0,x1),(x2,x3),(x4,[])]</code>.&shy;但為使 <code class="haskell">adjs</code> 適用於更多的情況，也許我們應該讓它多拿一個參數，&shy;當作落單的元素的配對。&shy;因此我們把 <code class="haskell">adjs</code> 的型別改為 <code class="haskell">a -&gt; List a -&gt; List (a × a)</code>,&shy;希望 <code class="haskell">adjs z xs = [(x0,x1),(x2,x3),(x4,z)]</code>.</p><p>我們試著看看這可如何辦到。</p><ul><li><p>首先，<code class="haskell">zip xs (tail xs)</code> 可把 <code class="haskell">xs</code> 的每個元素和其下一個放在序對中。&shy;例：當 <code class="haskell">xs = [x0,x1,x2,x3,x4]</code> 時，&shy;<code class="haskell">zip xs (tail xs)</code> 的值是 <code class="haskell">[(x0,x1),</code> <code class="haskell">(x1,x2),</code> <code class="haskell">(x2,x3),</code> <code class="haskell">(x3,x4)]</code>.</p></li><li><p>如果我們為 <code class="haskell">zip</code> 的第二個參數補上一個 <code class="haskell">z</code>,&shy;成為 <code class="haskell">zip xs (tail (xs ++ [z]))</code>，&shy;這可歸約為 <code class="haskell">[(x0,x1),(x1,x2),(x2,x3),(x3,x4),(x4,z)]</code>。</p></li><li><p>再將位置（由 <code class="haskell">0</code> 算起）為奇數的元素丟棄，我們便得到原先希望的&shy;<code class="haskell">[(x0,x1),(x2,x3),(x4,z)]</code> 了！</p></li></ul><p>讀者可試試看當 <code class="haskell">xs</code> 有偶數個元素時的情況。&shy;總之，<code class="haskell">adjs</code> 可定義成：</p><pre><code class="haskell">adjs ::  a -&gt; List a -&gt; List (a × a)
adjs z xs = everyother (zip xs (tail xs ++ [z])) 
</code></pre><p>其中 <code class="haskell">everyother ys</code> 把 <code class="haskell">ys</code> 中位置為奇數的元素丟棄。</p><p>最後，考慮如何把串列中位置為奇數的元素丟棄。&shy;一種做法是：一直從串列中丟掉頭兩個元素，直到串列用完：</p><pre><code class="haskell">everyother :: List a -&gt; List a
everyother = map head . takeWhile (not . null) . iterate (drop 2) 
</code></pre><p>總而言之，由下至上的合併排序可寫成：</p><pre><code class="haskell">msort :: List Int -&gt; List Int
msort = head . until isSingle mergeAdj . map wrap 
</code></pre><p>其中 <code class="haskell">mergeAdj</code> 的定義是：</p><pre><code class="haskell">mergeAdj :: List (List Int) -&gt; List (List Int)
mergeAdj = map merge' . adjs [] 
</code></pre><p>如果我們想看到合併排序完成前的每一步驟，可將 <code class="haskell">msort</code> 中&shy;（以 <code class="haskell">iterate</code> 與 <code class="haskell">dropWhile</code> 定義出）的 <code class="haskell">until</code>&shy;改為 <code class="haskell">iterate</code> 與 <code class="haskell">takeWhile</code>:</p><pre><code class="haskell">msortSteps :: List Int -&gt; List (List (List Int))
msortSteps = takeWhile (not . isSingle) . iterate mergeAdj . map wrap 
</code></pre><p>例如，<code class="haskell">msortSteps [9,2,5,3,6,4,7,0,5,1,8,2,3,1]</code> 可得到</p><pre><code class="spec">[  [[9],[2],[5],[3],[6],[4],[7],[0],[5],[1],[8],[2],[3],[1]],
   [[2,9],[3,5],[4,6],[0,7],[1,5],[2,8],[1,3]],
   [[2,3,5,9],[0,4,6,7],[1,2,5,8],[1,3]],
   [[0,2,3,4,5,6,7,9],[1,1,2,3,5,8]]] 
</code></pre><p>最後兩個串列合併為 <code class="haskell">[0,1,1,2,2,3,3,4,5,5,6,7,8,9]</code>，即為 <code class="haskell">msort</code> 的結果。</p><h2 class="section" id="sec:user-defined-data">1.10 自訂資料型別</h2><p>本章目前為止給讀者看到的 <code class="haskell">data</code> 定義其實都是 Haskell 已內建的型別。&shy;使用者也可自己定義新資料型別。&shy;例如，我們可能定義一個新型別表達四個方向：</p><pre><code class="spec">data Direction = North | East | South | West 
</code></pre><p>或著定義一個表示顏色的型別，用三個浮點數表達紅、綠、藍的比例：</p><pre><code class="haskell">data RGBColor = RGB Float Float Float 
</code></pre><p>例：土耳其藍(turquoise)可寫成 <code class="haskell">RGB 0.25 0.875 0.8125</code>.&shy;下列函數則降低一個顏色的彩度：&shy;<input class="toggle" id="footnote-1-10-16" type="checkbox"/><label class="fnote-toggle" for="footnote-1-10-16">(註16) </label><span class="collapsible-footnote">這是一個簡便的做法：算出該顏色的灰度 <code class="haskell">gr</code>,&shy;然後計算每個原色與該灰度的線性內插。&shy;更準確的作法應將 RGB 轉成 HSV，以後者調整飽和度。</span></p><pre><code class="haskell">desaturate :: Float -&gt; RGBColor -&gt; RGBColor
desaturate p (RGB r g b) =
    RGB  (r +. p *. (gr -. r)) (g +. p *. (gr -. g)) (b +. p *. (gr -. b)) 
  where gr = r *. 0.299 +. g *. 0.587 +. b *. 0.144 
</code></pre><p>我們也可定義如 <code class="haskell">List</code> 一樣的遞迴資料型別。&shy;例如，資料結構中可能談到兩種二元樹狀結構，一種僅在內部節點有標示（稱作 internally labelled），另一種僅在葉節點有表示（稱作 externally labelled）。&shy;這兩種二元樹可分別表示如下：</p><pre><code class="haskell">data ITree a  = Null | Node a (ITree a) (ITree a) 
data ETree a  = Tip a | Bin (ETree a) (ETree a) 
</code></pre><p>怎麼編寫這種資料結構上的程式呢？我們將在下一章中說到。</p><h2 class="section" id="sec:refs-basics">1.11 參考資料</h2><p>本章中的許多想法取自 <a href="Biblio.html#Bird:98:Introduction">Bird [1998]</a> ，該書是我相當推薦的 Haskell 教材。</p><div class="infobox infobox" title="Haskell 為何叫 Haskell?"><h5 class="infobox-title">Haskell 為何叫 Haskell?</h5><p>1980 年代中期，程式語言學者們已各自開發出了許多個語法、語意類似但卻稍有不同、大都只在出生機構被使用的惰性純函數語言。沒有一個語言取得壓倒性的優勢。&shy;為溝通方便、以及為了讓整個領域能走向下一步，大家有了該設計個統合、共通的惰性純函數語言的共識。&shy;1988年一月，新語言設計小組在耶魯大學開會，眾多討論項目中包括幫語言取個名字。&shy;以下軼事節錄自 <a href="Biblio.html#Hudak:07:Being">Hudak et al. [2007]</a> .</p><p>當天被提出的選項包括 Haskell, Vivaldi, Mozart, CFL (Common Functional Language), Curry, Frege, Peano, Nice, Fun, Light...等等。最後經程序選出的名字是 ``Curry'', 紀念邏輯學家 Haskell B. Curry --- 他在組件邏輯(combinatorial logic)、Curry-Howard 同構等領域的研究一直深遠影響函數語言學界。</p><p>但當天晚上就有人覺得這名字會招惹太多雙關語笑話。除了咖哩之外，小組成員覺得實在不行的是：TIM (three instruction machine) 是函數語言用的一種抽象機器，但 Tim Curry 則成了電影洛基恐怖秀（Rocky Horror Picture Show, 1975）的男主角。</p><p>於是新語言的名字就改成 Haskell 了。</p><p>小組成員 Paul Hudak 和 David Wise 寫信給 Curry 的遺孀 Virginia Curry，徵求她的同意。Hudak 後來親自登門拜訪，Virginia Curry 和他聊了之前的訪客（包含 Church 與 Kleene）的故事；後來她也去聽了 Hudak 關於 Haskell （語言）的演講，表現得十分友善。臨別前，她說：「其實呀，Haskell 一直都不喜歡他的名字。」</p></div><p><b>Currying</b> &emsp;&shy;Moses  <a href="Biblio.html#Schonfinkel:24:Uber">[Sch{\"{o}}nfinkel 1924]</a> 提出多參數函數可用單參數函數表達。&shy;Haskell Curry 在許多著作中（例：<a href="Biblio.html#Curry:80:Some">Curry [1980]</a> ）使用 currying，&shy;但當時並沒有 currying 一詞。&shy;為何此概念最後會以 Curry 命名呢？&shy;David A. Turner （Haskell 語言的前身之一 Miranda 的設計人）&shy;在一次網路討論  <a href="Biblio.html#Sankar:97:Currying">[Sankar et al. 1997]</a> 中表示 currying 一詞由&shy;Christopher Strachey 取名，於 1967 年前後使用在其上課資料中。&shy;這種說法目前廣被大家接受，但我目前尚未找可佐證的上課資料。&shy;相反地，<a href="Biblio.html#Strachey:67:Fundamental">Strachey [1967]</a> 之中明確表示他認為 currying&shy;的概念是由 Sch\"{o}nfinkel 發明的，並稱之為「Sch\"{o}nfinkel 的裝置」。&shy;<input class="toggle" id="footnote-1-11-17" type="checkbox"/><label class="fnote-toggle" for="footnote-1-11-17">(註17) </label><span class="collapsible-footnote">原文：``There is a device originated by Sch\"{o}nfinkel,&shy;for reducing operators with several operands to the successive application of single operand operators.''</span>&shy;但 currying 的想法可追溯得比 Sch\"{o}nfinkel 或 Curry 都早。&shy;F. L. Gottlob Frege 1891 年的&shy;\"{U}ber Funktion und Begriff (英譯 Function and Concept)&shy; <a href="Biblio.html#Frege:60:Function">[Frege 1960]</a> 結尾幾頁的概念即是 currying.</p><p><b>全麥編程</b> &emsp;&shy;「全麥編程」一詞由牛津大學 Geraint Jones 取名，由來可能是模仿健康食物的說詞。&shy;如 <a href="Biblio.html#Bird:10:Pearls">Bird [2010, 第19章]</a> 便寫道，「全麥編程好處多多，可預防『索引症』(indexitis)，鼓勵合法的程式建構。」&shy;在該章之中，Richard Bird 以大量使用串列組件函數的全麥編程為起點，&shy;推導出能相當迅速地解數獨的程式。&shy;<a href="Biblio.html#Hinze:09:La">Hinze [2009]</a> 以全麥編程為工具，示範了河內塔問題(Tower of Hanoi)&shy;的許多性質，以及其與謝爾賓斯基(Sierpi\'{n}ski)三角形的關係。&shy;其中寫道「函數語言擅長全麥編程。這個詞彙由 Geraint Jones 命名。&shy;全麥編程意謂由大處去想：處理整個串列，而不是一連串的元素；發展出整個解答的空間，而不是個別的解答；想像整個圖，而不是單一的路徑。對於已知的問題，全麥編程常給我們新洞察與新觀點。」&shy;<a href="Biblio.html#Hutton:16:Programming">Hutton [2016, 第五章]</a> 則以編、解密碼為例。&shy;<em>凱撒加密</em>(<em>Caesar cipher</em>)為一種簡單的加密方式：&shy;將明文中的每個字母都往前或後偏移固定的量，例如當偏移量為 <code class="haskell">2</code> 時， <code class="haskell">'a'</code> 變成 <code class="haskell">'c'</code>，&shy;<code class="haskell">'b'</code> 變成 <code class="haskell">'d'</code> ... 一種解凱撒密碼的有效方式是計算密文中每個字母的分佈，和一般英文文章中的平均字母分佈做比較，藉以猜出偏移量。Graham Hutton 在書中示範如何用組件函數、完全不用遞迴地寫出編碼與解碼程式。以上都是相當值得一看的例子。</p><p><b>LISP 的串列</b> &emsp;&shy;誕生於 1958 年的 LISP <span id="ix-1-50"></span> 是目前仍被使用的高階程式語言中歷史第二悠久的 --- 最早的是 FORTRAN.&shy;但 LISP 與 FORTRAN 是風格截然不同的語言。&shy;雖然具有含副作用的指令，LISP 仍被認為是函數語言的先驅。</p><p>LISP 為「串列處理(list processing)」的縮寫。&shy;但事實上，LISP 中的聚合資料結構「<code class="haskell">S</code> 算式 (S-expression)」不只可用來表達串列。&shy;<code class="haskell">CONS</code> 函數做出的是一個序對，&shy;其中第一個元素被稱作 <code class="haskell">CAR</code> (contents of the address part of register),&shy;第二個稱作 <code class="haskell">CDR</code> (contents of the decrement part of register).&shy;如果 <code class="haskell">CDR</code> 的部分仍是一個 <code class="haskell">CONS</code> 做出的序對，或是特殊值 <code class="haskell">NIL</code>,&shy;整個結構表達的就是一個串列。&shy;<code class="haskell">S</code> 算式也可用來做出二元樹、語法樹... 等等。&shy;Haskell 串列的建構元 <code class="haskell">[]</code> 可唸成 <code>nil'', |(:)| 唸成</code>cons'', 這兩個詞彙都從 LISP 而來。</p><p>在前幾波人工智慧熱潮時，大家認為符號與邏輯的處理是人工智慧的基礎。&shy;但早期的程式語言大多針對數值運算而設計，會處理串列的 LISP 便被視為最適合做符號處理的語言 ---「人工智慧用的語言」。&shy;另一個被視為「人工智慧專用語言」的是奠基於述語邏輯與歸結(resolution)&shy;<span id="ix-1-51"></span>&shy;的 PROLOG.&shy;今日的人工智慧技術以神經網路為基礎，「人工智慧專用語言」的頭銜則給了 Python。</p></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
