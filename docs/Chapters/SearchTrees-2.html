<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" checked type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" checked type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:induction-search-trees">3 搜尋樹</h1></div><div class="navi"><div class="previous">&laquo;<a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></div><div class="next"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:induction-red-black-tree">3.2 紅黑樹</h2><p>在二元搜尋樹的基礎上，<em>紅黑樹</em>(<em>red-black tree</em>)<span id="ix-3-2"></span>多加了個屬性：每個節點都是紅色或黑色之一。
表示成 Haskell 資料結構如下：</p><pre><code class="hasekell">data RBTree = E  | R RBTree Int RBTree
                 | B RBTree Int RBTree 
</code></pre><p>其中 <code class="haskell">E</code> 為沒有資料的葉節點，<code class="haskell">R</code> 為紅色內部節點，<code class="haskell">B</code> 為黑色內部節點 --- 葉節點 <code class="haskell">E</code> 被視為黑色的。
定義 <code class="haskell">data Color = Red | Blk</code>, 下述定義的 <code class="haskell">color t</code> 傳回 <code class="haskell">t</code> 的根部節點的顏色：</p><pre><code class="haskell">color :: RBTree -&gt; Color
color E          = Blk
color (R _ _ _)  = Red
color (B _ _ _)  = Blk 
</code></pre><p>我們要求紅黑樹滿足下列性質：</p><ol><li><p>紅黑樹也是二元搜尋樹，意即它得是有序的。</p></li><li><p>從根部開始到每個葉節點 <code class="haskell">E</code> 的路徑上的黑節點數目均相同。我們說這樣的一棵樹是<em>平衡</em>的。</p></li><li><p>紅節點的兩個子代都必須是黑色的，黑節點則無此限制。為方便說明，我們把滿足此條件的樹稱為<em>準紅黑樹</em>。</p></li><li><p>根節點為黑色的。</p></li></ol><p>其中，關於有序性的討論和前一節原則上相同，此節將之省略。我們假設存在某函數 <code class="haskell">sorted :: RBTree -&gt; Bool</code> 判斷一棵紅黑樹是否有序。
我們看看其他性質如何形式化。</p><p>首先，函數 <code class="haskell">bheight</code> 定義一棵樹的「黑高度」 --- 所有路徑上黑色節點的最多數目：</p><pre><code class="haskell">bheight :: RBTree -&gt; Nat
bheight E          = 0
bheight (R t x u)  = bheight t ↑ bheight u
bheight (B t x u)  = 1 + (bheight t ↑ bheight u) 
</code></pre><p>說一棵樹「平衡」意指每個內節點中，兩個子樹的黑高度均相等。</p><pre><code class="haskell">balanced :: RBTree -&gt; Bool
balanced E          =  True
balanced (R t x u)  =  bheight t == bheight u ⋀ balanced t ⋀ balanced u
balanced (B t x u)  =  bheight t == bheight u ⋀ balanced t ⋀ balanced u 
</code></pre><p>函數 <code class="haskell">semiRB</code> 檢查一棵樹是否為準紅黑 --- 紅節點的兩棵子樹均為黑色：</p><pre><code class="haskell">semiRB :: RBTree -&gt; Bool
semiRB E          =  True
semiRB (B t x u)  =  semiRB t ⋀ semiRB u
semiRB (R t x u)  =  color t == Blk ⋀ color u == Blk ⋀ semiRB t ⋀ semiRB u
</code></pre><p>最後，如前所述，紅黑樹需滿足 <code class="haskell">sorted</code>, <code class="haskell">balanced</code>, <code class="haskell">semiRB</code>, 並且根節點須為黑色：</p><pre><code class="spec">redBlack :: RBTree -&gt; Bool
redBlack t =  sorted t ⋀ balanced t ⋀ semiRB t ⋀ color t == Blk 
</code></pre><p>在這樣一棵二元樹中，由於 <code class="haskell">balanced</code> 被滿足，每條路徑上的黑節點數目均相同；由於 <code class="haskell">semiRB</code> 被滿足，紅節點不會連續出現。因此最長路徑之長度不超過最短路徑的兩倍。在這樣的樹中做二元搜尋，總會在 $O(\log n)$ 的時間內找到資料或走到葉節點。</p><h3 class="subsection">3.2.1 紅黑樹插入</h3><p>在紅黑樹中插入元素的方式最初和二元搜尋樹相同：一邊搜尋一邊往下走，如果我們碰到 <code class="haskell">E</code>, 便是插入新元素之處。新元素總在邊緣被插入，而樹的有序性仍保持著。</p><p>新加入的節點該是什麼顏色呢？讓新節點為紅色可能是個合理選擇。如此一來，插入新元素不會改變一棵樹的黑高度，也因此如果該樹原本是平衡的，加入新節點後的新樹仍是平衡的。</p><p>但這麼做可能破壞準紅黑性質：路徑上有可能出現兩個連續的紅節點。
因此我們在插入後的<em>回程</em>途中適時做<em>旋轉</em>，如圖[RefUndefined]所示。
每當我們看到一個黑節點之下有兩個連續的紅節點，必定是圖中四個角落的四種情形之一（我們只插入了一個元素，最多只有一個多出的紅節點。圖中 <code class="haskell">s</code>, <code class="haskell">t</code>, <code class="haskell">u</code>, 與 <code class="haskell">v</code> 仍是平衡的準紅黑樹）。
我們將每個情形都旋轉成圖中央的情況。
如此一來圖中央以 <code class="haskell">x</code>, <code class="haskell">z</code> 為根部的兩顆子樹都是黑根部的紅黑樹，<code class="haskell">y</code> 是紅節點。
於是我們再往上檢查，如果又出現四種情況之一就再旋轉，否則往上重建路徑，直到回到根部。
如此做出一棵滿足準紅黑性質的樹。
最後，如果根部節點為紅色，便直接改成黑色。</p><div class="figure top" id="fig:red-black-rotate" title="在紅黑樹中插入新元素後做的四種旋轉。"><center></center></div><p>我們看看前述的插入演算法可如何表示為 Haskell 程式。
我們將主要執行插入與旋轉的函數稱為 <code class="haskell">ins :: Int -&gt; RBTree -&gt; RBTree</code>.
函數 <code class="haskell">insert</code> 則在呼叫 <code class="haskell">ins</code> 之後將樹根改為黑色的：</p><pre><code class="haskell">insert :: Int -&gt; RBTree -&gt; RBTree
insert k t = blacken (ins k t) 
  where  blacken (R t x u) = B t x u
         blacken t = t 
</code></pre><div class="infobox infobox" title="紅黑樹旋轉只需四種情況"><h5 class="infobox-title">紅黑樹旋轉只需四種情況</h5><p>本節的的紅黑樹旋轉方式來自 <a href="../Biblio.html#Okasaki:99:RedBlack">Okasaki [1999]</a>。
熟悉資料結構的讀者可能發現它們比一般教科書或網路資源中的處理方式簡單許多：
一般資料中常會分出八種以上的狀況，除了主要路徑上的三個節點，也會考慮其兄弟節點的顏色。</p><p>Okasaki 發現只需本節的這四種情況就足夠了。
讀者也應可發現，採用較簡單的版本，對於證明以及暸解紅黑樹的性質幫助很大。</p><p>那麼，為何一般教科書會用上那麼多情況呢？
Okasaki 認為可能是效率考量。
一般書中的版本中，有些情況可不需旋轉，只直接改變節點顏色。
如此一來需要更動的欄位數目較少。
有些情況中轉出的樹根部已是黑色的。在指令式語言中，此時該程序就可以直接結束。</p><p>然而，在函數語言中，我們無論如何都需重建整個路徑上的節點。
因此上述優點均不明顯。
另一方面，Okasaki 也認為此種情況較少的版本是比較適合用於教學中的。</p></div><p>函數 <code class="haskell">ins</code> 在遇上紅節點（<code class="haskell">R t x u</code>）時和第<a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 </a>中的 <code class="haskell">insert</code> 很類似：比較 <code class="haskell">k</code> 與 <code class="haskell">x</code> 以決定該往哪邊插入，
並在歸納呼叫後以 <code class="haskell">R</code> 重做節點。
但遇到黑節點 <code class="haskell">B t x u</code> 時，我們不使用 <code class="haskell">B</code>, 而是額外呼叫 <code class="haskell">rotate</code> 函數：</p><pre><code class="haskell">ins :: Int -&gt; RBTree -&gt; RBTree
ins k E = R E k E
ins k (R t x u)  | k &lt;  x  = R (ins k t) x u
                 | k == x  = R t x u
                 | k &gt;  x  = R t x (ins k u)
ins k (B t x u)  | k &lt;  x  = rotate (ins k t) x u
                 | k == x  = B t x u
                 | k &gt;  x  = rotate t x (ins k u) 
</code></pre><p>回顧：圖[RefUndefined]的四種旋轉都只在根節點為黑色時啟動，因此我們也只在碰上黑節點時呼叫 <code class="haskell">rotate</code>。
在 <code class="haskell">rotate s x t</code> 之中，<code class="haskell">s</code> 為目前的左子樹，<code class="haskell">x</code> 為目前的（黑色）節點中的標籤，
<code class="haskell">t</code> 則為目前的右子樹。
函數 <code class="haskell">rotate</code> 的定義如下：</p><pre><code class="haskell">rotate :: RBTree a -&gt; a -&gt; RBTree a -&gt; RBTree a
rotate (R (R s x t) y u) z v  = R (B s x t) y (B u z v)
rotate (R s x (R t y u)) z v  = R (B s x t) y (B u z v)
rotate s x (R (R t y u) z v)  = R (B s x t) y (B u z v)
rotate s x (R t y (R u z v))  = R (B s x t) y (B u z v)
rotate s x t = B s x t 
</code></pre><p>其中，前四個情況的左邊分別對應到圖[RefUndefined]的四個情況；他們的右手邊都是一樣的，對應到圖[RefUndefined]正中央的樹。
最後的 <code class="haskell">rotate s x t</code> 則是四種情況之外、不用旋轉的情形。</p><h3 class="subsection">3.2.2 紅黑樹之性質：高度</h3><p>許多討論紅黑樹的教材在將插入、刪除等等操作的實作呈現讀者看過之後就結束了，
對於其性質的討論意外地不完整。
然而，這類資料結構之所以有效，正因為它們需有的性質一直被保持著。
談資料結構上的操作卻不證明它們怎麼維護資料結構的性質，可說是缺了最重要的一塊。
本章剩下的篇幅中，我們將描述並證明紅黑樹的一些主要性質。</p><p>首先我們談談黑高度。
讀者稍加嘗試之後會發現，<code class="haskell">insert k t</code> 有時會增加 <code class="haskell">t</code> 的黑高度，有時不會。
我們怎知道紅黑樹何時會長高呢？</p><p>原來，函數 <code class="haskell">ins</code> 其實是不會讓樹長高的！我們有如下的定理 --- <code class="haskell">ins k</code> 前後樹的黑高度不變：</p><div class="theorem" id="thm:redblack-bheight-ins"><h5 class="theorem-title">定理 3.2  </h5><p>對所有 <code class="haskell">k</code> 與 <code class="haskell">t</code>, <code class="haskell">bheight (ins k t) = bheight t</code>.</p></div><p>函數 <code class="haskell">insert k t</code> 呼叫 <code class="haskell">ins k t</code>, 得到的樹仍有原來的黑高度。
如果 <code class="haskell">blacken</code> 把樹由紅轉黑，新樹的黑高度才因此加一。
否則樹的黑高度仍不變。</p><div class="theorem" id="thm:redblack-bheight-insert"><h5 class="theorem-title">系理 3.3  </h5><p>對所有 <code class="haskell">k</code> 與 <code class="haskell">t</code>，如果 <code class="haskell">ins k t</code> 為黑色，
<code class="haskell">bheight (insert k t) = bheight t</code>.
否則 <code class="haskell">bheight (insert k t) = 1 + bheight t</code>.</p></div><p>我們將嘗試證明定理<a href="#thm:redblack-bheight-ins">3.2 </a>.
回顧我們的原則：<em>證明的結構依循程式的結構</em>。
由於 <code class="haskell">insert</code> 呼叫 <code class="haskell">ins</code>, 欲證明關於 <code class="haskell">insert</code> 的系理 <a href="#thm:redblack-bheight-insert">3.3 </a>，
我們需要關於 <code class="haskell">ins</code> 的定理 <a href="#thm:redblack-bheight-ins">3.2 </a>.
同樣地，由於 <code class="haskell">ins</code> 呼叫 <code class="haskell">rotate</code>, 欲證明定理 <a href="#thm:redblack-bheight-ins">3.2 </a>,
我們需要一個關於 <code class="haskell">rotate</code> 的引裡：</p><div class="theorem" id="lma:redblack-bheight-rotate"><h5 class="theorem-title">引理 3.4  </h5><p>對所有 <code class="haskell">t</code>, <code class="haskell">u</code> 與 <code class="haskell">z</code>,
<code class="haskell">bheight (rotate t z u) = 1 + (bheight t ↑ bheight u)</code>.</p></div><p>這也不意外：<code class="haskell">rotate</code> 的兩個參數 <code class="haskell">t</code> 與 <code class="haskell">u</code> 原本在黑節點之下，旋轉後的黑高度不變，仍是 <code class="haskell">1 + (bheight t ↑ bheight u)</code>.</p><p>以下我們證明定理<a href="#thm:redblack-bheight-ins">3.2 </a>.</p><div class="proof"><b>證明 </b><p>在 <code class="haskell">t</code> 之上做歸納。以下只列出幾個代表性狀況。</p><p><strong>狀況</strong> <code class="haskell">t := E</code>.</p><pre><code class="spec">   bheight (ins k E)
=  bheight (R E k E)
=  0
=  bheight E 
</code></pre><p><strong>狀況</strong> <code class="haskell">t := R t x u</code>, <code class="haskell">k &lt;  x</code>:</p><pre><code class="spec">   bheight (ins k (R t x u))
=    <comment>{- <code class="haskell">ins</code> 之定義；<code class="haskell">k &lt; x</code> -}</comment>
   bheight (R (ins k t) x u)
=    <comment>{- <code class="haskell">bheight</code> 之定義 -}</comment>
   bheight (ins k t) ↑ bheight u
=    <comment>{- 歸納假設 -}</comment>
   bheight t ↑ bheight u
=    <comment>{- <code class="haskell">bheight</code> 之定義 -}</comment>
   bheight (R t x u) 
</code></pre><p><strong>狀況</strong> <code class="haskell">t := B t x u</code>, <code class="haskell">k &lt;  x</code>:</p><pre><code class="spec">   bheight (ins k (B t x u))
=    <comment>{- <code class="haskell">ins</code> 之定義；<code class="haskell">k &lt; x</code> -}</comment>
   bheight (balance (ins k t) x u)
=    <comment>{- 引理 \ref{lma:redblack-bheight-rotate} -}</comment>
   1 + (bheight (ins k t) ↑ bheight u)
=    <comment>{- 歸納假設 -}</comment>
   1 + (bheight t ↑ bheight u)
=    <comment>{- <code class="haskell">bheight</code> 之定義 -}</comment>
   bheight (B t x u) 
</code></pre></div><p>為求完整，我們也簡述引理<a href="#lma:redblack-bheight-rotate">3.4 </a>之證明：</p><div class="proof"><b>證明 </b><p>由於 <code class="haskell">rotate</code> 沒有遞迴、不呼叫其他函數，但有許多狀況，
關於 <code class="haskell">rotate</code> 的證明也大都僅是檢查每個情況，雖不難但可能很繁瑣。
以下只舉一種狀況為例。</p><p><strong>狀況</strong> <code class="haskell">(t,z,u) := (R (R t x u) y v, z, w)</code>:</p><pre><code class="spec">   bheight (rotate (R (R t x u) y v) z w)
=    <comment>{- <code class="haskell">rotate</code> 之定義 -}</comment>
   bheight (R (B t x u) y (B v z w))
=    <comment>{- <code class="haskell">bheight</code> 之定義 -}</comment>
   (1+ (bheight t ↑ bheight u)) ↑ (1+ (bheight v ↑ bheight w))
=    <comment>{- 由於 <code class="haskell">(k+x) ↑ (k+y) = k + (x ↑ y)</code>, <code class="haskell">max</code> 有結合律 -}</comment>
   1 + (((bheight t ↑ bheight u) ↑ bheight v) ↑ bheight w)
=    <comment>{- <code class="haskell">bheight</code> 之定義 -}</comment>
   1 + (bheight ((R (R t x u) y v)) ↑ bheight w)
</code></pre></div><h3 class="subsection">3.2.3 紅黑樹之性質：平衡</h3><p>之所以討論黑高度，目的之一當然是要討論平衡。我們可證明函數 <code class="haskell">ins k</code> 維持平衡性：</p><div class="theorem" id="thm:red-black-balanced-ins"><h5 class="theorem-title">定理 3.5  </h5><p>對所有 <code class="haskell">k</code> 與 <code class="haskell">t</code>, <code class="haskell">balanced t ==&gt; balanced (ins k t)</code>.</p></div><p>而由於 <code class="haskell">balanced t ==&gt; balanced (blacken t)</code>, 定理 <a href="#thm:red-black-balanced-ins">3.5 </a> 蘊含 <code class="haskell">insert k</code> 也維持輸入樹的平衡： <code class="haskell">balanced t ==&gt; balanced (insert k t)</code>.</p><p>同樣地，要證明定理 <a href="#thm:red-black-balanced-ins">3.5 </a>，我們也需要一個關於 <code class="haskell">rotate</code> 的引理：</p><div class="theorem" id="lma:red-black-balanced-rotate"><h5 class="theorem-title">引理 3.6  </h5><p>對所有 <code class="haskell">t</code> 與 <code class="haskell">u</code>,</p><pre><code class="spec">balanced t ⋀ balanced u ⋀
   bheight t = bheight u ==&gt; balanced (rotate t x u) 
</code></pre></div><p>由於這些證明與前面提到的證明類似，我們將它們留給讀者做練習。</p><div class="exlist"><div class="exercise exer"><h5 class="exercise-title">練習 3.2 </h5><p>證明定理<a href="#thm:red-black-balanced-ins">3.5 </a>.
你將用得上引理<a href="#lma:red-black-balanced-rotate">3.6 </a>與定理 <a href="#thm:redblack-bheight-ins">3.2 </a>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-3-2" type="checkbox"/><label class="lbl-toggle" for="ans-3-2">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>在 <code class="haskell">t</code> 之上做歸納。基底情況 <code class="haskell">t := E</code> 很容易建立。
以下只示範一種歸納情況。</p><p><strong>狀況</strong> <code class="haskell">t := B t x u</code>, <code class="haskell">k &lt; x</code>:</p><pre><code class="spec">   balanced (ins k (B t x u))
=    <comment>{- <code class="haskell">ins</code> 之定義；<code class="haskell">k &lt; x</code> -}</comment>
   balanced (rotate (ins k t) x u)
&lt;==  <comment>{- 引理 \ref{lma:red-black-balanced-rotate} -}</comment>
   balanced (ins k t) ⋀ balanced u ⋀ bheight (ins k t) = bheight u
=    <comment>{- 定理 \ref{thm:redblack-bheight-ins} -}</comment>
   balanced (ins k t) ⋀ balanced u ⋀ bheight t = bheight u
&lt;==  <comment>{- 歸納假設 -}</comment>
   balanced t ⋀ balanced u ⋀ bheight t = bheight u
=    <comment>{- <code class="haskell">balanced</code> 之定義 -}</comment>
   balanced (B t x u) 
</code></pre></div></div><div class="exercise exer"><h5 class="exercise-title">練習 3.3 </h5><p>證明引理<a href="#lma:red-black-balanced-rotate">3.6 </a>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-3-3" type="checkbox"/><label class="lbl-toggle" for="ans-3-3">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>以下只示範其中一種狀況。</p><p><strong>狀況</strong>: <code class="haskell">(t,x,u) := (R (R t x u) y v, z, w)</code>.</p><pre><code class="spec">  balanced (rotate (R (R t x u) y v) z w)
=    <comment>{- <code class="haskell">rotate</code> 之定義 -}</comment>
  balanced (R (B t x u) y (B v z w))
=    <comment>{- <code class="haskell">balanced</code> 之定義 -}</comment>
  bheight (B t x u) = bheight (B v z w) ⋀
  balanced (B t x u) ⋀ balanced (B v z w)
=    <comment>{- <code class="haskell">bheight</code> 之定義 -}</comment>
  1 + (bheight t ↑ bheight u) = 1+ (bheight v ↑ beight w) ⋀
  bheight t = bheight u ⋀ balanced t ⋀ balanced u ⋀
  bheight v = bheight w ⋀ balanced v ⋀ balanced w
&lt;==  <comment>{- <code class="haskell">balanced</code> 與 <code class="haskell">bheight</code> 之定義；算數性質 -}</comment>
  bheight (R t x u) = bheight v ⋀
  balanced (R t x u) ⋀ balanced v ⋀ balanced w ⋀
  bheight t ↑ bheight u ↑ bheight v = bheight w
=    <comment>{- <code class="haskell">balanced</code> 與 <code class="haskell">bheight</code> 之定義 -}</comment>
  balanced (R (R t x u) y v) ⋀ balanced w ⋀
   bheight R (R t x u) y v = bheight w 
</code></pre></div></div></div><h3 class="subsection">3.2.4 紅黑樹之性質：顏色</h3><p>最後，我們談談紅黑樹插入之後的顏色。我們也許希望函數 <code class="haskell">ins k</code> 能保持準紅黑性，意即 <code class="haskell">semiRB t ==&gt; semiRB (ins k t)</code>.
但這顯然不成立：我們已經知道 <code class="haskell">ins k</code> 可能在一個路徑上產生連續兩個紅節點。</p><p>為描述此時的特殊狀況，我們另外定義一個性質：滿足下列述語的樹被稱作<em>紅外(infrared)樹</em> --- 取自比紅色還紅一點之意：</p><pre><code class="haskell">infrared :: RBTree -&gt; Bool
infrared (R t x u)  =  (color t == Blk || color u == Blk) ⋀
                         semiRB t ⋀ semiRB u
infrared t          =  False 
</code></pre><p>紅外樹幾乎是一棵根部為紅色的準紅黑樹，但兩個子樹 <code class="haskell">t</code> 與 <code class="haskell">u</code> 之中最多有一個可以是紅色！我們將其表示成 <code class="haskell">color t == Blk | color u == Blk</code>. 此外，<code class="haskell">t</code> 與 <code class="haskell">u</code> 仍必須是準紅黑樹。其他的情形（<code class="haskell">E</code> 或是 <code class="haskell">B _ _ _</code>）是黑色的，都不是紅外樹。</p><p>那麼，我們是否能證明：給定 <code class="haskell">ins k</code> 準紅黑樹 <code class="haskell">t</code>， <code class="haskell">ins k t</code> 總是一個紅外樹，意即 <code class="haskell">semiRB t ==&gt; infrared (ins k t)</code>？
對歸納證明熟悉的讀者可能立刻覺得事有蹊蹺：有二就有三，證明歸納狀況時，如果歸納假設中的子樹有兩個連續的紅節點，在歸納狀況中可能看到三個連續紅節點。如此一來似乎沒完沒了。</p><p>這是一個必須嘗試證明一個更強的性質才能使歸納證明成立的例子。
函數 <code class="haskell">ins</code> 真正滿足的是一個更強的性質：
給定準紅黑樹 <code class="haskell">t</code>,
如果 <code class="haskell">t</code> 是紅色，<code class="haskell">ins k t</code> 則是一棵紅外樹；如果 <code class="haskell">t</code> 是黑色，<code class="haskell">ins k t</code> 也將是一棵準紅黑樹：</p><div class="theorem" id="thm:red-black-semiRB-ins"><h5 class="theorem-title">定理 3.7  </h5><p>對所有 <code class="haskell">t</code>:</p><ol><li><p><code class="haskell">semiRB t ⋀ color t = Red ==&gt; infrared (ins k t)</code>,</p></li><li><p><code class="haskell">semiRB t ⋀ color t = Blk ==&gt; semiRB (ins k t)</code>.</p></li></ol></div><p>為證明定理<a href="#thm:red-black-semiRB-ins">3.7 </a>，我們也需要一個與 <code class="haskell">rotate</code> 相關的引理：
只要 <code class="haskell">t</code> 與 <code class="haskell">u</code> 之中有一個是準紅黑樹，另一個是準紅黑樹或紅外樹，<code class="haskell">rotate t x u</code> 就會是準紅黑樹：</p><div class="theorem" id="lma:red-black-semiRB-rotate"><h5 class="theorem-title">引理 3.8  </h5><p>對所有 <code class="haskell">t</code> 與 <code class="haskell">u</code>,</p><ol><li><p><code class="haskell">(infrared t ⋁ semiRB t) ⋀ semiRB u ==&gt; semiRB (rotate t x u)</code>;</p></li><li><p><code class="haskell">semiRB t ⋀ (infrared u ⋁ semiRB u) ==&gt; semiRB (rotate t x u)</code>.</p></li></ol></div><p>有了定理<a href="#thm:red-black-semiRB-ins">3.7 </a>，由於 <code class="haskell">infrared t ==&gt; semiRB (blacken t)</code>，
我們立刻得知 <code class="haskell">insert k</code> 保持準紅黑性：</p><div class="theorem"><h5 class="theorem-title">系理 3.9  </h5><p><code class="haskell">semiRB t ==&gt; semiRB (insert k t)</code>.</p></div><p>以下證明定理<a href="#thm:red-black-semiRB-ins">3.7 </a>:</p><div class="proof"><b>證明 </b><p>定理<a href="#thm:red-black-semiRB-ins">3.7 </a>的 1, 2 兩個小性質需在同一個歸納中證明。
注意： 1 與 2 的合取蘊含了</p><pre><code class="equation" id="eq:red-black-semiRB-ins-infrared">|semiRB t ==&gt; (infrared (ins k t) |||| semiRB (ins k t))| \mbox{~~.}</code>    (3.1 )
</pre><p>我們將用到此性質。</p><p>在 <code class="haskell">t</code> 之上做歸納。我們只舉出兩個具代表性的例子：</p><p><strong>狀況</strong>: <code class="haskell">t := B t x u</code>, <code class="haskell">k &lt; x</code>:</p><pre><code class="spec">   semiRB (ins k (B t x u))
=    <comment>{- <code class="haskell">ins</code> 之定義, <code class="haskell">k &lt; x</code> -}</comment>
   semiRB (rotate (ins k t) x u)
&lt;==  <comment>{- 引理 \ref{lma:red-black-semiRB-rotate} -}</comment>
   (infrared (ins k t) || semiRB (ins k t)) ⋀ semiRB u
&lt;==  <comment>{- 歸納假設，\eqref{eq:red-black-semiRB-ins-infrared} -}</comment>
   semiRB t ⋀ semiRB u
=    <comment>{- <code class="haskell">semiRB</code> 之定義 -}</comment>
   semiRB (B t x u) 
</code></pre><p><strong>狀況</strong>: <code class="haskell">t := R t x u</code>, <code class="haskell">k &lt; x</code>:</p><pre><code class="spec">   infrared (ins k (R t x u))
=    <comment>{- <code class="haskell">ins</code> 之定義 -}</comment>
   infrared (R (ins k t) x u)
=    <comment>{- <code class="haskell">infrared</code> 之定義 -}</comment>
   (color (ins k t) = Blk || color u = Blk) ⋀ semiRB (ins k t) ⋀ semiRB u
=    <comment>{- 歸納假設 -}</comment>
   (color (ins k t) = Blk || color u = Blk) ⋀ semiRB t ⋀ color t = Blk ⋀ semiRB u
&lt;==  <comment>{- 命題邏輯: <code class="haskell">((P ⋁ Q) ⋀ R) &lt;== (Q ⋀ R)</code> -}</comment>
   color t = color u = Blk ⋀ semiRB t ⋀ semiRB u
=   <comment>{- <code class="haskell">semiRB</code> 之定義 -}</comment>
   semiRB (R t x u) 
</code></pre></div><div class="exlist"><div class="exercise exer"><h5 class="exercise-title">練習 3.4 </h5><p>證明引理 <a href="#lma:red-black-semiRB-rotate">3.8 </a>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-3-4" type="checkbox"/><label class="lbl-toggle" for="ans-3-4">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>本證明只是一一檢查每個狀況。
以 1. <code class="haskell">(infrared t ⋁ semiRB t) ⋀ semiRB u ==&gt; semiRB (rotate t x u)</code> 為例，由於有 <code class="haskell">semiRB u</code>, 我們只需檢查 <code class="haskell">rotate</code> 的第一、第二、與最後一個狀況。
以第一個狀況為例：</p><p><strong>狀況</strong>: <code class="haskell">(t,x,u) := (R (R t x u) y v, z, w)</code>:</p><pre><code class="spec">   semiRB (rotate (R (R t x u) y v) z w)
=    <comment>{- <code class="haskell">rotate</code> 之定義 -}</comment>
   semiRB (R (B t x u) y (B v z w))
=    <comment>{- <code class="haskell">semiRB</code> 與 <code class="haskell">color</code> 之定義 -}</comment>
   color t = color u = color v = color w = Blk ⋀
   semiRB t ⋀ semiRB u ⋀ semiRB v ⋀ semiRB w
=    <comment>{- <code class="haskell">semiRB</code> 之定義 -}</comment>
   color v = color w = Blk ⋀
   semiRB (R t x u) ⋀ semiRB v ⋀ semiRB w
=    <comment>{- <code class="haskell">infrared</code> 之定義 -}</comment>
   infrared (R (R t x u) y v) ⋀ semiRB w
=    <comment>{- 命題邏輯，<code class="haskell">semiRB (R (R t x u) y v) = False</code> -}</comment>
   (infrared (R (R t x u) y v) || semiRB (R (R t x u) y v)) ⋀ semiRB w  

</code></pre></div></div></div></div><div class="navi"><div class="previous">&laquo;<a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></div><div class="next"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
