<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" checked type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" checked type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:basics">1 值、函數、與定義</h1></div><div class="navi"><div class="previous">&laquo;<a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></div><div class="next"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:elementary-datatypes">1.6 簡單資料型態</h2><p>藉由一些例子，我們已經看過 Haskell 的一些數值型別：<code class="haskell">Int</code>, <code class="haskell">Float</code> 等等。
在本節中我們將簡短介紹我們將用到的一些其他型別。</p><h3 class="subsection" id="sec:boolean">1.6.1 布林值</h3><p>布林值 (Boolean)<span id="ix-1-24"></span>常用於程式中表達真和假。
在 Haskell 中，我們可假想有這樣的一個型別定義：</p><pre><code class="spec">data Bool = False | True 
</code></pre><p>其中，<code class="haskell">data</code> 是 Haskell 宣告新資料型別的保留字。
上述定義可用口語描述成「定義一個稱作 <code class="haskell">Bool</code> 的新資料型別，
有兩個可能的值，分別為 <code class="haskell">False</code> 和 <code class="haskell">True</code>.」
<code class="haskell">False</code> 和 <code class="haskell">True</code> 是型別 <code class="haskell">Bool</code> 的<em>唯二</em>兩個<em>建構元</em> ---
任何型別為 <code class="haskell">Bool</code> 的值，如果有正規式，必定是它們兩者之一。
在 Haskell 之中，建構元必須以大寫英文字母或冒號(<code class="haskell">:</code>)開頭。</p><p><b>樣式配對</b> &emsp; <span id="ix-1-25"></span> 有了資料，我們來看看怎麼定義該型別上的函數。以布林值為輸入的函數中，
最簡單又常用的可能是 <code class="haskell">not</code>:</p><pre><code class="spec">not :: Bool -&gt; Bool
not False  = True
not True   = False 
</code></pre><p>這和我們的的直覺理解一致：<code class="haskell">not False</code> 是 <code class="haskell">True</code>, <code class="haskell">not True</code> 是
<code class="haskell">False</code>. 我們看到這個定義寫成兩行（正式說來是兩個「子句」），\emph{每一個子句分別對應到 <code class="haskell">Bool</code> 的一個可能的值}。
以下則是邏輯上的「且」和「或」（分別寫作<code class="haskell">(⋀)</code>與<code class="haskell">(⋁)</code>）的定義：
<input class="toggle" id="footnote-1-6-10" type="checkbox"/><label class="fnote-toggle" for="footnote-1-6-10">(註10) </label><span class="collapsible-footnote">邏輯「且」又稱作合取(conjunction)<span id="ix-1-26"></span>；邏輯「或」又稱作析取(disjunction).<span id="ix-1-27"></span>
在 Haskell 中，「且」與「或」需分別寫成 $(\mathtt{\&\&})$ 和 $(\mathtt{||||})$。本書中採用數學與邏輯領域較常使用的 <code class="haskell">(⋀)</code>與<code class="haskell">(⋁)</code>.</span></p><pre><code class="spec">(⋀), (||) :: Bool -&gt; Bool -&gt; Bool
False  ⋀ y  = False
True   ⋀ y  = y 

False  || y  = y
True   || y  = True 
</code></pre><p>運算子<code class="haskell">(⋀)</code>與<code class="haskell">(⋁)</code>的定義同樣是各兩個子句，每個子句分別考慮其第一個參數的值。
以 <code class="haskell">x ⋀ y</code> 為例：如果 <code class="haskell">x</code> 是 <code class="haskell">False</code>, 不論 <code class="haskell">y</code> 的值為何，<code class="haskell">x ⋀ y</code> 都是 <code class="haskell">False</code>；
如果 <code class="haskell">x</code> 是 <code class="haskell">True</code>, <code class="haskell">x & y</code> 的值和 <code class="haskell">y</code> 相同。<code class="haskell">(⋁)</code> 的情況類似。</p><div class="theorem" id="eg:leap-year"><h5 class="theorem-title">例 1.11  </h5><p>以下函數判斷給定年份 <code class="haskell">y</code> 是否為閏年。</p><pre><code class="haskell">leapyear :: Int -&gt; Bool
leapyear y =  (y `mod` 4 == 0) ⋀
               (y `mod` 100 /= 0 || y `mod` 400 == 0) 
</code></pre></div><p>我們來算算看 <code class="haskell">leapyear 2016</code>。依照定義展開為</p><pre><code class="spec">  (2016 `mod` 4 == 0) ⋀ (2016 `mod` 100 /= 0 || 2016 `mod` 400 == 0) 
</code></pre><p>接下來該怎麼做呢？函數 <code class="haskell">(⋀)</code> 的定義有兩個子句，我們得知道 <code class="haskell">2016 `mod` 4 == 0</code> 的值才能得知該歸約成哪個。因此只好先算 <code class="haskell">2016 `mod` 4 == 0</code>，得到 <code class="haskell">True</code>:</p><pre><code class="spec">  True ⋀ (2016 `mod` 100 /= 0 || 2016 `mod` 400 == 0) 
</code></pre><p>然後依照<code class="haskell">(⋀)</code> 的定義歸約為 <code class="haskell">2016 `mod` 100 /= 0 ⋁ 2016 `mod` 400 == 0</code>.
接下來也依此類推。</p><p>我們發現這是第<a href="Basics-1.html#sec:evaluation">1.1 </a>節中所提及的<em>被迫求值</em>的例子：我們得先把參數算出，才知道接下來如何走。
函數 <code class="haskell">not</code>, <code class="haskell">(⋀)</code>, <code class="haskell">(⋁)</code> 定義成許多個子句，每個都分析其參數的可能外觀，據此決定該怎麼走。這種定義方式稱作<em>樣式配對 (pattern matching)</em>：等號左手邊的 <code class="haskell">False</code>, <code class="haskell">True</code> 等等在此是樣式(pattern)。使用這些函數時，例如 <code class="haskell">x ⋀ y</code> 中， <code class="haskell">x</code> 得先被算到可以和這些樣式配對上的程度，才能決定接下來的計算如何進行。</p><p>樣式配對也可用在不止一個參數上。例如，以下的運算元 <code class="haskell">(==)</code> 判斷兩個布林值是否相等。</p><pre><code class="spec">(==) :: Bool -&gt; Bool -&gt; Bool
False  == False  = True
False  == True   = False
True   == False  = False
True   == True   = True 
</code></pre><p>讀者可能注意到我們用了同一個符號 <code class="haskell">(==)</code> 來表示整數與布林值的相等測試。
請讀者暫且接受，相信 Haskell 有某些方式可得知任一個算式中的 <code class="haskell">(==)</code> 到底是什麼型別的相等。詳情 \todo{where?}</p><p>Haskell 中另有一個專用來做樣式配對的 <code class="haskell">case</code> 算式。例如，<code class="haskell">(⋀)</code> 也可寫成如下的形式：</p><pre><code class="spec">(⋀) :: Bool -&gt; Bool
x ⋀ y =  case x of
            False  -&gt; False
            True   -&gt; y 
</code></pre><p>由於 <code class="haskell">case</code> 是算式，如同 <code class="haskell">let</code> 一樣可出現在其他算式中，也可巢狀出現。</p><div class="exlist"><div class="exercise exer" id="ex:case-formula"><h5 class="exercise-title">練習 1.7 </h5><p>以 <code class="haskell">case</code> 算式定義 <code class="haskell">not</code>, <code class="haskell">(⋁)</code>, 和 <code class="haskell">(==)</code>.</p></div><div class="exercise exer" id="ex:equal-symbol-defn"><h5 class="exercise-title">練習 1.8 </h5><p>另一個定義 <code class="haskell">(==) :: Bool -&gt; Bool -&gt; Bool</code> 的方式是</p><pre><code class="spec">x == y = (x ⋀ y) || (not x ⋀ not y) 
</code></pre><p>請將 <code class="haskell">(x,y) := (False, False)</code>, <code class="haskell">(x,y) := (False, True)</code>
等四種可能分別代入化簡，看看是否和本節之前的 <code class="haskell">(==)</code> 定義相同。</p></div></div><h3 class="subsection" id="sec:char">1.6.2 字元</h3><p>我們可把「字元」這個型別想成一個很長的 <code class="haskell">data</code> 宣告：</p><pre><code class="spec">data Char = 'a' | 'b' | ... | 'z' | 'A' | 'B' ....
</code></pre><p>其中包括所有字母、符號、空白... 目前的 Haskell 甚至有處理 Unicode 字元的能力。
但無論如何，<code class="haskell">Char</code> 之中的字元數目是有限的。我們可用樣式配對定義字元上的函數。
注意：字元以單引號括起來。</p><p>我們也可假設字元是有順序的，每個字元對應到一個內碼。
關於 <code class="haskell">Char</code> 的常用函數中，<code class="haskell">ord</code> 將字元的內碼找出，<code class="haskell">chr</code> 則將內碼轉為字元：</p><pre><code class="spec">ord  :: Char -&gt; Int 
chr  :: Int -&gt; Char 
</code></pre><div class="theorem" id="eg:isupper"><h5 class="theorem-title">例 1.12  </h5><p>下列函數 <code class="haskell">isUpper</code> 判斷一個字元是否為大寫英文字母；<code class="haskell">toLower</code> 則將
大寫字母轉成小寫字母，若輸入並非大寫字母則不予以變動。</p><pre><code class="haskell">isUpper :: Char -&gt; Bool
isUpper c = let x = ord c in ord 'A' &lt;= x ⋀ x &lt;= ord 'Z' 

toLower :: Char -&gt; Char
toLower c  | isUpper c  = chr (ord c - ord 'A' + ord 'a')
           | otherwise  = c 
</code></pre></div><h3 class="subsection" id="sec:pairs">1.6.3 序對</h3><p>數學上，將兩個值（如 <code class="haskell">3</code> 和 <code class="haskell">'a'</code>) 放在一起，就成了一個<em>有序對</em>(<em>ordered pair</em>)，可寫成<code class="haskell">(3,'a')</code>。<span id="ix-1-28"></span>
之所以稱作「有序」對，因為其中兩個元素的順序是不可忽略的 --- <code class="haskell">(3,'a')</code> 與 <code class="haskell">('a',3)</code> 是不同的有序對。
另一個常見譯名是「數對」。由於我們處理的不只是數字，本書將之簡稱為「序對」。</p><p>給兩個集合 <code class="haskell">A</code> 和 <code class="haskell">B</code>, 從 <code class="haskell">A</code> 之中任取一元素 <code class="haskell">x</code>，從 <code class="haskell">B</code> 之中也任取一元素 <code class="haskell">y</code>，
兩者的序對 <code class="haskell">(x,y)</code> 形成的集合稱作 <code class="haskell">A</code> 和 <code class="haskell">B</code> 的<em>笛卡兒積</em>(<em>Cartesian product</em>)，寫成 <code class="haskell">A × B</code>:<span id="ix-1-29"></span></p><pre><code class="spec">   A × B = {(x,y) | x ∈ A, y ∈ B} 
</code></pre><p>Haskell 之中也有類似的構造。給定型別 <code class="haskell">a</code> 與 <code class="haskell">b</code>, 它們的序對的型別是 <code class="haskell">(a × b)</code>.
<input class="toggle" id="footnote-1-6-11" type="checkbox"/><label class="fnote-toggle" for="footnote-1-6-11">(註11) </label><span class="collapsible-footnote">然而，由於「程式可能不終止」這個因素作怪，<code class="haskell">a × b</code> 的元素並不僅是 <code class="haskell">a</code> 與 <code class="haskell">b</code> （如果視做集合）的笛卡兒積。詳見 \todo{where?}</span>
我們可以想像 Haskell 有這麼一個型別定義：</p><pre><code class="spec">data (a × b) = (a,b) 
</code></pre><p>以口語說的話，<code class="haskell">(a × b)</code> 是一個新型別，而具有此型別的值若有範式，必定是 <code class="haskell">(x,y)</code> 的形式，其中 <code class="haskell">x</code> 的型別是 <code class="haskell">a</code>, <code class="haskell">y</code> 的型別是 <code class="haskell">b</code>.
<input class="toggle" id="footnote-1-6-12" type="checkbox"/><label class="fnote-toggle" for="footnote-1-6-12">(註12) </label><span class="collapsible-footnote">其實這個定義並不符合 Haskell 的語法，因此只是方便理解的想像。另，型別 <code class="haskell">(a × b)</code> 在 Haskell 中寫成 <code class="haskell">(a,b)</code>. 我的經驗中，讓型別與值的語法太接近，反易造成困惑。</span>
序對的建構元寫成<code class="haskell">(,)</code>，型別為 <code class="haskell">a -&gt; b -&gt; (a × b)</code>.
例如 <code class="haskell">(,) 4 'b' = (4,'b')</code>.</p><p>兩個常用的函數 <code class="haskell">fst</code> 與 <code class="haskell">snd</code> 分別取出序對中的第一個和第二個元素：</p><div class="multicols"><div class="mcol" width="0.4\textwidth"><pre><code class="spec">fst :: (a × b) -&gt; a
fst (x,y) = x 
</code></pre></div><div class="mcol" width="0.4\textwidth"><pre><code class="spec">snd :: (a × b) -&gt; b
snd (x,y) = y 
</code></pre></div></div><p>函數 <code class="haskell">fst</code> 與 <code class="haskell">snd</code> 的定義方式也是樣式配對：輸入值必須先計算成 <code class="haskell">(x,y)</code> 的形式。</p><div class="theorem" id="eg:pairs-examples"><h5 class="theorem-title">例 1.13  </h5><p>以下是一些序對與其相關函數的例子。</p><ul><li><p><code class="haskell">(3,'a')</code> 是一個型別為 <code class="haskell">(Int × Char)</code> 的序對。</p></li><li><p><code class="haskell">fst (3,'a') = 3</code>, <code class="haskell">snd (3,'a') = 'a'</code></p></li><li><p>函數 <code class="haskell">swap</code> 將序對中的元素調換：</p></li></ul><pre><code class="spec">swap :: (a × b) -&gt; (b × a)
swap (x,y) = (y,x) 
</code></pre><p>另一個定義方式是 <code class="haskell">swap p = (snd p, fst p)</code>.
但這兩個定義並不盡然相同。詳見第<a href="Basics-7.html#sec:weak-head-normal-form">1.7 </a>節。</p></div><p>序對也可以巢狀構成。例如 <code class="haskell">((True,3), 'c')</code> 是一個型別為 <code class="haskell">((Bool × Int) × Char)</code> 的序對，而 <code class="haskell">snd (fst ((True,3), 'c')) = 3</code>. 在 Haskell 之中，<code class="haskell">((a × b) × c)</code> 與 <code class="haskell">(a × (b × c))</code> 被視為不同的型別，但他們是<em>同構</em>的 --- 我們可定義一對函數在這兩個型別之間作轉換：</p><pre><code class="haskell">assocr :: ((a × b) × c) -&gt; (a × (b × c))
assocr ((x,y),z) = (x,(y,z)) 

assocl :: (a × (b × c)) -&gt; ((a × b) × c)
assocl (x,(y,z)) = ((x,y),z) 
</code></pre><p>並且滿足 <code class="haskell">assocr . assocl = id</code>, 和 <code class="haskell">assocl . assocr = id</code>.</p><div class="exlist"><div class="exercise exer" id="ex:assocl-assocr"><h5 class="exercise-title">練習 1.9 </h5><p>試試看不用樣式配對，而以 <code class="haskell">fst</code> 和 <code class="haskell">snd</code> 定義 <code class="haskell">assocl</code> 和 <code class="haskell">assocr</code>:</p><pre><code class="spec">assocl  p = ...
assocr  p = ...
</code></pre></div></div><div class="infobox infobox" title="同構"><h5 class="infobox-title">同構</h5><p><span id="ix-1-30"></span>
兩個集合<code class="haskell">A</code>與<code class="haskell">B</code> <em>同構</em>(<em>isomorphic</em>)，意思是
<code class="haskell">A</code> 之中的 <em>每個</em>元素都<em>唯一地</em>對應到 <code class="haskell">B</code> 之中的<em>一個</em>元素，反之亦然。</p><p>一個形式定義是：<code class="haskell">A</code>與<code class="haskell">B</code>同構意謂我們能找到兩個全(total)函數
<span id="ix-1-31"></span> <code class="haskell">to :: A -&gt; B</code> 和 <code class="haskell">from :: B -&gt; A</code>, 滿足</p><pre><code class="spec">from . to = id 
to . from = id 
</code></pre><p>此處的兩個 <code class="haskell">id</code> 型別依序分別為 <code class="haskell">A -&gt; A</code> 和 <code class="haskell">B -&gt; B</code>。
將定義展開，也就是說，對所有 <code class="haskell">x :: A</code>，<code class="haskell">from (to x) = x</code>; 對所有 <code class="haskell">y :: B</code>, <code class="haskell">to (from y) = y</code>. 這個定義迫使對每個 <code class="haskell">x</code> 都存在一個唯一的 <code class="haskell">to x</code>, 反之亦然。</p><p>我們已有兩個例子：<code class="haskell">((a × b) × c)</code> 與 <code class="haskell">(a × (b × c))</code> 同構，此外，<code class="haskell">(a × b)</code> 與 <code class="haskell">(b × a)</code> 也同構，因為 <code class="haskell">swap . swap = id</code>.</p><p>如果集合<code class="haskell">A</code>與<code class="haskell">B</code>同構，不僅 <code class="haskell">A</code> 之中的每個元素都有個在 <code class="haskell">B</code> 之中相對的元素，給任一個定義在 <code class="haskell">A</code> 之上的函數 <code class="haskell">f</code>, 我們必可構造出一個 <code class="haskell">B</code> 之上的函數，具有和 <code class="haskell">f</code> 相同的性質。即使<code class="haskell">A</code>與<code class="haskell">B</code>並不真正相等，我們也可把它們視為<em>基本上沒有差別</em>的。在許多無法談「相等」的領域中，同構是和「相等」地位一樣的觀念。</p></div><p>另外可一提的是，Haskell 允許我們在 $\lambda$ 算式中做樣式配對。例如 <code class="haskell">fst</code> 的另一種寫法是：</p><pre><code class="spec">fst = \(x,y) -&gt; x 
</code></pre><p>Haskell 另有提供更多個元素形成的有序組，例如 <code class="haskell">(True, 3, 'c')</code> 是一個型別為 <code class="haskell">(Bool × Int × Char)</code> 的值。但本書暫時不使用他們。</p><p id="par:split-product"><b>分裂與積</b> &emsp;
在我們將介紹的程式設計風格中，以下兩個產生序對的運算子相當好用。
第一個運算子利用兩個函數產生一個序對：</p><pre><code class="haskell">fork :: (a -&gt; b) -&gt; (a -&gt; c) -&gt; a -&gt; (b × c)
(fork f g) x = (f x, g x) 
</code></pre><p>給定兩個函數 <code class="haskell">f :: a -&gt; b</code> 和 <code class="haskell">g :: a -&gt; c</code>,
<code class="haskell">fork f g :: a -&gt; (b × c)</code> 是一個新函數，將 <code class="haskell">f</code> 和 <code class="haskell">g</code> 的結果
收集在一個序對中。
我們借用範疇論的詞彙，將此稱作<em>分裂</em>(<em>split</em>) ---
<code class="haskell">fork f g</code> 可讀成「<code class="haskell">f</code> 與 <code class="haskell">g</code> 的分裂」。
<span id="ix-1-32"></span></p><p>如果我們已經有了一個序對，我們可用 <code class="haskell">(f *** g)</code> 算出一個新序對：</p><pre><code class="spec">(***) :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; (a × c) -&gt; (b × d)
(f *** g) (x,y) = (f x, g x) 
</code></pre><p>函數<code class="haskell">(f *** g)</code> 將 <code class="haskell">f</code> 和 <code class="haskell">g</code> 分別作用在序對 <code class="haskell">(x,y)</code> 的兩個元素上。
這個操作稱作「<code class="haskell">f</code> 和 <code class="haskell">g</code> 的乘績(product)」，同樣是借用範疇論的詞彙。
<span id="ix-1-33"></span></p><p>關於分裂與乘積，有兩條重要的性質，將會在之後用到：</p><div class="equations"><ul><li><p id="eq:prod-split-absorb"><b>吸收律</b> &emsp; <code class="haskell">(f *** g) . fork h k</code> <code class="haskell">= fork (f . h) (g . k)</code></p></li><li><p id="eq:prod-fusion"><b>融合律</b> &emsp; <code class="haskell">(f *** g) . (h *** k)</code> <code class="haskell">= ((f . h) *** (g . k))</code></p></li></ul></div><p>目前 Haskell 的標準階層函式庫將分裂與乘積收錄在 \texttt{Control.Arrow} 中，
<code class="haskell">fork f g</code> 寫作：\texttt{f \&\&\& g}, <code class="haskell">(f *** g)</code> 則寫作 \texttt{f *** g}.</p><p id="par:currying-uncurrying"><b>Currying 與 Uncurrying</b> &emsp;
如前所述，Haskell 的每個函數都只拿一個參數。拿多個參數的函數可以
傳回函數的函數來模擬，稱作 currying.
有了序對之後，另一種模擬多參數的方式是把參數都包到一個序對中。
例如，型別為 <code class="haskell">(a × b) -&gt; c)</code> 的函數可視為拿了兩個型別為 <code class="haskell">a</code> 與 <code class="haskell">b</code> 的參數。</p><p>函數 <code class="haskell">curry</code> 與 <code class="haskell">uncurry</code> 幫助我們在這兩種表示法之間轉換 ---
<code class="haskell">curry</code> 將拿序對的函數轉換成 curried 函數，<span id="ix-1-34"></span>
<code class="haskell">uncurry</code> 則讓 curried 函數改拿序對當作參數：<span id="ix-1-35"></span></p><pre><code class="spec">curry :: ((a × b) -&gt; c) -&gt; (a -&gt; b -&gt; c)
curry f x y = f (x,y) 

uncurry :: (a -&gt; b -&gt; c) -&gt; ((a × b) -&gt; c)
uncurry f (x,y) = f x y 
</code></pre><p>例：如果<code class="haskell">(==)</code> 的型別為 <code class="haskell">Int -&gt; Int -&gt; Bool</code>,
<code class="haskell">uncurry (==)</code> 的型別為 <code class="haskell">(Int × Int) -&gt; Bool</code>。
後者檢查一個序對中的兩個值是否相等（例：<code class="haskell">uncurry (==) (3,3) = True</code>）。</p><div class="exlist"><div class="exercise exer" id="ex:curry-uncurry-id"><h5 class="exercise-title">練習 1.10 </h5><p>事實上，<code class="haskell">curry</code> 與 <code class="haskell">uncurry</code> 的存在證明了 <code class="haskell">(a × b) -&gt; c</code>
與 <code class="haskell">a -&gt; b -&gt; c</code> 是同構的。試證明
<code class="haskell">curry . uncurry = id</code>, 以及 <code class="haskell">uncurry . curry = id</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-10" type="checkbox"/><label class="lbl-toggle" for="ans-1-10">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>欲證明 <code class="haskell">curry . uncurry = id</code>：</p><pre><code class="spec">     curry . uncurry = id
&lt;=&gt;    <comment>{- 外延相等及 <code class="haskell">id</code> 之定義 -}</comment>
     (forall f : curry (uncurry f) = f)
&lt;=&gt;    <comment>{- 外延相等 -}</comment>
     (forall f x y : curry (uncurry f) x y = f x y) 
</code></pre><p>因此我們證明 <code class="haskell">curry (uncurry f) x y = f x y</code> 如下：</p><pre><code class="spec">   curry (uncurry f) x y
=   <comment>{- <code class="haskell">curry</code> 之定義 -}</comment>
   uncurry f (x,y)
=   <comment>{- <code class="haskell">uncurry</code> 之定義 -}</comment>
   f x y  
</code></pre><p>與此相似，欲證明 <code class="haskell">uncurry . curry = id</code> 我們須證明
<code class="haskell">uncurry (curry f) (x,y) = f (x,y)</code>，其證明也與上面的證明類似。</p></div></div><div class="exercise exer" id="ex:uncurry-apply"><h5 class="exercise-title">練習 1.11 </h5><p>請說明 <code class="haskell">map (uncurry ($))</code> 的型別與功能。
關於 <code class="haskell">($)</code> 請參考第\pageref{para:fun-apply}頁。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-11" type="checkbox"/><label class="lbl-toggle" for="ans-1-11">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p><code class="haskell">map (uncurry ($)) :: List ((a -&gt; b) × a) -&gt; List b</code>.
它拿一個內容均為「(函數 $\times$ 參數)」序對的串列，將每個函數作用在其參數上。
例如：</p><pre><code class="spec">map (uncurry ($)) [((1+), 3), (square, 4), (smaller 5, 3)]
</code></pre><p>會得到 <code class="haskell">[1+3,4*4,3]</code>.</p></div></div></div></div><div class="navi"><div class="previous">&laquo;<a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></div><div class="next"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
