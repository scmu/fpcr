<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" checked type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" checked type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:derivation">5 一般程式推導</h1></div><div class="navi"><div class="previous">&laquo;<a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></div><div class="next"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:tupling">5.5 組對</h2><p>接下來我們介紹另一個重要的技巧：「組對(tupling)」。</p><h3 class="subsection" id="sec:steep">5.5.1 陡串列</h3><p>給定一個整數串列。當我們說它很「陡」，意思是它由左到右下降得極快，快到每一個元素都大於其右邊所有元素的和。形式化的定義如下：</p><pre><code class="haskell">steep :: List Int -&gt; Bool
steep []      = True
steep (x:xs)  = x &gt; sum xs ⋀ steep xs 
</code></pre><p>如果當作一個程式，當輸入串列長度為 <code class="haskell">n</code>, 由於反覆呼叫 <code class="haskell">sum</code>, 上述的程式需要 $O(n^2)$ 的時間。
但每次算出的 <code class="haskell">sum xs</code> 和 <code class="haskell">x</code> 比較後便立刻被丟棄，似乎很浪費。我們能否把 <code class="haskell">sum</code> 的結果存下來呢？
下述函數 <code class="haskell">steepsum</code> 把 <code class="haskell">steep</code> 與 <code class="haskell">sum</code> 都算出來，放在一個序對中：</p><pre><code class="spec">steepsum :: List Int -&gt; (Bool × Int)
steepsum xs = (steep xs, sum xs) 
</code></pre><p>我們看看 <code class="haskell">steepsum</code> 能否算得快一點？</p><p>根據定義，<code class="haskell">steepsum [] = (True, 0)</code>. 我們看看 <code class="haskell">xs = x:xs</code> 的例子：</p><pre><code class="haskell">      steepsum (x:xs)
 ===    <comment>{- <code class="haskell">steepsum</code> 之定義 -}</comment>
      (steep (x:xs), sum (x:xs))
 ===    <comment>{- <code class="haskell">steep</code> 與 <code class="haskell">sum</code> 之定義 -}</comment>
      (x &gt; sum xs ⋀ steep xs, x + sum xs)
 ===    <comment>{- 將子算式提取至 <code class="haskell">let</code> 中 -}</comment>
      let (b, s) = (steep xs, sum xs)
      in (x &gt; s ⋀ b, x + s)
 ===    <comment>{- <code class="haskell">steepsum</code> 之定義 -}</comment>
      let (b, s) = steepsum xs
      in (x &gt; s ⋀ b, x + s) 
</code></pre><p>我們已推導出：</p><pre><code class="haskell">steepsum []      =  (True, 0)
steepsum (x:xs)  =  let (b, s) = steepsum xs
                    in (x &gt; s ⋀ b, x + s) 
</code></pre><p>這是一個只用 $O(n)$ 時間的程式。
有了 <code class="haskell">steepsum</code>，我們可重新定義 <code class="haskell">steep</code> 為 <code class="haskell">steep = fst . steepsum</code>。</p><p>讓一個函數<em>多傳回一些值</em>的動作稱作<em>組對</em>(<em>tupling</em>) --- 因為多傳回的值被放在一個序對中。<span id="ix-5-6"></span>
<input class="toggle" id="footnote-5-5-3" type="checkbox"/><label class="fnote-toggle" for="footnote-5-5-3">(註3) </label><span class="collapsible-footnote">在一些函數語言中，<code>pair'' 指含兩個成員的序對，</code>tuple'' 則不限定為兩個成員。Tuple 也可當作動詞，指做出一個 tuple. 本書將動詞的 tuple 譯為「組對」-- 組出一個對。有些語言中 pair 與 tuple 有更根本的差異，但本書中不做區分。</span>
我們常用此技巧來存下可重複使用的中間值，並減少走訪資料結構的次數。</p><p>最後一提：若使用第<a href="Basics-6.html#sec:pairs">1.6.3 </a>節，頁介紹的「分裂」運算元：
<span id="ix-5-7"></span></p><pre><code class="spec">fork :: (a -&gt; b) -&gt; (a -&gt; c) -&gt; a -&gt; (b × c)
(fork f g) x = (f x, g x) 
</code></pre><p>函數 <code class="haskell">steepsum</code> 的定義可較簡潔地寫成：</p><pre><code class="spec">steepsum = fork steep sum 
</code></pre><p>本書將在適當時採用這種寫法。</p><p><b>責任越大，能力越強？</b> &emsp;
某個意義上，函數 <code class="haskell">steepsum</code> 做的事比 <code class="haskell">steep</code> 多：
後者只判斷輸入是否為陡串列，前者不只如此，還多附送了串列的和。
然而，傳回較多東西、似乎做了更多事的程式，反倒可以執行得比較快。
竟出現「責任越大，能力越強」這種違反直覺的現象，這是怎麼回事呢？
<input class="toggle" id="footnote-5-5-4" type="checkbox"/><label class="fnote-toggle" for="footnote-5-5-4">(註4) </label><span class="collapsible-footnote">「能力越強，責任越大 (with great power comes great responsibility)」是 2002 年版《蜘蛛人》電影的名句。根據考證 <a href="../Biblio.html#OToole:15:Great">[O'Toole 2017]</a>, 法國國民公會1793年的政令中即出現過類似的想法，包括邱吉爾和羅斯福等人也都說過類似話語的不同版本。</span></p><p>其實，在歸納定義與歸納證明中，這都是常見的。
有些比較通用的程式反倒比較容易定義；有些定理本身不好證明，為了證明它，我們把它變得更廣泛、更強些，反倒好證了。
箇中原因說穿了便不難理解，
函數 <code class="haskell">steepsum</code> 便是一個容易明白的好例子：一個函數若傳回較多資訊，在遞迴呼叫它時，我們便有更多資訊可直接取用。
同樣地，一個定理若保證更強的性質，表示在使用歸納假設的步驟中，我們有了更強的性質可用。</p><p>如果我們把一個函數或待證的定理擴充得太強，確實也有可能使它們強到寫不出來、證不出來。
做歸納定義或證明的重要技巧之一，便是找到這麼一個平衡點：將一個待定義或證明的物件擴充到足以提供歸納步驟需要的所有資訊，又不至於強到無法寫出、證出。</p><p>在這一節以及下一節中，我們都會看到許多如此的例子。</p><h3 class="subsection" id="sec:repl-tree">5.5.2 以串列標記樹狀結構</h3><p>我們再舉一個組對的好例子。回顧第 <a href="Basics-10.html#sec:user-defined-data">1.10 </a>與<a href="Induction-8.html#sec:other-inductive-datatypes">2.8 </a>節中提及的外標籤二元樹：</p><pre><code class="spec">data ETree a  = Tip a | Bin (ETree a) (ETree a) 
</code></pre><p>下述函數 <code class="haskell">size :: ETree a -&gt; Int</code> 計算一棵樹中標籤的數目（對 <code class="haskell">ETree</code> 而言是 <code class="haskell">Tip</code> 出現的次數）； <code class="haskell">repl t xs</code> 則將 <code class="haskell">t</code> 原有的標籤丟棄，改用串列 <code class="haskell">xs</code> 由右至左依序重新為 <code class="haskell">t</code> 上標籤。
觀察：在遞迴呼叫中，我們用 <code class="haskell">take</code> 和 <code class="haskell">drop</code> 將串列 <code class="haskell">xs</code> 截成適當的長度：</p><pre><code class="haskell">size (Tip _)    = 1
size (Bin t u)  = size t + size u 

repl :: ETree a -&gt; List b -&gt; ETree b
repl (Tip _)    xs = Tip (head xs)
repl (Bin t u)  xs = Bin (repl t (take n xs)) (repl u (drop n xs))
    where n = size t 
</code></pre><p>如果 <code class="haskell">t</code> 是一個向左傾斜的二元樹，<code class="haskell">repl t xs</code> 不僅會反覆計算 <code class="haskell">size</code>，也會反覆地將 <code class="haskell">take</code> 與 <code class="haskell">drop</code> 用在 <code class="haskell">xs</code> 上，使得上述的 <code class="haskell">repl</code> 成為一個 $O(n^2)$ 的演算法。
利用組對的技巧，我們能讓 <code class="haskell">repl</code> 的時間複雜度小一些嗎？</p><p>我們試著把 <code class="haskell">repl</code> 作用在一個稍微左斜的樹，<code class="haskell">(Bin (Bin t u) v)</code> 之上，看看有什麼能做的。
令 <code class="haskell">t</code>, <code class="haskell">u</code> 的 <code class="haskell">size</code> 分別為 <code class="haskell">n1</code> 與 <code class="haskell">n2</code>.
如果我們希望導出一個線性時間的程式，其中一個提示是：我們希望在 <code class="haskell">repl (Bin (Bin t u) v) xs</code> 中，<em><code class="haskell">xs</code> 的每個元素最多都只被 <code class="haskell">take</code> 和 <code class="haskell">drop</code> 各碰過一次</em>。
依此原則，以下的推導基嘗試做到兩點：首先，把連續的 <code class="haskell">take</code> 消去；其次，若已做了 <code class="haskell">take n1 xs</code>，就避免再出現 <code class="haskell">take (n1 + n2) xs</code>，因為後者的存在會讓 <code class="haskell">take</code> 重複處理 <code class="haskell">xs</code> 中的元素。
我們會用到習題 <a href="Induction-10.html#ex:take-take">2.39 </a> -- <a href="Induction-10.html#ex:drop-drop">2.41 </a> 中提到的三個性質：</p><pre><code class="equation">|take m (take (m+n) xs)| ~&=~ |take m xs|
\mbox{~~,}\\
|drop m (take (m + n) xs)| ~&=~ |take n (drop m xs)|\mbox{~~,}\\
|drop (m + n) xs| ~&=~ |drop n (drop m xs)| \mbox{~~.}</code>    (5.4 )
</pre><p>其中 <code class="haskell">m</code>, <code class="haskell">n</code> 均為自然數。試演算如下：</p><pre><code class="haskell">      repl (Bin (Bin t u) v) xs
 ===    <comment>{- <code class="haskell">repl</code> 之定義，兩次 -}</comment>
      Bin  (Bin  (repl t (take n1 (take (n1+n2) xs)))
                 (repl u (drop n1 (take (n1+n2) xs))))
           (repl v (drop (n1+n2) xs))
 ===    <comment>{- 習題 \ref{ex:take-take} -- \ref{ex:drop-drop} -}</comment>
      Bin  (Bin  (repl t (take n1 xs))
                 (repl u (take n2 (drop n1 xs))))
           (repl v (drop n2 (drop n1 xs)))  
</code></pre><p>演算到此，與 <code class="haskell">t</code> 有關的是 <code class="haskell">repl t</code>, <code class="haskell">take (size t)</code>, 與 <code class="haskell">drop (size t)</code> 三項；
與 <code class="haskell">u</code> 有關的是 <code class="haskell">repl u</code>, <code class="haskell">take (size u)</code>, 與 <code class="haskell">drop (size u)</code> 三項。
如果我們把 <code class="haskell">repl t</code>, <code class="haskell">take (size t)</code>, 與 <code class="haskell">drop (size t)</code> 取出，當作一個函數之內完成的動作：</p><pre><code class="haskell">repTail :: ETree a -&gt; List b -&gt; (ETree b × List b)
repTail s xs = (repl s (take n xs), drop n xs) 
  where n = size s 
</code></pre><p>那麼 <code class="haskell">Bin (repl t (take n1 xs)) (repl u (take n2 (drop n1 xs)))</code> 似乎有可能收回成為這樣的式子：<code class="haskell">xs</code> 先被丟給 <code class="haskell">repTail t</code>，將 <code class="haskell">t</code> 標記好，並得到剩下的串列 <code class="haskell">drop n1 xs</code>。這個剩下的串列又可以丟給 <code class="haskell">repTail u</code>, 兩者都只把 <code class="haskell">xs</code> 走過一次。
我們試著導出 <code class="haskell">repTail</code> 的歸納定義。
基底狀況 <code class="haskell">s := Tip y</code> 比較容易，我們考慮 <code class="haskell">s := Bin t u</code> 的情況，
並演算如下（令 <code class="haskell">n1 = size t</code>，<code class="haskell">n2 = size u</code>, 因此 <code class="haskell">size (Bin t u)= n1 + n2</code>）：</p><pre><code class="haskell">      repTail (Bin t u) xs
 ===   <comment>{- <code class="haskell">repTail</code> 之定義 -}</comment>
      (repl (Bin t u) (take (n1 + n2) xs), drop (n1 + n2) xs)
 ===   <comment>{- <code class="haskell">repl</code> 之定義，令 <code class="haskell">n1 = size t</code> -}</comment>
      (Bin  (repl t (take n1 (take (n1 + n2) xs)))
            (repl u (drop n1 (take (n1 + n2) xs))), drop (n1 + n2) xs)
 ===   <comment>{- 習題 \ref{ex:take-take} -- \ref{ex:drop-drop} -}</comment>
      (Bin  (repl t (take n1 xs))
            (repl u (take n2 (drop n1 xs))), drop n2 (drop n1 xs))
 ===   <comment>{- 提出共同項 -}</comment>
      let  (t', xs')   = (repl t (take n1 xs),  drop n1 xs)
           (u', xs'')  = (repl u (take n2 xs'), drop n2 xs')
      in (Bin t' u', xs'')
 ===   <comment>{- <code class="haskell">repTail</code> 之定義 -}</comment>
      let  (t', xs')   = repTail t xs
           (u', xs'')  = repTail u xs'
      in (Bin t' u', xs'') 
</code></pre><p>因此我們得到：</p><pre><code class="spec">repTail (Tip _)    xs =  (Tip (head xs), tail xs)
repTail (Bin t u)  xs =  let  (t', xs')   = repTail t xs
                              (u', xs'')  = repTail u xs'
                         in (Bin t' u', xs'') 
</code></pre><p>確實如同所預期的，串列 <code class="haskell">xs</code> 被 <code class="haskell">repTail t</code> 使用，得到標籤過的新樹 <code class="haskell">t'</code>, 和剩下的串列 <code class="haskell">xs'</code>. 後者再被 <code class="haskell">repTail u</code> 用來給 <code class="haskell">u</code> 上標籤。最後我們得傳回剩下的串列 <code class="haskell">xs''</code>. 實際上把串列變短的動作發生在基底狀況 <code class="haskell">repTail (Tip _)</code> 中。串列中的每個元素只會在每次遇見 <code class="haskell">Tip</code> 時被取出一次，因此這是一個線性時間的演算法。</p><p>\todo{<code class="haskell">repsort t = rep t (sort (leaves t []))</code>.}</p><p><a href="../Biblio.html#BurstallDarlington:77:Transformation">Burstall and Darlington [1977]</a></p><div class="exlist"><div class="exercise exer" id="ex:ascendingTuple"><h5 class="exercise-title">練習 5.14 </h5><p>下述函數 <code class="haskell">ascending :: List Int -&gt; Bool</code> 判斷一個串列是否由左到右遞增：</p><pre><code class="haskell">ascending :: List Int -&gt; Bool
ascending []      = True
ascending (x:xs)  = x &lt;= minimum xs ⋀ ascending xs 
</code></pre><p>當輸入串列長度為 <code class="haskell">n</code>, 這個函數需要 $O(n^2)$ 個基本運算。請用組對的方式將之減少至 $O(n)$.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-14" type="checkbox"/><label class="lbl-toggle" for="ans-5-14">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>考慮如下的定義：</p><pre><code class="spec">ascMin :: List Int -&gt; (Bool × Int)
ascMin = fork ascending minimum 
</code></pre><p>如果 <code class="haskell">ascMin</code> 有更快的實作，我們可定義 <code class="haskell">ascending = fst . ascMin</code>.</p><p>當輸入為 <code class="haskell">[]</code>, 我們有 <code class="haskell">ascMin [] = (True, maxBound)</code>. 考慮當輸入為 <code class="haskell">x:xs</code> 的情況：</p><pre><code class="haskell">      ascMin (x:xs)
 ===   <comment>{- <code class="haskell">ascMin</code> 之定義 -}</comment>
      (ascending (x:xs), minimum (x:xs))
 ===   <comment>{- <code class="haskell">ascending</code> 與 <code class="haskell">minimum</code> 之定義 -}</comment>
      (x &lt;= minimum xs ⋀ ascending xs, x ↓ minimum xs)
 ===   <comment>{- 引入區域變數 -}</comment>
      let (b, y) = (ascending xs, minimum xs)
      in (x &lt;= y ⋀ b, x ↓ y)
 ===   <comment>{- <code class="haskell">ascMin</code> 之定義 -}</comment>
      let (b, y) = ascMin xs
      in (x &lt;= y ⋀ b, x ↓ y) 
</code></pre><p>如此，我們已導出：</p><pre><code class="haskell">ascMin :: List Int -&gt; (Bool, Int)
ascMin []      = (True, maxBound)
ascMin (x:xs)  =  let (b, y) = ascMin xs
                  in (x &lt;= y ⋀ b, x ↓ y) 
</code></pre></div></div></div><div class="exlist"><div class="exercise exer" id="ex:baobab-ITree"><h5 class="exercise-title">練習 5.15 </h5><p>回顧第 <a href="Basics-10.html#sec:user-defined-data">1.10 </a> 節中談到的 <code class="haskell">ITree</code>:</p><pre><code class="spec">data ITree a = Null | Node a (ITree a) (ITree a) 
</code></pre><p><em>猴麵包樹(baobab)</em>，又稱猢猻木，是一種樹幹相當粗的樹。
<input class="toggle" id="footnote-5-5-5" type="checkbox"/><label class="fnote-toggle" for="footnote-5-5-5">(註5) </label><span class="collapsible-footnote">猴麵包樹原產於馬達加斯加、非洲等地，也被寫進了《小王子》之中。</span>
如果一個 <code class="haskell">ITree Int</code> 的<em>每個</em>標籤都大於其兩個子樹的標籤總和，我們便說它是一棵猴麵包樹。
以下的函數判定一棵樹是否為猴麵包樹（其中 <code class="haskell">sumT :: ITree Int -&gt; Int</code> 計算一個樹中所有標籤的總和）：</p><pre><code class="haskell">baobab :: ITree Int -&gt; Bool
baobab Null          =  True
baobab (Node x t u)  =  baobab t ⋀ baobab u ⋀
                          x &gt; (sumT t + sumT u) 
</code></pre><p>因反覆呼叫 <code class="haskell">sumT</code>, 當樹的大小為 <code class="haskell">n</code> 時，<code class="haskell">baobab</code> 的執行時間為 $O(n^2)$.
請使用組對的技巧，在 $O(n)$ 的時間內算出 <code class="haskell">baobab</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-15" type="checkbox"/><label class="lbl-toggle" for="ans-5-15">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>考慮如下的定義：</p><pre><code class="spec">baosum :: Tree Int -&gt; (Bool, Int)
baosum = fork baobab sumT 
</code></pre><p>如果 <code class="haskell">baosum</code> 有時間效率為 $O(n)$ 的定義，我們可重定義 <code class="haskell">baobab = fst . baosum</code>.
當 <code class="haskell">t := Null</code>, 我們有 <code class="haskell">baosum Null = (True, 0)</code>.
考慮 <code class="haskell">t := Node x t u</code>:</p><pre><code class="haskell">     baosum (Node x t u)
 ===    <comment>{- <code class="haskell">baosum</code> 之定義 -}</comment>
     (baobab (Node x t u), sumT (Node x t u))
 ===    <comment>{- <code class="haskell">baobab</code> 與 <code class="haskell">sumT</code> 之定義 -}</comment>
     (  baobab t ⋀ baobab u ⋀ x &gt; (sumT t + sumT u),
        x + sumT t + sumT u)
 ===    <comment>{- 引入區域變數 -}</comment>
     let  (b,y) = (baobab t, sumT t)
          (c,z) = (baobab u, sumT u)
     in (b ⋀ c ⋀ x &gt; (y + z), x + y + z)
 ===    <comment>{- <code class="haskell">baosum</code> 之定義 -}</comment>
     let  (b,y) = baosum t
          (c,z) = baosum u
     in (b ⋀ c ⋀ x &gt; (y + z), x + y + z) 
</code></pre><p>如此，我們已經導出：</p><pre><code class="haskell">baosum Null          = (True, 0)
baosum (Node x t u)  =
  let  (b,y) = baosum t
       (c,z) = baosum u
  in (b ⋀ c ⋀ x &gt; (y + z), x + y + z) 
</code></pre></div></div></div><div class="exlist"><div class="exercise exer" id="ex:deepest"><h5 class="exercise-title">練習 5.16 </h5><p>本題出自<a href="../Biblio.html#HuIwasaki:97:Tupling">Hu et al. [1997]</a>。
函數 <code class="haskell">depth</code> 定義一棵 <code class="haskell">ETree</code> 的<em>深度</em>。
<code class="haskell">Tip</code> 的深度為零，<code class="haskell">Bin</code> 的深度則為兩子樹中較深者的深度加一：</p><pre><code class="haskell">depth :: ETree a -&gt; Nat
depth (Tip _)    = Zero
depth (Bin t u)  = Suc (depth t ↑ depth u) 
</code></pre><p>下列函數 <code class="haskell">deepest</code> 則傳回一棵樹中最深的標籤：</p><pre><code class="haskell">deepest :: ETree a -&gt; List a
deepest (Tip x)    = [x]
deepest (Bin t u)  | m &lt;  n  = deepest u
                   | m == n  = deepest t ++ deepest u
                   | m &gt;  n  = deepest t
    where (m,n) = (depth t, depth u) 
</code></pre><p>請用組對的技巧，避免重複計算 <code class="haskell">depth</code>.
<strong>注意</strong>: 完成的程式中，<code class="haskell">(++)</code> 仍可能需要 $O(n^2)$ 的時間。
我們將在習題<a href="Derivation-6.html#ex:deepestAux">5.31 </a>處理這個問題。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-16" type="checkbox"/><label class="lbl-toggle" for="ans-5-16">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>定義：</p><pre><code class="spec">dd :: ETree a -&gt; (List a, Nat)
dd = fork deepest depth 
</code></pre><p>顯然 <code class="haskell">dd (Tip x) = ([x], 0)</code>.
以下我們考慮歸納情況時，用一個非標準的語法同時處理守衛算式的三個式子：</p><pre><code class="spec">      dd (Bin t u)
 ===   <comment>{- <code class="haskell">dd</code>, <code class="haskell">deepest</code>, 與 <code class="haskell">depth</code> 之定義 -}</comment>
      (  ( m &lt;  n  -&gt; deepest u
         | m == n  -&gt; deepest t ++ deepest u
         | m &gt;  n  -&gt; deepest t), 1 + (m ↑ n))
      where (m,n) = (depth t, depth u)
 ===   <comment>{- 取出 <code class="haskell">deepest t</code> 與 <code class="haskell">deepest u</code> -}</comment>
      (  ( m &lt;  n  -&gt; ys
         | m == n  -&gt; xs ++ ys
         | m &gt;  n  -&gt; xs), 1 + (m ↑ n))
      where ((xs,m),(ys,n)) = ((deepest t,depth t), (deepest u, depth u))
 ===   <comment>{- <code class="haskell">dd</code> 之定義，函數分配進條件判斷 -}</comment>
      ( m &lt;  n  -&gt; (ys, 1 + n)
      | m == n  -&gt; (xs ++ ys, 1 + n)
      | m &gt;  n  -&gt; (xs, 1 + m))
      where ((xs,m),(ys,n)) = (dd t, dd u) 
</code></pre><p>因此我們得到：</p><pre><code class="haskell">dd (Tip x)    = ([x],0)
dd (Bin t u)  | m &lt;  n  = (ys, 1 + n)
              | m == n  = (xs ++ ys, 1 + n)
              | m &gt;  n  = (xs, 1 + m) 
  where ((xs,m),(ys,n)) = (dd t, dd u) 
</code></pre></div></div></div><div class="exlist"><div class="exercise exer" id="ex:red-black-tree-balanced-linear-time"><h5 class="exercise-title">練習 5.17 </h5><p>第 <a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 </a> 節中的函數 <code class="haskell">balanced :: RBTree -&gt; Bool</code> 檢查一棵紅黑樹是否平衡。由於重複呼叫 <code class="haskell">bheight</code>, 這是一個需要 $O(n^2)$ 時間的函數。請用組對的技巧推導出一個可在線性時間內判斷平衡的版本。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-17" type="checkbox"/><label class="lbl-toggle" for="ans-5-17">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>定義：</p><pre><code class="spec">balHeight :: RBTree -&gt; (Bool, Nat)
balHeight = fork balanced bheight 
</code></pre><p>我們有 <code class="haskell">balanced = fst . balHeight</code>.
顯然 <code class="haskell">balHeight E = (True, 0)</code>.
考慮 <code class="haskell">B t x u</code> 的狀況：</p><pre><code class="spec">  balHeight (B t x u)
=   <comment>{- <code class="haskell">balHeight</code> 之定義 -}</comment>
  (balanced (B t x u), bheight (B t x u))
=   <comment>{- <code class="haskell">balanced</code> 與 <code class="haskell">bheight</code> 之定義 -}</comment>
  (bheight t == bheight u ⋀ balanced t ⋀ balanced u,
   1 + (bheight t ↑ bheight u))
=   <comment>{- 將 <code class="haskell">balanced</code> 與 <code class="haskell">bheight</code> 的呼叫取出 -}</comment>
  let  (bt,  ht)  = (balanced t, bheight t)
       (bu,  hu)  = (balanced u, bheight u)
  in   (ht == hu ⋀ bt ⋀ bu, 1 + (ht ↑ hu))
=   <comment>{- <code class="haskell">balHeight</code> 之定義 -}</comment>
  let  (bt,  ht)  = balHeight t
       (bu,  hu)  = balHeight u
  in   (ht == hu ⋀ bt ⋀ bu, 1 + (ht ↑ hu)) 
</code></pre><p>當輸入為 <code class="haskell">R t x u</code> 的情況亦雷同。我們可推導出：</p><pre><code class="spec">balHeight :: RBTree -&gt; (Bool, Nat)
balHeight E          =  (True, 0)
balHeight (R t x u)  =  let  (bt,  ht)  = balHeight t
                             (bu,  hu)  = balHeight u
                        in   (ht == hu ⋀ bt ⋀ bu, (ht ↑ hu))
balHeight (B t x u)  =  let  (bt,  ht)  = balHeight t
                             (bu,  hu)  = balHeight u
                        in   (ht == hu ⋀ bt ⋀ bu, 1 + (ht ↑ hu)) 
</code></pre></div></div></div><h3 class="subsection" id="sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</h3><p>下列函數 <code class="haskell">minE</code> 曾出現在第 <a href="Induction-8.html#sec:other-inductive-datatypes">2.8 </a> 節中，找出一棵 <code class="haskell">ETree</code> 中最小的值。
函數 <code class="haskell">rep</code> 則可視為 <code class="haskell">repl</code> 的簡單版，將樹中的每個標籤都代換成同一個值 <code class="haskell">y</code>。</p><div class="multicols"><div class="mcol" width="0.45\textwidth"><pre><code class="haskell">minE :: ETree Int -&gt; Int
minE (Tip x)    = x
minE (Bin t u)  = minE t ↓ minE u 
</code></pre></div><div class="mcol" width="0.5\textwidth"><pre><code class="haskell">rep :: b -&gt; ETree a -&gt; ETree b
rep y (Tip _)   = Tip y
rep y (Bin t u) = Bin (rep y t) (rep y u) 
</code></pre></div></div><p>給一棵樹 <code class="haskell">t</code>, 我們要把 <code class="haskell">t</code> 之中的每個標籤都代換成 <code class="haskell">t</code> 的最小標籤。
直觀的做法是寫成 <code class="haskell">let m = minE t in rep t m</code>.
如此一來，<code class="haskell">t</code> 會被走訪兩次，第一次被<code class="haskell">minE</code> 走訪以計算 <code class="haskell">m</code>, 第二次由 <code class="haskell">rep</code> 進行代換。
<a href="../Biblio.html#Bird:84:Circular">Bird [1984]</a> 提出挑戰：有可能在只把 <code class="haskell">t</code> 走訪一次的情況下，完成上述工作嗎？</p><p>以下函數 <code class="haskell">repmin</code> 同時傳回代換過後的樹，以及原樹中的最小標籤：</p><pre><code class="spec">repmin :: ETree Int -&gt; a -&gt; (ETree a × Int)
repmin y = fork (rep y) minE 
</code></pre><p>使用本節的技巧，讀者們應該已經可以為 <code class="haskell">repmin</code> 導出如下的歸納定義：</p><pre><code class="haskell">repmin y (Tip x)    =  (Tip y, x)
repmin y (Bin t u)  =  let  (t', m) = repmin y t
                            (u', n) = repmin y u
                       in (Bin t' u', m ↓ n) 
</code></pre><p>該定義只將 <code class="haskell">t</code> 走訪一次。然後我們定義：</p><pre><code class="haskell">transform :: ETree Int -&gt; ETree Int
transform t =  let (t', m) = repmin m t in t' 
</code></pre><p>函數 <code class="haskell">transform</code> 用 <code class="haskell">repmin</code> 算出 <code class="haskell">t</code> 的最小標籤 <code class="haskell">m</code>, 同時又用 <code class="haskell">m</code> 來標記 <code class="haskell">t</code>... 於是，似乎確實用一次走訪就完成了兩件事！這是怎麼做到的呢？</p><p>函數 <code class="haskell">transform</code> 有個特殊之處：變數 <code class="haskell">m</code> 既是 <code class="haskell">repmin</code> 的傳回值，又是其參數。
這是一個<em>循環程式</em>(<em>circular program</em>)。
<span id="ix-5-8"></span>
這樣的程式之所以能正常終止，有賴於 Haskell 的範式順序/惰性求值（見第頁）。實際上發生的事情如此：假設輸入為</p><pre><code class="haskell">t = Bin  (Bin (Tip 4) (Tip 2))
         (Bin (Bin (Tip 3) (Tip 1)) (Tip 5))
</code></pre><p><code class="haskell">repmin</code> 將輸入 <code class="haskell">t</code> 走訪一遍，邊走邊建立了一個未算出的算式 <code class="haskell">(4 ↓ 2) ↓ ((3 ↓ 1) ↓ 5)</code>.
該算式就是 <code class="haskell">m</code> 的值，其實也可視作一棵樹，其結構和 <code class="haskell">t</code> 一樣，只是把每個 <code class="haskell">Bin</code> 代換成 <code class="haskell">min</code>.
函數 <code class="haskell">repmin</code> 的另一項工作是新建一棵樹 <code class="haskell">t'</code>，該樹之中每個 <code class="haskell">Tip</code> 的標籤都指到這個算式。
根據範式順序求值，這個算式還不用立刻被算出來。直到我們終於不得不算出它，例如當 <code class="haskell">t'</code> 被傳回，我們要求電腦把 <code class="haskell">t'</code> 印出來，或著有別的函數需檢查 <code class="haskell">t'</code> 中的標籤時，該算式才被歸約成一個數字 --- 這需要把該算式走訪一遍。
（但，根據惰性求值，一但 <code class="haskell">m</code> 被算成一個數字，下次使用 <code class="haskell">m</code> 時就不再需要反覆計算了。）</p><p>需注意，雖然「<code class="haskell">t</code>只被走訪一次」確實成立，這並不表示 <code class="haskell">transform</code> 必然比老實將樹走訪兩次的程式快 --- 效率是個複雜的問題，本章將陸續談到更多。我的建議是：循環程式應視為有趣、優雅的謎題，而不是以效率為目的的程式設計技巧。</p><h3 class="subsection" id="sec:tupling-conclude">5.5.4 小結與提醒</h3><p>「組對」的技巧讓函數多傳回一些值。我們可能藉此省下一些重複的計算，增進效率。</p><p>我們自然想問：給一個有重複計算、待改進的函數 <code class="haskell">f</code>, 怎知道該讓它多傳回什麼值？
在本節的例子中，我們可由符號演算看出一些端倪：
將 <code class="haskell">f</code> 的定義展開，辨識出被重複計算的子算式，這些子算式就可能用來與原函數組對。
但廣泛說來，「將一個函數或性質通用化」是編程與證明中最困難、最需要經驗、智慧的一步。
只要找到正確的通用化，例如 <code class="haskell">steepsum</code> 或 <code class="haskell">repTail</code>, 剩下的推導都可相當機械化地進行。
唯有「通用化」這一步，我們無法保證有任何機械化、公式化的方法可作為解決所有問題的萬靈丹 ---
否則編程就是一件可完全自動化的事情了。</p><p>雖然如此，我們仍希望基於符號演算的形式方法能給我們一定程度的幫助與指引。
程式語言研究的目標之一便是分辨出編程的過程中，哪些部分是瑣碎、機械化的，哪些部分是真正需要靈感與智慧的，並且盡量使用符號幫助，使我們在進行思考時有更多工具。</p><p>組對可用於減少走訪資料結構的次數，但這麼做並不見得有效率上的好處。
例如，以下函數計算一個串列中元素的平均值：</p><pre><code class="spec">average xs = sum xs / length xs 
</code></pre><p>利用組對，我們可以另定義一個函數 <code class="haskell">sumlen = fork sum length</code>,
並推導其歸納定義，在一次走訪中同時計算串列的和與長度：</p><pre><code class="haskell">sumlen []      =  (0,0)
sumlen (x:xs)  =  let (s,l) = sumlen xs
                  in (x + s, 1 + l) 
</code></pre><p>然後平均便可定義成 <code class="haskell">average' xs = let (s,l) = sumlen xs in s/l</code>.</p><p>然而，根據<a href="../Biblio.html#HuIwasaki:97:Tupling">Hu et al. [1997]</a>，<code class="haskell">average'</code> 通常比 <code class="haskell">average</code> 慢。
兩者都是 $O(n)$ 的演算法。
函數 <code class="haskell">sumlen</code> 在傳回值時會產生一個序對，該序對立刻被上層拆掉。
因此 <code class="haskell">average'</code> 每處理一個元素耗費的時間較多，往往不如乾脆將 <code class="haskell">xs</code> 走訪兩次。
<a href="../Biblio.html#HuIwasaki:97:Tupling">Hu et al. [1997]</a> 認為需有更有效率的序對實作法，組對才是值得做的轉換。</p><div class="exlist"><div class="exercise exer" id="ex:allpairs"><h5 class="exercise-title">練習 5.18 </h5><p>函數 <code class="haskell">allpairs</code> 傳回輸入串列中任兩個元素（依其原本順序）形成的序對。
例如 <code class="haskell">allpairs [1,2,3,4]</code> 可得到 <code class="haskell">[(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]</code>。</p><pre><code class="haskell">allpairs :: List a -&gt; List (a × a)
allpairs []      = []
allpairs (x:xs)  = map (\y -&gt; (x,y)) xs ++ allpairs xs 
</code></pre><p>而 <code class="haskell">maxdiff</code> 則計算一個串列中任兩元素前者與後者的最大差：</p><pre><code class="haskell">maxdiff :: List Int -&gt; Int
maxdiff = maximum . map (\(x,y) -&gt; x - y) . allpairs 
</code></pre><p>當輸入串列長度為 <code class="haskell">n</code>, 如此定義的 <code class="haskell">maxdiff</code> 是一個需時 $O(n^2)$ 的演算法。
定義：</p><pre><code class="spec"> mdm xs = (maxdiff xs, ???) 
</code></pre><p>找出 <code class="haskell">???</code> 可能的值，使得 <code class="haskell">mdm</code> 能在 $O(n)$ 時間之內完成計算。
你可假設以下性質：</p><pre><code class="equation" id="eq:max-minus">  & |maximum (map (x-) xs) = x - minimum xs| \mbox{~~.}</code>    (5.5 )
</pre><p>並假設 <code class="haskell">maximum</code> 與 <code class="haskell">minimum</code> 在空串列上的值分別為 <code class="haskell">-infty</code> 與 <code class="haskell">infty</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-18" type="checkbox"/><label class="lbl-toggle" for="ans-5-18">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>由 ([RefUndefined]) 我們推測：</p><pre><code class="spec">mdm :: List Int -&gt; (Int × Int)
mdm xs = (maxdiff xs, minimum xs) 
</code></pre><p>我們試圖找出 <code class="haskell">mdm</code> 的歸納定義。顯然 <code class="haskell">mdm [] = (-infty, infty)</code>.
考慮歸納情況（令 <code class="haskell">minus (x,y) = x-y</code>）：</p><pre><code class="haskell">      mdm (x:xs)
 ===    <comment>{- <code class="haskell">mdm</code>, <code class="haskell">maxdiff</code>, 與 <code class="haskell">minimum</code> 之定義 -}</comment>
      (maximum (map minus (allpairs (x:xs))), x ↓ minimum xs)
 ===  (  maximum (map minus (map (\y -&gt; (x,y)) xs ++ allpairs xs)),
         x ↓ minimum xs) 
</code></pre><p>集中焦點在序對的第一個元素：</p><pre><code class="haskell">      maximum (map minus (map (\y -&gt; (x,y)) xs ++ allpairs xs))
 ===     <comment>{- 因 <code class="haskell">map f (xs ++ ys) = map f xs ++ map f ys</code> (習題 \ref{ex:map-append}) -}</comment>
      maximum (  map minus (map (\y -&gt; (x,y)) xs) ++
                 map minus (allpairs xs))
 ===     <comment>{- <code class="haskell">map</code>-fusion -}</comment>
      maximum (map (x-) xs ++ map minus (allpairs xs))
 ===     <comment>{- 因 <code class="haskell">maximum (xs ++ ys) = maximum xs ↑ maximum ys</code> -}</comment>
      maximum (map (x-) xs) ↑ maximum (map minus (allpairs xs))
 ===     <comment>{- 因 \eqref{eq:max-minus} -}</comment>
      (x - minimum xs) ↑ maximum (map minus (allpairs xs))
 ===     <comment>{- <code class="haskell">maxdiff</code> 之定義 -}</comment>
      (x - minimum xs) ↑ maxdiff xs 
</code></pre><p>回到推導主體：</p><pre><code class="haskell">      mdm (x:xs)
 ===    <comment>{- 上述計算 -}</comment>
      ((x - minimum xs) ↑ maxdiff xs , x ↓ minimum xs)
 ===    <comment>{- 使用 <code class="haskell">let</code> -}</comment>
      let (y, z) = (maxdiff xs, minimum xs)
      in ((x - z) ↑ y, x ↓ z)
 ===    <comment>{- <code class="haskell">mdm</code> 之定義 -}</comment>
      let (y, z) = mdm xs
      in ((x - z) ↑ y, x ↓ z)  
</code></pre><p>於是我們得知：</p><pre><code class="haskell">mdm []      =  (minBound, maxBound)
mdm (x:xs)  =  let (y, z) = mdm xs
               in ((x - z) ↑ y, x ↓ z)  
</code></pre></div></div></div></div><div class="navi"><div class="previous">&laquo;<a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></div><div class="next"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
