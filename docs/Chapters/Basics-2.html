<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" checked type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:basics">1 值、函數、與定義</h1></div><div class="navi"><div class="previous">&laquo;<a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></div><div class="next"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:function-defns">1.2 函數定義</h2><p>考慮如下的函數定義：</p><pre><code class="spec">smaller :: Int -&gt; Int -&gt; Int
smaller x y = if x &lt;= y then x else y 
</code></pre><p>我們可粗略地理解為：<code class="haskell">smaller</code> 是一個函數，拿兩個參數 <code class="haskell">x</code> 與 <code class="haskell">y</code>，傳回其中較小的那個。
如 <code class="haskell">smaller (double 6) (3+4)</code> 的值為 <code class="haskell">7</code>.</p><div class="exlist"><div class="exercise exer" id="ex:smaller-normal-form"><h5 class="exercise-title">練習 1.3 </h5><p>用前一節介紹的求值順序，將<code class="haskell">smaller (double 6) (3+4)</code>化簡為範式。</p></div></div><p><b>守衛</b> &emsp; 如果函數本體做的第一件事就是條件判斷，Haskell 提供另一種語法：</p><pre><code class="spec">smaller :: Int -&gt; Int -&gt; Int
smaller x y  | x &lt;= y  = x
             | x &gt; y   = y 
</code></pre><p>這麼寫出的 <code class="haskell">smaller</code> 的行為仍相同：如果 <code class="haskell">x &lt;= y</code> 成立，傳回 <code class="haskell">x</code>；如果 <code class="haskell">x &gt; y</code>, 傳回 <code class="haskell">y</code>。
但這種語法較接近一些數學教科書中定義函數的寫法。
其中，放在 <code class="haskell">x &lt;=y</code> 和 <code class="haskell">x &gt; y</code> 等位置的必須是型別為 <code class="haskell">Bool</code> 的算式。
它們擋在那兒，只在值為 <code class="haskell">True</code> 的時候才讓執行「通過」，因此被稱為<em>守衛</em>(<em>guard</em>)<span id="ix-1-13"></span>。
如果有三個以上的選項，如下述例子，使用守衛比 <code class="haskell">if .. then.. else</code> 更清晰可讀：</p><pre><code class="spec">sign :: Int -&gt; Int
sign x  | x &gt; 0   = 1
        | x == 0  = 0
        | x &lt; 0   = -1 
</code></pre><p>遇到數個守衛時，Haskell 將<em>依照順序</em>嘗試每個選項，直到碰到第一個為真的守衛，然後只執行該項定義。
也就是說， 即使我們把 <code class="haskell">sign</code> 定義中的 <code class="haskell">x == 0</code> 改為 <code class="haskell">x &gt;= 0</code>, <code class="haskell">sign 10</code> 的值仍會是 <code class="haskell">1</code>。
若每個守衛都是 <code class="haskell">False</code>, 程式則將中斷執行（並傳回一個錯誤訊息）。
在許多程式中，我們會希望最後一個守衛能捕捉所有的漏網之魚：如果其他條款都不適用，就執行最後一個。一種做法是讓一個守衛是 <code class="haskell">True</code>。或著，在 Haskell 中有個 <code class="haskell">otherwise</code> 關鍵字可讓定義讀來更口語化些：</p><pre><code class="spec">sign :: Int -&gt; Int
sign x  | x &gt; 0      = 1
        | x == 0     = 0
        | otherwise  = -1 
</code></pre><p>事實上，<code class="haskell">otherwise</code> 的定義就是 <code class="haskell">otherwise = True</code>.</p><p><b>區域識別字</b> &emsp; Haskell 提供兩種宣告區域識別字的語法：<code class="haskell">let</code> 與 <code class="haskell">where</code>.
也許最容易理解的方式是用例子說明。</p><div class="theorem" id="eg:payment"><h5 class="theorem-title">例 1.1  </h5><p>工讀生每小時的時薪為新台幣 130 元。
假設一週有五個工作天，每天有八小時上班時間。
定義一個函數 <code class="haskell">payment :: Int -&gt; Int</code>，輸入某學生工作的週數，計算其薪資。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-3" type="checkbox"/><label class="lbl-toggle" for="ans-1-3">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>我們當然可直接用一個式子算出薪資。但為清楚起見，我們可用兩個區域識別字 <code class="haskell">days</code> 和 <code class="haskell">hours</code>,
分別計算該學生工作的日數和時數。如果用 <code class="haskell">let</code>, 可這麼做。</p><pre><code class="spec">payment :: Int -&gt; Int
payment weeks =  let  days   = 5 * weeks
                      hours  = 8 * days
                 in 130 * hours 
</code></pre><p><code class="haskell">let</code> 算式的語法為</p><pre><code class="spec">  let  x1 = e1
       x2 = e2 ....
  in e 
</code></pre><p>其中 <code class="haskell">e</code> 為整個算式的值，而 <code class="haskell">x1</code>, <code class="haskell">x2</code> 等等為區域識別字。兩個區域識別字的有效範圍包括 <code class="haskell">e</code>, 以及 <code class="haskell">e1</code> 與 <code class="haskell">e2</code>。</p><p>另一種語法是 <code class="haskell">where</code> 子句。若用它定義 <code class="haskell">payment</code>, 可寫成這樣：</p><pre><code class="spec">payment :: Int -&gt; Int
payment weeks = 130 * hours 
  where  hours  = 8 * days
         days   = 5 * weeks 
</code></pre></div></div><p>該用 <code class="haskell">let</code> 或是 <code class="haskell">where</code>?
大部份時候這可依個人習慣，看寫程式的人覺得怎麼說一件事情比較順。
使用 <code class="haskell">let</code> 時，敘事的順序是由小到大，先給「工作日數」、「工作時數」等小元件的定義，再用他們組出最後的式子 <code class="haskell">130 * hours</code>。
使用 <code class="haskell">where</code> 時則是由大到小，先說我們要算「工作時數乘以 130」，然後補充「其中，工作時數的定義是...」。</p><p>但，Haskell 之所以保留了兩種語法，是為了因應不同的用途。語法上，<code class="haskell">let</code> 是一個算式，可出現在算式中。如下的算式是合法的，其值為 <code class="haskell">24</code>:</p><pre><code class="spec">   (1 + 1) * (let y = double 5 in y + 2) 
</code></pre><p><code class="haskell">where</code> 子句的一般語法則如下例所示：</p><pre><code class="spec">f x0 = d0
   where y0 = e0
f x1 = d1
   where y1 = e1 
</code></pre><p>由語法設計上即可看出，子句 <code class="haskell">where y0 = e0</code> 只能放在 <code class="haskell">f x0 = ...</code> 的一旁當作補述，不能出現在 <code class="haskell">d0</code> 之中。
這個例子中， <code class="haskell">y0</code> 的有效範圍含括 <code class="haskell">d0</code> 與 <code class="haskell">e0</code>。另，<code class="haskell">e0</code> 可以使用 <code class="haskell">x0</code>.</p><p>算式中只能用 <code class="haskell">let</code>. 相對地，也有些只能使用 <code class="haskell">where</code> 的場合。我們來看
我們來看一個只能使用 <code class="haskell">where</code> 的例子：</p><div class="theorem" id="eg:payment2"><h5 class="theorem-title">例 1.2  </h5><p>延續例 <a href="#eg:payment">1.1 </a>。
今年起，新勞動法規規定工作超過 19 週的工讀生必須視為正式雇員，
學校除了薪資外，也必須付給勞保、健保費用。
學校需負擔的勞健保金額為雇員薪資的百分之六。請更新函數 <code class="haskell">payment</code>,
輸入某工讀生工作週數，計算在新規定之下，學校需為工讀生付出的總額。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-3" type="checkbox"/><label class="lbl-toggle" for="ans-1-3">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>一種可能寫法是先使用守衛，判斷工作週數是否大於 19：</p><pre><code class="spec">payment :: Int -&gt; Int
payment weeks  | weeks &gt; 19  = round (fromIntegral baseSalary * 1.06)
               | otherwise   = baseSalary 
 where  baseSalary = 130 * hours
        hours  = 8 * days
        days   = 5 * weeks 
</code></pre><p>在 <code class="haskell">where</code> 子句中，我們先算出不含勞健保費用的薪資，用識別字 <code class="haskell">baseSalary</code> 表達。
如果 <code class="haskell">weeks</code> 大於 <code class="haskell">19</code>, 我們得將 <code class="haskell">baseSalary</code> 乘以 <code class="haskell">1.06</code>；否則即傳回 <code class="haskell">baseSalary</code>.
函數 <code class="haskell">fromIntegral</code> 把整數轉為浮點數，<code class="haskell">round</code> 則把浮點數四捨五入為整數。
請注意：兩個被守衛的算式都用到了 <code class="haskell">baseSalary</code> ---
<code class="haskell">where</code> 子句中定義的識別字是可以跨越守衛的。
相較之下，<code class="haskell">let</code> 算式只能出現在等號的右邊，而在守衛 <code class="haskell">weeks &gt; 19 = ...</code> 之後出現的
<code class="haskell">let</code> 所定義出的區域識別字，顯然無法在 <code class="haskell">otherwise = ...</code> 之中被使用，反之亦然。</p></div></div><p><b>巢狀定義</b> &emsp; <code class="haskell">let</code> 算式之中還可有 <code class="haskell">let</code> 算式，
<code class="haskell">where</code> 子句中定義的識別字也可有自己的 <code class="haskell">where</code> 子句。
我們看看兩個關於 <code class="haskell">let</code> 的例子：</p><div class="theorem" id="eg:nested-recursive"><h5 class="theorem-title">例 1.3  </h5><p>猜猜看 <code class="haskell">nested</code> 和 <code class="haskell">recursive</code> 的值分別是什麼。
將他們載入 Haskell 直譯器，看看和你的猜測是否相同。</p><div class="multicols"><div class="mcol" width="0.4\textwidth"><pre><code class="spec">nested :: Int
nested =  let x = 3
          in (  let  x = 5
                in x + x) + x 
</code></pre></div><div class="mcol" width="0.4\textwidth"><pre><code class="spec">recursive :: Int
recursive =  let x = 3
             in  let x = x + 1
                 in x 
</code></pre></div></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-3" type="checkbox"/><label class="lbl-toggle" for="ans-1-3">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p><code class="haskell">nested</code> 的值是 <code class="haskell">13</code>，因為 <code class="haskell">x+x</code> 之中的 <code class="haskell">x</code> 在 <code class="haskell">let x = 5</code> 的範圍中,
而 <code class="haskell">.. + x</code> 中的 <code class="haskell">x</code> 則在 <code class="haskell">let x = 3</code> 的範圍中。<input class="toggle" id="footnote-1-2-6" type="checkbox"/><label class="fnote-toggle" for="footnote-1-2-6">(註6) </label><span class="collapsible-footnote">在各種語言中，範圍的設計都是為了給程式員方便：在寫子算式時，可不用擔心是否與外層的識別字撞名。在教學時，我們難免舉各種撞名的例子作為說明。若把這些刁鑽例子當作考題，就是違反設計者本意的發展了。</span>
至於 <code class="haskell">recursive</code> 的值，關鍵在於 <code class="haskell">x = x + 1</code> 中右手邊的 <code class="haskell">x</code> 指的是哪個。
若是 <code class="haskell">x = 3</code> 的那個 <code class="haskell">x</code>, 整個算式的值將是 <code class="haskell">4</code>. 若 <code class="haskell">x = x + 1</code> 中，
等號右手邊的 <code class="haskell">x</code> 也是左手邊的 <code class="haskell">x</code>, <code class="haskell">recursive</code> 就是 <code class="haskell">((..)+1)+1</code> , 沒有範式。
這兩種設計都有其道理。
Haskell 選了後者：在 <code class="haskell">let x = e in ...</code> 之中，<code class="haskell">x</code> 的有效範圍包括 <code class="haskell">e</code>.
因此 <code class="haskell">recursive</code> 在 Haskell 中會無窮地求值下去。
但也有些函數語言中的 <code class="haskell">let</code> 採用前者的設計。通常這類語言中會另有一個 $\Keyword{letrec}$
結構，和 Haskell 的 <code class="haskell">let</code> 功能相同。</p></div></div></div></div><div class="navi"><div class="previous">&laquo;<a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></div><div class="next"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
