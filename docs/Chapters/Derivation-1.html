<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" checked type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-selected pure-menu-item"><a href="#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:derivation">5 一般程式推導</h1></div><div class="navi"><div class="previous">&laquo;<a href="Derivation.html#ch:derivation">5 一般程式推導</a></div><div class="next"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:fold-unfold-transform">5.1 展開-收回轉換</h2><p>考慮這麼一個例子：給定一個整數形成的串列，我們想計算其每個數的平方的和。例如當輸入是<code class="haskell">[2,6,5,3]</code>, 我們希望算出 $2^2 + 6^2 + 5^2 + 3^2 = 74$. 這項工作可以簡短地描述如下：</p><p>函數 <code class="haskell">sumsq</code> 的型別為 <code class="haskell">List Int -&gt; Int</code>.
其中 <code class="haskell">map square</code> 將輸入串列的每個元素都平方，然後由 <code class="haskell">sum</code> 計算其總和。第<a href="Induction-4.html#sec:induction-lists">2.4 </a>節中給過一個 <code class="haskell">sum</code> 的歸納定義，重複如下：</p><pre><code class="spec">sum :: List Int -&gt; Int
sum []      = 0
sum (x:xs)  = x + sum xs 
</code></pre><p><b>消除中間串列</b> &emsp;
對大部分的應用而言，如上定義的 <code class="haskell">sumsq</code> 已經很堪用了。但作為一個例子，我們來挑惕些仍不滿意之處。執行 <code class="haskell">sumsq xs</code> 時，<code class="haskell">map square</code> 會產生另一個（存放 <code class="haskell">xs</code> 每個元素的平方的）串列，該串列隨即由 <code class="haskell">sum</code> 消掉 --- 感覺上似乎很浪費空間與時間。
<input class="toggle" id="footnote-5-1-1" type="checkbox"/><label class="fnote-toggle" for="footnote-5-1-1">(註1) </label><span class="collapsible-footnote">在惰性求值的情況下，該中間串列的<em>每個</em>節點被產生後立刻被 <code class="haskell">sum</code> 消去，因此不會真的佔用和 <code class="haskell">xs</code> 同樣長度的空間。這也是大家覺得惰性求值有助於模組化、使小函數變得易於重用的例子之一。但「產生一個新節點、立刻消去」仍耗了一些不必要的時間。</span>
有不產生這個中間串列的方法嗎？</p><p>我們試著做些計算。當 <code class="haskell">sumsq</code> 的參數是 <code class="haskell">[]</code> 時：</p><pre><code class="haskell">   sumsq []
 ===    <comment>{- <code class="haskell">sumsq</code> 之定義 -}</comment>
   sum (map square [])
 ===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
   sum []
 ===    <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
   0 
</code></pre><p>由此我們得知 <code class="haskell">sumsq []</code> 會被計算成 <code class="haskell">0</code>. 當輸入不是空串列時呢？試計算：</p><pre><code class="haskell">   sumsq (x:xs)
 ===    <comment>{- <code class="haskell">sumsq</code> 之定義 -}</comment>
   sum (map square (x:xs))
 ===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
   sum (square x : map square xs)
 ===    <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
   square x + sum (map square xs)
 ===    <comment>{- <code class="haskell">sumsq</code> 之定義 -}</comment>
   square x + sumsq xs 
</code></pre><p>可得知對任何 <code class="haskell">x</code> 與 <code class="haskell">xs</code>, <code class="haskell">sum (x:xs)</code> 歸約的結果和 <code class="haskell">square x + sumsq xs</code> 會是相同的。
總結說來，藉由計算，我們發現 <code class="haskell">sumsq</code> 滿足以下兩條性質：</p><p>但如果我們翻轉過來，把這兩條性質當作 <code class="haskell">sumsq</code> 的新定義呢？
這是一個依據歸納法定義的良好程式，而且不會產生中間串列！</p><p>但我們怎知道 <code class="haskell">sumsq</code> 的新定義滿足我們最初的要求 ([RefUndefined])，即 <code class="haskell">sumsq = sum . map square</code> 呢？
回顧起來，我們的演算只證明了當 <code class="haskell">sumsq</code> 滿足 ([RefUndefined])，它也滿足 ([RefUndefined])，
卻還不能據此宣稱另一個方向：若 ([RefUndefined]) 成立，([RefUndefined]) 也成立。
我們將在第<a href="Semantics.html#ch:semantics">4 </a>章詳細討論這個問題。
目前可暫時這麼說：如果我們從某個問題規格 <code class="haskell">f = e</code> 起始，發現 <code class="haskell">f</code> 滿足某一組等式，而這些等式剛好可湊成一個<em>會正常終止</em>的歸納定義，則 <code class="haskell">e</code> 確實是唯一滿足這些等式的解。由於如此的 <code class="haskell">e</code> 是唯一的，我們也可倒過來以這組等式為 <code class="haskell">f</code> 的定義，並同時宣稱 <code class="haskell">f = e</code> 這個性質成立。</p><p>回顧起來，在 <code class="haskell">sumsq</code> 的計算中，我們僅是把 <code class="haskell">sumsq</code> 的定義展開，接著展開 <code class="haskell">map</code>, <code class="haskell">sum</code> 等等元件的定義，直到我們又看到 <code class="haskell">sumsq</code> 的定義出現在式子中、剛好可以收回為止。
這是一種單純而歷史悠久的程式推導方法，稱作<em>展開-收回轉換</em>(<em>fold-unfold transformation</em>)<span id="ix-5-1"></span>。
雖然簡單，有時這個方法意外地有用。</p><p>在這個例子中，我們真正做到的是將一個單行、使用全麥編程的 <code class="haskell">sumsq</code> 定義轉換成了一個歸納定義。
新定義的 <code class="haskell">sumsq</code> 比起原版稍有效率些，但這只是恰巧發生的 --- 歸納定義的程式不見得總會比較有效率。
程式推導確保程式的正確性 --- 意即<em>導出的程式與原本的規格是同一個函數</em>。
但新程式的效率仍須單獨分析。這是下一節的主題。</p><div class="exlist"><div class="exercise exer" id="ex:descend"><h5 class="exercise-title">練習 5.1 </h5><p>下述函數 <code class="haskell">descend n</code> 傳回 <code class="haskell">[n, n-1, n-2...0]</code>:</p><pre><code class="haskell">descend :: Nat -&gt; List Nat
descend Zero     = []
descend (Suc n)  = Suc n : descend n 
</code></pre><p>定義 <code class="haskell">sumseries = sum . descend</code>.
請找出 <code class="haskell">sumseries</code> 的歸納定義。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-1" type="checkbox"/><label class="lbl-toggle" for="ans-5-1">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>顯然 <code class="haskell">sum (descend 0) = 0</code>. 考慮歸納情況：</p><pre><code class="haskell">   sum (descend (Suc n))
 ===   <comment>{- <code class="haskell">descend</code> 之定義 -}</comment>
   sum (Suc n : descend n)
 ===   <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
   (Suc n) + sum (descend n)
 ===   <comment>{- <code class="haskell">sumseries</code> 之定義 -}</comment>
   (Suc n) + sumseries n 
</code></pre><p>因此</p><pre><code class="haskell">sumseries Zero     = Zero
sumseries (Suc n)  = (Suc n) + sumseries n 
</code></pre></div></div></div><div class="exlist"><div class="exercise exer" id="ex:repeatN"><h5 class="exercise-title">練習 5.2 </h5><p>承接習題<a href="#ex:descend">5.1 </a>。函數 <code class="haskell">repeatN :: (Nat × a) -&gt; List a</code> 的定義為</p><pre><code class="spec">repeatN (n,x) = map (const x) (descend n) 
</code></pre><p>因此，<code class="haskell">repeatN (n,x)</code> 會傳回一個含 <code class="haskell">n</code> 個 <code class="haskell">x</code> 的串列。
例如 <code class="haskell">repeatN (3,'a') = "aaa"</code>.
請算出一個歸納定義的 <code class="haskell">repeatN</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-2" type="checkbox"/><label class="lbl-toggle" for="ans-5-2">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>顯然 <code class="haskell">repeatN (0,x) = []</code>.
至於歸納情況，演算如下：</p><pre><code class="haskell">   repeatN (Suc n, x)
 ===   <comment>{- <code class="haskell">repeatN</code> 之定義 -}</comment>
   map (const x) (descend (Suc n))
 ===   <comment>{- <code class="haskell">descend</code> 之定義 -}</comment>
   map (const x) (Suc n : descend n)
 ===   <comment>{- <code class="haskell">map</code> 與 <code class="haskell">const</code> 之定義 -}</comment>
   x : map (const x) (descend n)
 ===   <comment>{- <code class="haskell">repeatN</code> 之定義 -}</comment>
   x : repeatN (n,x) 
</code></pre><p>因此，</p><pre><code class="haskell">repeatN (Zero,   x)  = []
repeatN (Suc n,  x)  = x : repeatN (n,x) 
</code></pre></div></div></div><div class="exlist"><div class="exercise exer" id="ex:rld"><h5 class="exercise-title">練習 5.3 </h5><p>承接習題<a href="#ex:repeatN">5.2 </a>。遊程編碼(run-length encoding)<span id="ix-5-2"></span>是一種簡單的壓縮方式：將字串中重複的字元表達成其出現的數字。例如 <code class="haskell">"aaabbbbcdd"</code> 可以表達為 <code class="haskell">"3a4b1c2d"</code>. 下列函數 <code class="haskell">rld :: List (Nat × a) -&gt; List a</code> 則是抽象過的「遊程解碼」，將已經表示成（次數$\times$字元）的壓縮文展開：</p><pre><code class="spec">rld = concat . map repeatN 
</code></pre><p>例如， <code class="haskell">rld [(2,'a'), (3,'b'), (1,'c')] = "aabbbc"</code>.
請導出 <code class="haskell">rld</code> 的歸納定義。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-3" type="checkbox"/><label class="lbl-toggle" for="ans-5-3">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>基底狀況：</p><pre><code class="spec">   rld []
=    <comment>{- <code class="haskell">rld</code> 之定義 -}</comment>
   concat (map repeatN [])
=    <comment>{- <code class="haskell">map</code> 與 <code class="haskell">concat</code> 之定義 -}</comment>
   [] 
</code></pre><p>歸納狀況：</p><pre><code class="haskell">      rld ((n,x):xs)
 ===    <comment>{- <code class="haskell">rld</code> 之定義 -}</comment>
      concat (map repeatN ((n,x):xs))
 ===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
      concat (repeatN (n,x) : map repeatN xs)
 ===    <comment>{- <code class="haskell">concat</code> 之定義 -}</comment>
      repeatN (n,x) ++ concat (map repeatN xs)
 ===    <comment>{- <code class="haskell">rld</code> 之定義 -}</comment>
      repeatN (n,x) ++ rld xs 
</code></pre><p>因此我們已推導出：</p><pre><code class="haskell">rld []          = []
rld ((n,x):xs)  = repeatN (n,x) ++ rld xs 
</code></pre></div></div></div><div class="exlist"><div class="exercise exer" id="ex:delete-select"><h5 class="exercise-title">練習 5.4 </h5><p>下列函數 <code class="haskell">delete</code> 將輸入串列中的每個元素輪流刪除：</p><pre><code class="haskell">delete         ::  List a -&gt; List (List a)
delete []      =   []
delete (x:xs)  =   xs : map (x:) (delete xs) 
</code></pre><p>例如，<code class="haskell">delete [1,2,3,4] = [[2,3,4], [1,3,4], [1,2,4], [1,2,3]]</code>.
函數 <code class="haskell">select :: List a -&gt; List (a × List a)</code> 則將一個串列中的元素依次選出。
例如，<code class="haskell">select [1,2,3,4] = [(1,[2,3,4]), (2,[1,3,4]), (3,[1,2,4]), (4,[1,2,3])]</code>. 函數 <code class="haskell">select</code> 恰巧可用 <code class="haskell">delete</code> 定義出來：</p><pre><code class="haskell">select xs = zip xs (delete xs) 
</code></pre><p>請推導出 <code class="haskell">select</code> 的歸納定義。<strong>提示</strong>：下述性質可能有用 ---
<code class="haskell">zip xs (map f ys) = map (id *** f) (zip xs ys)</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-4" type="checkbox"/><label class="lbl-toggle" for="ans-5-4">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>顯然 <code class="haskell">select [] = []</code>。考慮 <code class="haskell">xs := x:xs</code> 的情況：</p><pre><code class="haskell">    select (x:xs)
 ===   <comment>{- <code class="haskell">select</code> 與 <code class="haskell">delete</code> 之定義 -}</comment>
    zip (x:xs) (xs : map (x:) (delete xs))
 ===   <comment>{- <code class="haskell">zip</code> 之定義 -}</comment>
    (x, xs) : zip xs (map (x:) (delete xs))
 ===   <comment>{- <code class="haskell">zip xs (map f ys) = map (id *** f) (zip xs ys)</code> -}</comment>
    (x, xs) : map (id *** (x:)) (zip xs (delete xs))
 ===   <comment>{- <code class="haskell">select</code> 之定義 -}</comment>
    (x, xs) : map (id *** (x:)) (select xs) 
</code></pre><p>因此，</p><pre><code class="spec">select []      = []
select (x:xs)  = (x, xs) : map (id *** (x:)) (select xs) 
</code></pre></div></div></div><div class="exlist"><div class="exercise exer" id="ex:delete-take-drop"><h5 class="exercise-title">練習 5.5 </h5><p>函數 <code class="haskell">delete</code> 有另一個可能定義：</p><pre><code class="spec">delete xs = map (del xs) [0..length xs-1]
   where del xs i = take i xs ++ drop (1+i) xs 
</code></pre><p>（此處我們利用了當 <code class="haskell">n</code> 為負數時，<code class="haskell">[0..n]</code> 化簡成 <code class="haskell">[]</code> 的特性。）
請用此定義推導出 <code class="haskell">delete</code> 的歸納定義。<strong>提示</strong>：你可能用得上下述性質：</p><pre><code class="equation" id="eq:gen-split">  |[0..n] = 0 : map (1+) [0..n-1]|\mbox{,~~ if |n &gt;= 0|,}</code>    (5.1 )
</pre></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-5" type="checkbox"/><label class="lbl-toggle" for="ans-5-5">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>以下只列出歸納狀況：</p><pre><code class="haskell">    delete (x:xs)
 ===   <comment>{- <code class="haskell">delete</code> 之定義 -}</comment>
    map (del (x:xs)) [0..length (x:xs) -1]
 ===   <comment>{- <code class="haskell">length</code> 之定義，簡單運算 -}</comment>
    map (del (x:xs)) [0..length xs]
 ===   <comment>{- 由於 <code class="haskell">length xs &gt;= 0</code>, 使用 \eqref{eq:gen-split} -}</comment>
   map (del (x:xs)) (0 : map (1+) [0..length xs-1])
 ===   <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
   del (x:xs) 0 : map (del (x:xs)) (map (1+) [0..length xs-1])
 ===   <comment>{- <code class="haskell">map</code> 融合 -}</comment>
   del (x:xs) 0 : map (del (x:xs) . (1+)) [0..length xs-1] 
</code></pre><p>在此暫停一下，觀察 <code class="haskell">del (x:xs)</code>. 顯然, <code class="haskell">del (x:xs) 0 = xs</code>. 至於 <code class="haskell">del (x:xs) . (1+)</code>，我們演算看看:</p><pre><code class="haskell">    (del (x:xs) . (1+)) i
 ===    <comment>{- <code class="haskell">(.)</code> 與 <code class="haskell">del</code> 之定義 -}</comment>
    take (1+ i) (x:xs) ++ drop (1+ (1+ i)) (x:xs)
 ===    <comment>{- <code class="haskell">take</code> 與 <code class="haskell">drop</code> 之定義 -}</comment>
    x : take i xs ++ drop (1+ i) xs
 ===    <comment>{- <code class="haskell">del</code> 之定義 -}</comment>
    x : del xs i
 ===    <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
    ((x:) . del xs) i 
</code></pre><p>繼續之前的演算：</p><pre><code class="haskell">    del (x:xs) 0 : map (del (x:xs) . (1+)) [0 .. length xs - 1]
 ===   <comment>{- 前述之演算 -}</comment>
    xs : map ((x:) . del xs) [0 .. length xs - 1]
 ===   <comment>{- <code class="haskell">map</code> 融合 -}</comment>
    xs : map (x:) (map (del xs) [0 .. length xs - 1])
 ===   <comment>{- <code class="haskell">delete</code> 之定義 -}</comment>
    xs : map (x:) (delete xs) 
</code></pre><p>由此，我們導出了正文中 <code class="haskell">delete</code> 的歸納定義.</p></div></div></div></div><div class="navi"><div class="previous">&laquo;<a href="Derivation.html#ch:derivation">5 一般程式推導</a></div><div class="next"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
