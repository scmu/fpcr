<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" checked type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-selected pure-menu-item"><a href="#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" checked type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:fold">6 摺</h1></div><div class="navi"><div class="previous">&laquo;<a href="Folds.html#ch:fold">6 摺</a></div><div class="next"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:folds-on-lists">6.1 串列的摺</h2><p>「摺」有許多方式可理解。
我們可說 <code class="haskell">foldr</code> 捕捉了最常見的一種歸納定義模式，並將它形式化地表達出來。
在第<a href="Induction.html#ch:induction">2 </a>章中，許多函數定義都遵循這樣的模式：</p><pre><code class="spec">h :: List a -&gt; b
h []      = e
h (x:xs)  = ... x ... h xs ...
</code></pre><p>在 <code class="haskell">h []</code> 的情況傳回某個基底值；在 <code class="haskell">h (x:xs)</code> 的情況中可使用 <code class="haskell">x</code> 與 <code class="haskell">h xs</code> 的值。
如果上述定義中 <code class="haskell">...</code> 之處<em>沒有出現 <code class="haskell">xs</code></em>, 則 <code class="haskell">h</code> 的定義就能寫成一個 <code class="haskell">foldr</code>.</p><p>我們也可將 <code class="haskell">foldr</code> 視為組件(combinator)函數之一。<span id="ix-6-1"></span>
第<a href="Basics-8.html#sec:list-combinators">1.8.3 </a>節之中介紹了組件函數的觀念：
如同 <code class="haskell">map</code>, <code class="haskell">take</code>, <code class="haskell">drop</code>, <code class="haskell">zip</code> 等等的組件函數捕捉了常見的程式設計模式。
每個組件負責一項單一、通用、易重用的功能。
函數 <code class="haskell">foldr</code> 也可視為一個組件，只是它比一些其他組件更抽象、更通用 --- 我們稍後將發現許多我們見過的組件函數都是 <code class="haskell">foldr</code> 的特例。</p><p>還有一個理解 <code class="haskell">foldr</code> 的方式：<code class="haskell">foldr</code> 替換了串列中的建構元。
回顧：任何有限長度的串列都是由 <code class="haskell">[]</code> 開始，有限次地套用 <code class="haskell">(:)</code> 而來。
例如 <code class="haskell">[x0,x1,x2]</code> 是 <code class="haskell">x0 : (x1 : (x2 : []))</code> 的簡寫。
考慮 <code class="haskell">foldr oplus e [x0,x1,x2]</code>:</p><pre><code class="spec">     foldr oplus e (x0 : (x1 : (x2 : [])))
===  x0 ⊕ foldr oplus e (x1 : (x2 : []))
===  x0 ⊕ (x1 ⊕ foldr oplus e (x2 : []))
===  x0 ⊕ (x1 ⊕ (x2 ⊕ foldr oplus e []))
===  x0 ⊕ (x1 ⊕ (x2 ⊕ e)) 
</code></pre><p>我們可看到 <code class="haskell">foldr</code> 將串列走訪一次，將每個 <code class="haskell">(:)</code> 替換成 <code class="haskell">oplus</code>, 將 <code class="haskell">[]</code> 替換成 <code class="haskell">e</code>.
式子中的括號往右邊結合，這是 <code class="haskell">foldr</code> 的名字中字母 <code class="haskell">r</code> 的由來。
這種理解也便於解釋 <code class="haskell">foldr</code> 的型別。
回想串列的兩個建構元，</p><ul><li><p><code class="haskell">[]</code> 的型別是 <code class="haskell">List a</code>,</p></li><li><p><code class="haskell">(:)</code> 的型別是 <code class="haskell">a -&gt; List a -&gt; List a</code>.</p></li></ul><p>函數 <code class="haskell">foldr oplus e</code> 接收一個 <code class="haskell">List a</code>，把其中的建構元分別替換為 <code class="haskell">e</code> 與 <code class="haskell">oplus</code>，藉此算出一個型別為 <code class="haskell">b</code> 的值。因此，</p><ul><li><p><code class="haskell">e</code> 是輸入為 <code class="haskell">[]</code> 時立刻傳回的值，其型別必須是 <code class="haskell">b</code>.</p></li><li><p>至於 <code class="haskell">oplus</code> 的型別，考慮 <code class="haskell">x0 ⊕ (x1 ⊕ (x2 ⊕ e))</code> 這個式子。
其中 <code class="haskell">x0</code> 的型別為 <code class="haskell">a</code>, <code class="haskell">x1 ⊕ (x2 ⊕ e)</code> 是建構元已被替換過的串列，型別應該為 <code class="haskell">b</code>.
而 <code class="haskell">oplus</code> 拿到這兩個輸入後，得算出一個型別為 <code class="haskell">b</code> 的值.
因此 <code class="haskell">oplus</code> 的型別為 <code class="haskell">a -&gt; b -&gt; b</code>.</p></li></ul><p>注意：<code class="haskell">e</code> 與 <code class="haskell">oplus</code> 的型別分別是將 <code class="haskell">[]</code> 與 <code class="haskell">(:)</code> 的型別中的 <code class="haskell">List a</code> 代換成 <code class="haskell">b</code> 而來。
綜合言之，
<code class="haskell">foldr</code> 的型別是 <code class="haskell">(a -&gt; b -&gt; b) -&gt; b -&gt; List a -&gt; b</code>.</p><p>為方便說明，此後我們將 <code class="haskell">foldr oplus e</code> 之中的 <code class="haskell">e</code> 稱作<em>基底值</em>(<em>base value</em>)<span id="ix-6-2"></span>，將 <code class="haskell">oplus</code> 稱作<em>步驟函數</em>(<em>step function</em>)<span id="ix-6-3"></span>.
函數 <code class="haskell">foldr</code> 的型別可以理解為：給一個型別為 <code class="haskell">a -&gt; b -&gt; b</code> 的步驟函數，和一個型別為 <code class="haskell">b</code> 的基底值，<code class="haskell">foldr</code> 就能將一個 <code class="haskell">List a</code> 轉換為 <code class="haskell">b</code>.</p><p>串列的摺(<code class="haskell">foldr</code>)只是一個常用的特例 ---「將資料結構中的建構元代換掉」的動作也可推廣到其他資料結構上。
我們在之後的章節中將看到一些其他資料結構上的摺。</p><p>下一節將舉更多使用 <code class="haskell">foldr</code> 的例子。
在那之前我們再次提醒讀者：在 <code class="haskell">foldr oplus e (x:xs)</code> 的狀況中，<code class="haskell">oplus</code> 可以使用 <code class="haskell">x</code> 與 <code class="haskell">foldr oplus e xs</code> 的結果，但不能直接使用 <code class="haskell">xs</code>.</p><h3 class="subsection" id="sec:more-folds-on-lists">6.1.1 更多串列上的摺</h3><p>回顧起來，我們可發現第<a href="Induction.html#ch:induction">2 </a>章介紹的許多函數都是 <code class="haskell">foldr</code>.</p><div class="theorem" id="eg:foldr"><h5 class="theorem-title">例 6.1  </h5><p>以下函數都可寫成 <code class="haskell">foldr</code>:</p><ul><li><p><code class="haskell">concat = foldr (++) []</code>.</p></li><li><p><code class="haskell">filter p = foldr (\ x xs -&gt; if p x then x:xs else xs) []</code>,</p></li><li><p><code class="haskell">takeWhile p = foldr (\x xs -&gt; if p x then x:xs else []) []</code>,</p></li><li><p><code class="haskell">elem x = foldr (\y b -&gt; x == y ⋁ b) False</code>,</p></li><li><p><code class="haskell">all p = foldr (\x b -&gt; p x ⋀ b) True</code>.</p></li></ul></div><p>串列連接 <code class="haskell">(++) :: List a -&gt; List a -&gt; List a</code> 雖是個二元運算，
若將 <code class="haskell">(++ ys) :: List a -&gt; List a</code> 視為一個函數，它可寫成一個 <code class="haskell">foldr</code>:</p><pre><code class="spec"> (++ ys) = foldr (:) ys 
</code></pre><p>一個重要的特例是當 <code class="haskell">ys = []</code> 時。對任何 <code class="haskell">xs</code>, <code class="haskell">xs ++ [] = xs</code>. 因此 <code class="haskell">(++[])</code> 是串列上的 <code class="haskell">id</code>:</p><pre><code class="spec">id :: List a -&gt; List a
id = foldr (:) [] 
</code></pre><p>確實，將一個串列中的 <code class="haskell">(:)</code> 代換成 <code class="haskell">(:)</code>, <code class="haskell">[]</code> 代換成 <code class="haskell">[]</code>, 我們還是得到原來的串列。
我們日後還會用到「串列上的 <code class="haskell">id</code> 是一個 <code class="haskell">foldr</code>」的性質。</p><p>計算所有前段的函數 <code class="haskell">inits :: List a -&gt; List (List a)</code> 可寫成 <code class="haskell">foldr</code>:
<span id="ix-6-4"></span></p><pre><code class="haskell">inits = foldr (\x xss -&gt; [] : map (x:) xss) [[]] 
</code></pre><p>計算所有後段的 <code class="haskell">tails :: List a -&gt; List (List a)</code> 也可以寫成 <code class="haskell">foldr</code>，但需要用一個小性質。
回顧其定義：
<span id="ix-6-5"></span></p><pre><code class="spec">tails []      = [[]]
tails (x:xs)  = (x:xs) : tails xs 
</code></pre><p>乍看之下這不符合 <code class="haskell">foldr</code> 的模式：參數 <code class="haskell">xs</code> 出現在 <code class="haskell">... : tails xs</code> 的左邊，但在 <code class="haskell">foldr</code> 的模式中，<code class="haskell">xs</code> 不能出現在遞迴呼叫之外。
幸好 <code class="haskell">tails</code> 有一個剛好在此有用的小特性：<code class="haskell">tails xs</code> 傳回的所有後段中，第一個就是 <code class="haskell">xs</code> 本身：<code class="haskell">head (tails xs) = xs</code>.
因此我們可將 <code class="haskell">tails</code> 寫成：</p><pre><code class="haskell">tails = foldr (\x xss -&gt; (x : head xss) : xss) [[]] 
</code></pre><p>由於 <code class="haskell">tails</code> 永遠傳回非空串列，使用 <code class="haskell">head xss</code> 是安全的。</p><div class="exlist"><div class="exercise exer" id="ex:perms-sublists-splits-foldr"><h5 class="exercise-title">練習 6.1 </h5><p>請將以下函數寫成 <code class="haskell">foldr</code>:</p><ol><li><p><code class="haskell">perms :: List a -&gt; List (List a)</code> (見第<a href="Induction-6.html#sec:fan-perm">2.6.4 </a>節),</p></li><li><p><code class="haskell">sublists :: List a -&gt; List (List a)</code> (見第<a href="Induction-6.html#sec:fan-perm">2.6.4 </a>節),</p></li><li><p><code class="haskell">splits :: List a -&gt; List (List a × List a)</code> （見習題<a href="Induction-6.html#ex:splits">2.27 </a>）。</p></li></ol></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-1" type="checkbox"/><label class="lbl-toggle" for="ans-6-1">顯示答案</label><div class="collapsible-content"><h5>答案</h5><ol><li><p><code class="haskell">perms = foldr (\x xss -&gt; concat (map (fan x) xss)) [[]]</code></p></li><li><p><code class="haskell">sublists = foldr (\x xss -&gt; xss ++ map (x:) xss) [[]]</code></p></li><li><p><code class="haskell">splits</code> 可定義如下：</p></li></ol><pre><code class="haskell">splits = foldr spl [([],[])] 
  where  spl x ((xs,ys):zss) =
           ([],x:xs++ys) : map ((x:) *** id) ((xs,ys):zss) 
</code></pre></div></div></div><h3 class="subsection" id="sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</h3><p>並非所有輸入為串列的函數都是 <code class="haskell">foldr</code>.
最明顯的例子是 <code class="haskell">tail</code>: 我們無法由 <code class="haskell">x</code> 和 <code class="haskell">tail xs</code> 算出 <code class="haskell">tail (x:xs)</code>。
例如，<code class="haskell">tail [1,2,3] = [2,3]</code>，但 <code class="haskell">tail [2,3] = [3]</code>, 而 <code class="haskell">[2,3]</code> 無法由 <code class="haskell">1</code> 和 <code class="haskell">[3]</code> 組出來。</p><p>另一個例子是 <code class="haskell">dropWhile p</code>. 回顧其定義：</p><pre><code class="spec">dropWhile p []      = []
dropWhile p (x:xs)  = if p x then dropWhile p xs else x:xs 
</code></pre><p>在歸納情況中，<code class="haskell">else</code> 的分支需傳回 <code class="haskell">x:xs</code> --- <code class="haskell">xs</code> 出現在遞迴呼叫以外的地方。這樣的程式不是 <code class="haskell">foldr</code>。
當然，這只表示 <code class="haskell">dropWhile p</code> 的<em>這個</em>定義不符合 <code class="haskell">foldr</code> 的模式.
是否有其他的方式能將 <code class="haskell">dropWhile p</code> 寫成 <code class="haskell">foldr</code> 呢？
不論 <code class="haskell">dropWhile p</code> 是怎麼定義的，考慮
<code class="haskell">dropWhile even [4,3,6,2] = [3,6,2]</code>, 但 <code class="haskell">dropWhile even [3,6,2] = []</code> ---
看來，<code class="haskell">dropWhile p</code> 丟掉了太多資訊，使得我們無法保證能從 <code class="haskell">dropWhile p xs</code> 重組出 <code class="haskell">dropWhile p (x:xs)</code>。
因此，<code class="haskell">dropWhile p</code> 和 <code class="haskell">tail</code> 一樣，是先天上無法寫成 <code class="haskell">foldr</code> 的。</p><div class="exlist"><div class="exercise exer" id="ex:fan-foldr"><h5 class="exercise-title">練習 6.2 </h5><p>考慮第<a href="Induction-6.html#sec:fan-perm">2.6.4 </a>節的函數 <code class="haskell">fan</code>:</p><pre><code class="spec">fan :: a -&gt; List a -&gt; List (List a)
fan y []      = [[y]]
fan y (x:xs)  = (y:x:xs) : map (x:) (fan y xs) 
</code></pre><p>為何這個定義目前的形式不是一個 <code class="haskell">foldr</code>?
有沒有可能將 <code class="haskell">fan y</code> 寫成一個 <code class="haskell">foldr</code> 呢？</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-2" type="checkbox"/><label class="lbl-toggle" for="ans-6-2">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>由於 <code class="haskell">xs</code> 出現在遞迴呼叫以外的地方 --- <code class="haskell">((y:x:xs) :)</code>, 此處的 <code class="haskell">fan</code> 定義並不是一個 <code class="haskell">foldr</code>.
但由於 <code class="haskell">tail (head (fan y xs)) = xs</code>
（例如，<code class="haskell">fan 5 [1,2,3] = [[5,1,2,3],[1,5,2,3],[1,2,5,3],[1,2,3,5]]</code>,
因此 <code class="haskell">tail (head (fan 5 [1,2,3])) = [1,2,3]</code>），
我們可將 <code class="haskell">fan</code>寫成：</p><pre><code class="haskell">fan' y = foldr (\x xss -&gt; (y:x: tail (head xss)) : map (x:) xss) [[y]] 
</code></pre></div></div></div></div><div class="navi"><div class="previous">&laquo;<a href="Folds.html#ch:fold">6 摺</a></div><div class="next"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
