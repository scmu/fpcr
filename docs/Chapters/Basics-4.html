<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" checked type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:basics">1 值、函數、與定義</h1></div><div class="navi"><div class="previous">&laquo;<a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></div><div class="next"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:func-comp">1.4 函數合成</h2><p>拿到一個函數 <code class="haskell">f</code>，我們能做的基本操作包括把 <code class="haskell">f</code> 作用在某個參數上、
把 <code class="haskell">f</code> 傳給別的函數...
此外，另一個常用的基本操作是將 <code class="haskell">f</code> 和別的函數<em>合成</em>(<em>compose</em>)
<span id="ix-1-18"></span><span id="ix-1-19"></span>
為一個新函數。
<input class="toggle" id="footnote-1-4-9" type="checkbox"/><label class="fnote-toggle" for="footnote-1-4-9">(註9) </label><span class="collapsible-footnote">Robert Gl\"{u}ck 認為函數上應有三個基本操作：
函數應用、函數合成、以及求一個函數的反函數。
前兩者已經提到，第三者則是大部分語言欠缺的。</span>
「合成」運算子在 Haskell 中寫成<code class="haskell">(.)</code>.
這個運算子的形式定義如下（我們先看定義本體，待會兒再看型別）：</p><pre><code class="spec">(f . g) x  = f (g x) 
</code></pre><p>若用口語說，<code class="haskell">f . g</code> 是將 <code class="haskell">f</code> 和 <code class="haskell">g</code>兩個函數「串起來」得到的新函數：
輸入 <code class="haskell">x</code> 先丟給 <code class="haskell">g</code>, 後者算出的結果再傳給 <code class="haskell">f</code>.</p><div class="theorem" id="eg:square-double"><h5 class="theorem-title">例 1.7  </h5><p><code class="haskell">square . double</code> 與 <code class="haskell">double . square</code> 都是由 <code class="haskell">Int</code> 到 <code class="haskell">Int</code> 的函數.
直覺上，前者把輸入先給 <code class="haskell">double</code>, 其結果再給 <code class="haskell">square</code>。
後者則反過來。
如何了解它們的行為？既然它們是函數，我們便餵給它們一個參數，看看會展開成什麼！
兩者分別展開如下：</p><div class="multicols"><div class="mcol" width="0.4\textwidth"><pre><code class="spec">   (square . double) x
=    <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
   square (double x)
=  (x + x) * (x + x) 
</code></pre></div><div class="mcol" width="0.4\textwidth"><pre><code class="spec">   (double . square) x
=    <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
   double (square x)
=  (x * x) + (x * x) 
</code></pre></div></div><p>所以，如果輸入為 <code class="haskell">x</code>, <code class="haskell">(square . double) x</code> 計算 $(2x)^2$;
<code class="haskell">(double . square) x</code> 則是 $2x^2$.</p></div><p>但，並不是所有函數都可以串在一起：
<code class="haskell">f . g</code> 之中，<code class="haskell">g</code> 的輸出型別和 <code class="haskell">f</code> 的輸入型別必須一致才行。
運算子 <code class="haskell">(.)</code> 包括型別的完整定義為：</p><pre><code class="spec">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(f . g) x  = f (g x) 
</code></pre><p>如果 <code class="haskell">g</code> 的型別是 <code class="haskell">a -&gt; b</code>, <code class="haskell">f</code> 的型別是 <code class="haskell">b -&gt; c</code>, 將他們串接起來後，
便得到一個型別為 <code class="haskell">a -&gt; c</code> 的函數。</p><p>有了<code class="haskell">(.)</code>, 函數 <code class="haskell">twice</code> 可以定義如下：</p><pre><code class="spec">twice    :: (a -&gt; a) -&gt; (a -&gt; a)
twice f  = f . f  
</code></pre><p>確實，根據 <code class="haskell">(.)</code> 的定義，<code class="haskell">twice f x = (f . f) x = f (f x)</code>，和 <code class="haskell">twice</code> 原來的定義相同。</p><p>為了討論函數合成的性質，我們先介紹一個函數 <code class="haskell">id</code>:</p><pre><code>id :: a -&gt; a
id x = x 
</code></pre><p>它又稱作<em>單位函數</em>或<em>恆等函數</em>。<span id="ix-1-20"></span>
這是一個似乎沒有在做什麼的函數：給任何輸入，<code class="haskell">id</code> 都原封不動地把它送到輸出 ---
這也反映在他的型別 <code class="haskell">a -&gt; a</code> 上。
這個函數有什麼重要性呢？
原來，<code class="haskell">(.)</code> 滿足結合律，並且以 <code class="haskell">id</code> 為單位元素（這也是「單位函數」這名字的由來）：</p><p>用數學術語來說的話，<code class="haskell">id</code> 與 <code class="haskell">(.)</code> 形成一個<em>幺半群</em> (<em>monoid</em>)。
<span id="ix-1-21"></span>
函數 <code class="haskell">id</code> 的重要性就如同 <code class="haskell">0</code> 在代數中的重要性（<code class="haskell">0</code> 與 <code class="haskell">(+)</code> 也是一個幺半群）。我們在許多計算、證明中都會見到它。</p><p>以下我們試著證明 <code class="haskell">(.)</code> 的結合律。我們想論證
<code class="haskell">(f . g) . h = f . (g . h)</code>，但該如何下手？
該等式的等號左右兩邊都是函數。
當我們說兩個整數相等，意思很清楚：如果等號左邊是 <code class="haskell">0</code>, 右邊也是 <code class="haskell">0</code>;
如果左邊是 <code class="haskell">1</code>, 右邊也是 <code class="haskell">1</code>... 但說兩個函數「相等」，是什麼意思呢？</p><div class="theorem" id="def:extensional-eq" title="外延相等(extensional equality)"><h5 class="theorem-title">定義 1.8  外延相等(extensional equality) </h5><p>給定兩個型別相同的函數 <code class="haskell">f</code> 和 <code class="haskell">g</code>, 當我們說它們<em>外延相等</em>(<em>extensionally equal</em>)<span id="ix-1-22"></span>，
意思是給任何一個輸入，<code class="haskell">f</code> 和 <code class="haskell">g</code> 都算出相等的輸出。也就是：
<code class="haskell">(forall x. f x = g x)</code>.</p><p>本書中，當我們寫兩個函數相等(<code class="haskell">f = g</code>)時，指的便是外延相等，除非例外註明。</p></div><p>在外延相等的假設下，證明 <code class="haskell">(f . g) . h = f . (g . h)</code> 也就是證明對任何一個 <code class="haskell">x</code>, <code class="haskell">((f . g) . h) x = (f . (g . h)) x</code> 均成立. 我們推論如下：</p><pre><code class="spec">  ((f . g) . h) x
=  <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
  (f . g) (h x)
=  <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
  f (g (h x))
=  <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
  f ((g . h) x) 
=  <comment>{- <code class="haskell">(.)</code> 的定義 -}</comment>
  (f . (g . h)) x 
</code></pre><p>既然 <code class="haskell">(f . g) . h = f . (g . h)</code>，我們便可統一寫成 <code class="haskell">f . g . h</code>, 不用加括號了。</p><div class="exlist"><div class="exercise exer" id="ex:identity-law"><h5 class="exercise-title">練習 1.6 </h5><p>證明 <code class="haskell">id . f = f = f . id</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-6" type="checkbox"/><label class="lbl-toggle" for="ans-1-6">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>根據外延相等，我們需證明 <code class="haskell">(forall x . id . f = f = f . id)</code>.
推論如下：</p><pre><code class="spec">   (id . f) x
=    <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
   id (f x)
=    <comment>{- <code class="haskell">id</code> 之定義 -}</comment>
   f x
=    <comment>{- <code class="haskell">id</code> 之定義 -}</comment>
   f (id x)
=    <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
   (f . id) x 
</code></pre></div></div></div><p>合成 <code class="haskell">(.)</code> 也是一個中序運算子。和其他中序運算子一樣，其優先性低於函數應用。
因此，當我們寫 <code class="haskell">f . g x</code>, 指的是 <code class="haskell">f . (g x)</code> --- <code class="haskell">g x</code> 為一個函數，
和 <code class="haskell">f</code> 合成，而不是 <code class="haskell">(f . g) x</code> （後者根據 <code class="haskell">(.)</code> 的定義，是 <code class="haskell">f (g x)</code>）。</p><div class="theorem" id="eg:smaller-square-legal"><h5 class="theorem-title">例 1.9  </h5><p>下列程式中，有些是合法的 Haskell 式子、有些則有型別錯誤。
對每個程式，如果它是合法的，請找出它的型別，並說說看該程式做什麼。
如果有型別錯誤，請簡述為什麼。</p><ol><li><p><code class="haskell">square . smaller 3</code>;</p></li><li><p><code class="haskell">smaller 3 . square</code>;</p></li><li><p><code class="haskell">smaller (square 3)</code>;</p></li><li><p><code class="haskell">smaller . square 3</code>.</p></li></ol></div><div class="wrap-collabsible"><input class="toggle" id="ans-1-6" type="checkbox"/><label class="lbl-toggle" for="ans-1-6">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>前三者都是 <code class="haskell">Int -&gt; Int</code>。</p><ol><li><p>根據 <code class="haskell">(.)</code> 的定義，<code class="haskell">(square . smaller 3) x = square (smaller 3 x)</code>.
因此 <code class="haskell">square . smaller 3</code> 是一個函數，將其輸入和 <code class="haskell">3</code> 比較，取較小者的平方。</p></li><li><p><code class="haskell">(smaller 3 . square) x = smaller 3 (square x)</code>. 因此它讀入 <code class="haskell">x</code>, 並在 <code class="haskell">3</code> 或 <code class="haskell">x^2</code> 之中選較小的那個。</p></li><li><p><code class="haskell">smaller (square 3)</code> 是一個函數，讀入 <code class="haskell">x</code> 之後，選擇 <code class="haskell">x</code> 與 <code class="haskell">3^2</code> 之中較小的那個。</p></li><li><p><code class="haskell">smaller . square 3</code> 有型別錯誤： <code class="haskell">square 3</code> 不是一個函數（而是一個整數），
無法和 <code class="haskell">smaller</code> 合成。</p></li></ol></div></div><p id="para:fun-apply"><b>函數應用運算子</b> &emsp;
本書中有些時候會將許多函數組合成一串，例如 <code class="haskell">square . double . (+1) . smaller 3</code>
。由於函數應用的優先順序比一般二元運算元高，把上述式子應用在參數 <code class="haskell">5</code> 之上時得寫成</p><pre><code class="spec">  (square . double . (+1) . smaller 7) 5 
</code></pre><p>（這個式子的值為 $(2\times(5+1))^2$。）
每次都得加一對括號似乎有些累贅。Haskell 另有一個運算子<code class="haskell">($)</code>, 唸作 ``apply'', 代表函數應用：
<span id="ix-1-23"></span></p><pre><code class="spec">($) :: (a -&gt; b) -&gt; a -&gt; b
f $ x = f x 
</code></pre><p><code class="haskell">f $ x</code> 和 <code class="haskell">f x</code> 意思一樣。那麼我們為何需要這個運算子呢？原因之一是
<code class="haskell">($)</code> 的優先度比 <code class="haskell">(.)</code> 低，因此上式可省去括號改寫如下：</p><pre><code class="spec">  square . double . (+1) . smaller 7 $ 5 
</code></pre><p>運算子 <code class="haskell">($)</code> 的另一個重要意義是：「函數應用」這個動作有了符號，
成為可以獨立討論的事物。例如，<code class="haskell">($)</code> 可以當作參數。
一個這麼做的例子是習題 <a href="Basics-6.html#ex:uncurry-apply">1.11 </a>。</p><p id="para:const"><b>常量函數</b> &emsp;
既然介紹了 <code class="haskell">id</code>, 本節也順便介紹一個以後將使用到的基本組件。
給定 <code class="haskell">x</code> 之後，函數 <code class="haskell">const x</code> 是一個 <em>不論拿到什麼函數，都傳回 <code class="haskell">x</code></em>的函數。
函數 <code class="haskell">const</code> 的定義如下：</p><pre><code class="spec">const :: a -&gt; b -&gt; a
const x y = x 
</code></pre><p>第<a href="Basics-1.html#sec:evaluation">1.1 </a>節開頭的範例 <code class="haskell">three</code> 可定義為 <code class="haskell">three = const 3</code>.</p><p>「無論如何都傳回 <code class="haskell">x</code>」聽來好像是個沒用的函數，
但和 <code class="haskell">id</code> 一樣，我們日後會看到它在演算、證明中時常用上。
事實上，<em>組件邏輯</em>理論告訴我們：所有函數都可以由 <code class="haskell">id</code>, <code class="haskell">const</code>, 和下述的 <code class="haskell">subst</code> 三個函數組合出來。</p><pre><code class="spec">subst :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
subst f g x = f x (g x) 
</code></pre></div><div class="navi"><div class="previous">&laquo;<a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></div><div class="next"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
