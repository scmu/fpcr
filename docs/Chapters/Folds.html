<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="ToC.html">目錄</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction">0.3 抽象化</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:correctness">0.5 正確性</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:relevant-information">0.7 相關資料</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:evaluation">1.1 值與求值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:function-defns">1.2 函數定義</a></li><li class="pure-menu-item"><a href="Basics.html#sec:higher-order-func">1.3 高階函數</a></li><li class="pure-menu-item"><a href="Basics.html#sec:func-comp">1.4 函數合成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:boolean">1.6.1 布林值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:char">1.6.2 字元</a></li><li class="pure-menu-item"><a href="Basics.html#sec:pairs">1.6.3 序對</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:weak-head-normal-form">1.7 弱首範式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:list-deconstruct">1.8.1 串列解構</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-generation">1.8.2 串列生成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:wholemeal">1.9 全麥編程</a></li><li class="pure-menu-item"><a href="Basics.html#sec:user-defined-data">1.10 自訂資料型別</a></li><li class="pure-menu-item"><a href="Basics.html#sec:refs-basics">1.11 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:math-induction">2.1 數學歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li><li class="pure-menu-item"><a href="Induction.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:list-segments">2.6.3 串列區段</a></li><li class="pure-menu-item"><a href="Induction.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li><li class="pure-menu-item"><a href="Induction.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li><li class="pure-menu-item"><a href="Induction.html#sec:complete-induction">2.11 完全歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:well-founded-induction">2.12 良基歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:mutual-induction">2.14 交互歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-ref">2.15 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.1 紅黑樹插入</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.2 紅黑樹之性質：高度</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.3 紅黑樹之性質：平衡</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.4 紅黑樹之性質：顏色</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics.html#sec:denotational-semantics">4.1 指稱語意</a></li><li class="pure-menu-item"><a href="Semantics.html#sec:operational-semantics">4.2 操作語意</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:efficiency-basics">5.2 關於執行效率</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:var-cons">5.4 變數換常數</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:steep">5.5.1 陡串列</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion">5.6.3 尾遞迴</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:difference-list">5.6.6 函數作為串列</a></li></ul></li></ul></li><li class="pure-menu-selected pure-menu-item"><a href="#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" checked type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li><li class="pure-menu-item"><a href="Folds.html#sec:scan-lemma">6.2.3 掃描</a></li><li class="pure-menu-item"><a href="Folds.html#sec:banana-split">6.2.4 香蕉船定理</a></li><li class="pure-menu-item"><a href="Folds.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li><li class="pure-menu-item"><a href="Folds.html#sec:bring-in-context">6.2.6 引入脈絡</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldl">6.3.1 左摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:list-homomorphism">6.3.2 串列同構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldN">6.4 自然數的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:folds-ref">6.6 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-segment-sum">7.1 最大區段和</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:segProblems-ref">7.3 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:exceptions">8.1 例外處理</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-class-laws">8.2 單子與單子律</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:var-env-reader">8.3.1 變數與環境</a></li><li class="pure-menu-item"><a href="Monads.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:hanoi">8.4.1 河內塔問題</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#">8.5 參考資料</a></li></ul></li></ul></nav><p><a href="Ix.html">索引</a></p><p><a href="Biblio.html">參考書目</a></p><p class="author-info"><a href="https://  homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div><div id="main"><div class="header"><h1 class="chapter" id="ch:fold">6 摺</h1></div><div class="content"><p><span id="ix-6-1"></span></p><p>第<a href="Induction.html#ch:induction">2 </a>章中的許多歸納函數定義都循著同一個固定模式。&shy;以 <code class="haskell">sum</code>, <code class="haskell">length</code>, 與 <code class="haskell">map f</code> 為例：</p><pre><code class="spec">sum :: List Int -&gt; Int
sum []      = <comment>{-"{\color{burntorange}"-}</comment>0<comment>{-"}"-}</comment>
sum (x:xs)  = <comment>{-"{\color{burntorange}"-}</comment>x  +<comment>{-"}\,"-}</comment> sum xs 

length :: List a -&gt; Nat
length []      = <comment>{-"{\color{burntorange}"-}</comment>Zero<comment>{-"}"-}</comment>
length (x:xs)  = <comment>{-"{\color{burntorange}"-}</comment>Suc<comment>{-"}"-}</comment> (length xs) 

map :: (a -&gt; b) -&gt; List a -&gt; List b
map f []      = <comment>{-"{\color{burntorange}"-}</comment>[]<comment>{-"}"-}</comment>
map f (x:xs)  = <comment>{-"{\color{burntorange}"-}</comment>f x  :<comment>{-"\,}"-}</comment> map f xs 
</code></pre><p>它們都在輸入為 <code class="haskell">[]</code> 時傳回某個基底值，在輸入為 <code class="haskell">x:xs</code> 時在 <code class="haskell">xs</code> 上遞迴呼叫，&shy;並將呼叫結果稍作加工。&shy;三者的不同之處只在橘色的部分，即基底值以及用於加工的函數：<code class="haskell">sum</code> 使用 <code class="haskell">0</code> 與 <code class="haskell">(+)</code>, <code class="haskell">length</code> 使用 <code class="haskell">Zero</code> 與 <code class="haskell">Suc</code>, <code class="haskell">map f</code> 則使用 <code class="haskell">[]</code> 與 <code class="haskell">(f x :)</code>.&shy;如果說「抽象化」是一個高階程式語言給我們的最重要能力，我們能否將這個模式抽象出來呢？</p><p>我們把上述三個定義中橘色的部分抽出變成參數，將餘下的函數稱為 <code class="haskell">foldr</code>:</p><pre><code class="spec">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; List a -&gt; b
foldr f e []      = e
foldr f e (x:xs)  = f x (foldr f e xs) 
</code></pre><p>如此一來，<code class="haskell">sum</code>, <code class="haskell">length</code>, 與 <code class="haskell">map f</code> 都是 <code class="haskell">foldr</code> 的特例：</p><pre><code class="spec">sum     = foldr (+) 0 
length  = foldr (\x n -&gt; Suc n) Zero 
map f   = foldr (\x ys -&gt; f x : ys) [] 
</code></pre><p>函數 <code class="haskell">foldr</code> 是串列上的「摺(fold)」 --- <code class="haskell">foldr</code> 一詞是 fold 與「右邊(right)」的縮寫，意謂該函數是一個往右結合的摺。我們將在下一節解釋。</p><h2 class="section" id="sec:folds-on-lists">6.1 串列的摺</h2><p>「摺」有許多方式可理解。&shy;我們可說 <code class="haskell">foldr</code> 捕捉了最常見的一種歸納定義模式，並將它形式化地表達出來。&shy;在第<a href="Induction.html#ch:induction">2 </a>章中，許多函數定義都遵循這樣的模式：</p><pre><code class="spec">h :: List a -&gt; b
h []      = e
h (x:xs)  = ... x ... h xs ...
</code></pre><p>在 <code class="haskell">h []</code> 的情況傳回某個基底值；在 <code class="haskell">h (x:xs)</code> 的情況中可使用 <code class="haskell">x</code> 與 <code class="haskell">h xs</code> 的值。&shy;如果上述定義中 <code class="haskell">...</code> 之處<em>沒有出現 <code class="haskell">xs</code></em>, 則 <code class="haskell">h</code> 的定義就能寫成一個 <code class="haskell">foldr</code>.</p><p>我們也可將 <code class="haskell">foldr</code> 視為組件(combinator)函數之一。<span id="ix-6-2"></span>&shy;第<a href="Basics.html#sec:list-combinators">1.8.3 </a>節之中介紹了組件函數的觀念：&shy;如同 <code class="haskell">map</code>, <code class="haskell">take</code>, <code class="haskell">drop</code>, <code class="haskell">zip</code> 等等的組件函數捕捉了常見的程式設計模式。&shy;每個組件負責一項單一、通用、易重用的功能。&shy;函數 <code class="haskell">foldr</code> 也可視為一個組件，只是它比一些其他組件更抽象、更通用 --- 我們稍後將發現許多我們見過的組件函數都是 <code class="haskell">foldr</code> 的特例。</p><p>還有一個理解 <code class="haskell">foldr</code> 的方式：<code class="haskell">foldr</code> 替換了串列中的建構元。&shy;回顧：任何有限長度的串列都是由 <code class="haskell">[]</code> 開始，有限次地套用 <code class="haskell">(:)</code> 而來。&shy;例如 <code class="haskell">[x0,x1,x2]</code> 是 <code class="haskell">x0 : (x1 : (x2 : []))</code> 的簡寫。&shy;考慮 <code class="haskell">foldr oplus e [x0,x1,x2]</code>:</p><pre><code class="spec">     foldr oplus e (x0 : (x1 : (x2 : [])))
===  x0 ⊕ foldr oplus e (x1 : (x2 : []))
===  x0 ⊕ (x1 ⊕ foldr oplus e (x2 : []))
===  x0 ⊕ (x1 ⊕ (x2 ⊕ foldr oplus e []))
===  x0 ⊕ (x1 ⊕ (x2 ⊕ e)) 
</code></pre><p>我們可看到 <code class="haskell">foldr</code> 將串列走訪一次，將每個 <code class="haskell">(:)</code> 替換成 <code class="haskell">oplus</code>, 將 <code class="haskell">[]</code> 替換成 <code class="haskell">e</code>.&shy;式子中的括號往右邊結合，這是 <code class="haskell">foldr</code> 的名字中字母 <code class="haskell">r</code> 的由來。&shy;這種理解也便於解釋 <code class="haskell">foldr</code> 的型別。&shy;回想串列的兩個建構元，</p><ul><li><p><code class="haskell">[]</code> 的型別是 <code class="haskell">List a</code>,</p></li><li><p><code class="haskell">(:)</code> 的型別是 <code class="haskell">a -&gt; List a -&gt; List a</code>.</p></li></ul><p>函數 <code class="haskell">foldr oplus e</code> 接收一個 <code class="haskell">List a</code>，把其中的建構元分別替換為 <code class="haskell">e</code> 與 <code class="haskell">oplus</code>，藉此算出一個型別為 <code class="haskell">b</code> 的值。因此，</p><ul><li><p><code class="haskell">e</code> 是輸入為 <code class="haskell">[]</code> 時立刻傳回的值，其型別必須是 <code class="haskell">b</code>.</p></li><li><p>至於 <code class="haskell">oplus</code> 的型別，考慮 <code class="haskell">x0 ⊕ (x1 ⊕ (x2 ⊕ e))</code> 這個式子。&shy;其中 <code class="haskell">x0</code> 的型別為 <code class="haskell">a</code>, <code class="haskell">x1 ⊕ (x2 ⊕ e)</code> 是建構元已被替換過的串列，型別應該為 <code class="haskell">b</code>.&shy;而 <code class="haskell">oplus</code> 拿到這兩個輸入後，得算出一個型別為 <code class="haskell">b</code> 的值.&shy;因此 <code class="haskell">oplus</code> 的型別為 <code class="haskell">a -&gt; b -&gt; b</code>.</p></li></ul><p>注意：<code class="haskell">e</code> 與 <code class="haskell">oplus</code> 的型別分別是將 <code class="haskell">[]</code> 與 <code class="haskell">(:)</code> 的型別中的 <code class="haskell">List a</code> 代換成 <code class="haskell">b</code> 而來。&shy;綜合言之，&shy;<code class="haskell">foldr</code> 的型別是 <code class="haskell">(a -&gt; b -&gt; b) -&gt; b -&gt; List a -&gt; b</code>.</p><p>為方便說明，此後我們將 <code class="haskell">foldr oplus e</code> 之中的 <code class="haskell">e</code> 稱作<em>基底值</em>(<em>base value</em>)<span id="ix-6-3"></span>，將 <code class="haskell">oplus</code> 稱作<em>步驟函數</em>(<em>step function</em>)<span id="ix-6-4"></span>.&shy;函數 <code class="haskell">foldr</code> 的型別可以理解為：給一個型別為 <code class="haskell">a -&gt; b -&gt; b</code> 的步驟函數，和一個型別為 <code class="haskell">b</code> 的基底值，<code class="haskell">foldr</code> 就能將一個 <code class="haskell">List a</code> 轉換為 <code class="haskell">b</code>.</p><p>串列的摺(<code class="haskell">foldr</code>)只是一個常用的特例 ---「將資料結構中的建構元代換掉」的動作也可推廣到其他資料結構上。&shy;我們在之後的章節中將看到一些其他資料結構上的摺。</p><p>下一節將舉更多使用 <code class="haskell">foldr</code> 的例子。&shy;在那之前我們再次提醒讀者：在 <code class="haskell">foldr oplus e (x:xs)</code> 的狀況中，<code class="haskell">oplus</code> 可以使用 <code class="haskell">x</code> 與 <code class="haskell">foldr oplus e xs</code> 的結果，但不能直接使用 <code class="haskell">xs</code>.</p><h3 class="subsection" id="sec:more-folds-on-lists">6.1.1 更多串列上的摺</h3><p>回顧起來，我們可發現第<a href="Induction.html#ch:induction">2 </a>章介紹的許多函數都是 <code class="haskell">foldr</code>.</p><div class="theorem" id="eg:foldr"><h5 class="theorem-title">例 6.1  </h5><p>以下函數都可寫成 <code class="haskell">foldr</code>:</p><ul><li><p><code class="haskell">concat = foldr (++) []</code>.</p></li><li><p><code class="haskell">filter p = foldr (\ x xs -&gt; if p x then x:xs else xs) []</code>,</p></li><li><p><code class="haskell">takeWhile p = foldr (\x xs -&gt; if p x then x:xs else []) []</code>,</p></li><li><p><code class="haskell">elem x = foldr (\y b -&gt; x == y ⋁ b) False</code>,</p></li><li><p><code class="haskell">all p = foldr (\x b -&gt; p x ⋀ b) True</code>.</p></li></ul></div><p>串列連接 <code class="haskell">(++) :: List a -&gt; List a -&gt; List a</code> 雖是個二元運算，&shy;若將 <code class="haskell">(++ ys) :: List a -&gt; List a</code> 視為一個函數，它可寫成一個 <code class="haskell">foldr</code>:</p><pre><code class="spec"> (++ ys) = foldr (:) ys 
</code></pre><p>一個重要的特例是當 <code class="haskell">ys = []</code> 時。對任何 <code class="haskell">xs</code>, <code class="haskell">xs ++ [] = xs</code>. 因此 <code class="haskell">(++[])</code> 是串列上的 <code class="haskell">id</code>:</p><pre><code class="spec">id :: List a -&gt; List a
id = foldr (:) [] 
</code></pre><p>確實，將一個串列中的 <code class="haskell">(:)</code> 代換成 <code class="haskell">(:)</code>, <code class="haskell">[]</code> 代換成 <code class="haskell">[]</code>, 我們還是得到原來的串列。&shy;我們日後還會用到「串列上的 <code class="haskell">id</code> 是一個 <code class="haskell">foldr</code>」的性質。</p><p>計算所有前段的函數 <code class="haskell">inits :: List a -&gt; List (List a)</code> 可寫成 <code class="haskell">foldr</code>:&shy;<span id="ix-6-5"></span></p><pre><code class="haskell">inits = foldr (\x xss -&gt; [] : map (x:) xss) [[]] 
</code></pre><p>計算所有後段的 <code class="haskell">tails :: List a -&gt; List (List a)</code> 也可以寫成 <code class="haskell">foldr</code>，但需要用一個小性質。&shy;回顧其定義：&shy;<span id="ix-6-6"></span></p><pre><code class="spec">tails []      = [[]]
tails (x:xs)  = (x:xs) : tails xs 
</code></pre><p>乍看之下這不符合 <code class="haskell">foldr</code> 的模式：參數 <code class="haskell">xs</code> 出現在 <code class="haskell">... : tails xs</code> 的左邊，但在 <code class="haskell">foldr</code> 的模式中，<code class="haskell">xs</code> 不能出現在遞迴呼叫之外。&shy;幸好 <code class="haskell">tails</code> 有一個剛好在此有用的小特性：<code class="haskell">tails xs</code> 傳回的所有後段中，第一個就是 <code class="haskell">xs</code> 本身：<code class="haskell">head (tails xs) = xs</code>.&shy;因此我們可將 <code class="haskell">tails</code> 寫成：</p><pre><code class="haskell">tails = foldr (\x xss -&gt; (x : head xss) : xss) [[]] 
</code></pre><p>由於 <code class="haskell">tails</code> 永遠傳回非空串列，使用 <code class="haskell">head xss</code> 是安全的。</p><div class="exlist"><div class="exercise exer" id="ex:perms-sublists-splits-foldr"><h5 class="exercise-title">練習 6.1 </h5><p>請將以下函數寫成 <code class="haskell">foldr</code>:</p><ol><li><p><code class="haskell">perms :: List a -&gt; List (List a)</code> (見第<a href="Induction.html#sec:fan-perm">2.6.4 </a>節),</p></li><li><p><code class="haskell">sublists :: List a -&gt; List (List a)</code> (見第<a href="Induction.html#sec:fan-perm">2.6.4 </a>節),</p></li><li><p><code class="haskell">splits :: List a -&gt; List (List a × List a)</code> （見習題<a href="Induction.html#ex:splits">2.27 </a>）。</p></li></ol></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-1" type="checkbox"/><label class="lbl-toggle" for="ans-6-1">顯示答案</label><div class="collapsible-content"><h5>答案</h5><ol><li><p><code class="haskell">perms = foldr (\x xss -&gt; concat (map (fan x) xss)) [[]]</code></p></li><li><p><code class="haskell">sublists = foldr (\x xss -&gt; xss ++ map (x:) xss) [[]]</code></p></li><li><p><code class="haskell">splits</code> 可定義如下：</p></li></ol><pre><code class="haskell">splits = foldr spl [([],[])] 
  where  spl x ((xs,ys):zss) =
           ([],x:xs++ys) : map ((x:) *** id) ((xs,ys):zss) 
</code></pre></div></div></div><h3 class="subsection" id="sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</h3><p>並非所有輸入為串列的函數都是 <code class="haskell">foldr</code>.&shy;最明顯的例子是 <code class="haskell">tail</code>: 我們無法由 <code class="haskell">x</code> 和 <code class="haskell">tail xs</code> 算出 <code class="haskell">tail (x:xs)</code>。&shy;例如，<code class="haskell">tail [1,2,3] = [2,3]</code>，但 <code class="haskell">tail [2,3] = [3]</code>, 而 <code class="haskell">[2,3]</code> 無法由 <code class="haskell">1</code> 和 <code class="haskell">[3]</code> 組出來。</p><p>另一個例子是 <code class="haskell">dropWhile p</code>. 回顧其定義：</p><pre><code class="spec">dropWhile p []      = []
dropWhile p (x:xs)  = if p x then dropWhile p xs else x:xs 
</code></pre><p>在歸納情況中，<code class="haskell">else</code> 的分支需傳回 <code class="haskell">x:xs</code> --- <code class="haskell">xs</code> 出現在遞迴呼叫以外的地方。這樣的程式不是 <code class="haskell">foldr</code>。&shy;當然，這只表示 <code class="haskell">dropWhile p</code> 的<em>這個</em>定義不符合 <code class="haskell">foldr</code> 的模式.&shy;是否有其他的方式能將 <code class="haskell">dropWhile p</code> 寫成 <code class="haskell">foldr</code> 呢？&shy;不論 <code class="haskell">dropWhile p</code> 是怎麼定義的，考慮&shy;<code class="haskell">dropWhile even [4,3,6,2] = [3,6,2]</code>, 但 <code class="haskell">dropWhile even [3,6,2] = []</code> ---&shy;看來，<code class="haskell">dropWhile p</code> 丟掉了太多資訊，使得我們無法保證能從 <code class="haskell">dropWhile p xs</code> 重組出 <code class="haskell">dropWhile p (x:xs)</code>。&shy;因此，<code class="haskell">dropWhile p</code> 和 <code class="haskell">tail</code> 一樣，是先天上無法寫成 <code class="haskell">foldr</code> 的。</p><div class="exlist"><div class="exercise exer" id="ex:fan-foldr"><h5 class="exercise-title">練習 6.2 </h5><p>考慮第<a href="Induction.html#sec:fan-perm">2.6.4 </a>節的函數 <code class="haskell">fan</code>:</p><pre><code class="spec">fan :: a -&gt; List a -&gt; List (List a)
fan y []      = [[y]]
fan y (x:xs)  = (y:x:xs) : map (x:) (fan y xs) 
</code></pre><p>為何這個定義目前的形式不是一個 <code class="haskell">foldr</code>?&shy;有沒有可能將 <code class="haskell">fan y</code> 寫成一個 <code class="haskell">foldr</code> 呢？</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-2" type="checkbox"/><label class="lbl-toggle" for="ans-6-2">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>由於 <code class="haskell">xs</code> 出現在遞迴呼叫以外的地方 --- <code class="haskell">((y:x:xs) :)</code>, 此處的 <code class="haskell">fan</code> 定義並不是一個 <code class="haskell">foldr</code>.&shy;但由於 <code class="haskell">tail (head (fan y xs)) = xs</code>&shy;（例如，<code class="haskell">fan 5 [1,2,3] = [[5,1,2,3],[1,5,2,3],[1,2,5,3],[1,2,3,5]]</code>,&shy;因此 <code class="haskell">tail (head (fan 5 [1,2,3])) = [1,2,3]</code>），&shy;我們可將 <code class="haskell">fan</code>寫成：</p><pre><code class="haskell">fan' y = foldr (\x xss -&gt; (y:x: tail (head xss)) : map (x:) xss) [[y]] 
</code></pre></div></div></div><h2 class="section" id="sec:foldr-fusion">6.2 摺融合定理</h2><p>第<a href="Introduction.html#ch:intro">0 </a>章中提及，「抽象化」意指抽取出我們認為重要的概念、成分，給予一個名字或符號。&shy;如此一來，這個概念正式地「存在」了，我們可以談論它、研究其性質，並將研究結果應用在所有符合這個抽象概念的事物上。&shy;一個程式語言最重要的功能之一是提供良好的抽象化機制。&shy;由於高階函數等等性質，函數語言讓我們能較容易地對程式結構作抽象。</p><p>「摺」是我們找到的一個抽象，許多程式可以表達為摺。&shy;而一旦辨識出了摺這個結構，我們可開始討論所有摺都滿足的性質，&shy;這些性質則將可適用於所有是摺的程式上。</p><p>關於摺的性質中，最重要的也許是本節的<em>摺融合定理</em>(<em>fold-fusion theorem</em>)。</p><p>摺融合定理告訴我們一個摺如何能與串接於其後的函數融合起來，成為單獨的一個摺：</p><div class="theorem" id="thm:foldr-fusion" title="摺融合定理(串列版)"><h5 class="theorem-title">定理 6.2  摺融合定理(串列版) </h5><p><span id="ix-6-7"></span>&shy;給定 <code class="haskell">f :: a -&gt; b -&gt; b</code>, <code class="haskell">e :: b</code>, <code class="haskell">h :: b -&gt; c</code>.&shy;如果 <code class="haskell">h (f x y) = g x (h y)</code> 對所有 <code class="haskell">x :: a</code> 與<em>在 <code class="haskell">foldr f e</code> 的值域中的</em> <code class="haskell">y :: b</code> 成立，則</p><pre><code class="spec">h . foldr f e = foldr g (h e) 
</code></pre></div><p>性質 <code class="haskell">h (f x y) = g x (h y)</code> 是該融合能成立的充分條件，我們日後將稱之為「<em>融合條件</em>(<em>fusion condition</em>)」。<span id="ix-6-8"></span>&shy;如果定理本身看來太抽象，下述例子也許可給讀者一些直覺。考慮 <code class="haskell">[x0,x1,x2]</code>:</p><pre><code class="haskell">      <comment>{-"{\color{burntorange}"-}</comment>h<comment>{-"}"-}</comment> (foldr f e [x0,x1,x2])
 ===    <comment>{- <code class="haskell">foldr</code> 之定義 -}</comment>
      <comment>{-"{\color{burntorange}"-}</comment>h<comment>{-"}"-}</comment> (f x0 (f x1 (f x2 e)))
 ===    <comment>{- 融合條件: <code class="haskell">{-"{\color{burntorange}"-}h{-"}"-} (f x y) = g x ({-"{\color{burntorange}"-}h{-"}"-} y)</code> -}</comment>
      g x0 (<comment>{-"{\color{burntorange}"-}</comment>h<comment>{-"}"-}</comment> (f x1 (f x2 e)))
 ===    <comment>{- 融合條件: <code class="haskell">{-"{\color{burntorange}"-}h{-"}"-} (f x y) = g x ({-"{\color{burntorange}"-}h{-"}"-} y)</code> -}</comment>
      g x0 (g x1 (<comment>{-"{\color{burntorange}"-}</comment>h<comment>{-"}"-}</comment> (f x2 e)))
 ===    <comment>{- 融合條件: <code class="haskell">{-"{\color{burntorange}"-}h{-"}"-} (f x y) = g x ({-"{\color{burntorange}"-}h{-"}"-} y)</code> -}</comment>
      g x0 (g x1 (g x2 (<comment>{-"{\color{burntorange}"-}</comment>h<comment>{-"}"-}</comment> e)))
 ===    <comment>{- <code class="haskell">foldr</code> 之定義 -}</comment>
      foldr g (<comment>{-"{\color{burntorange}"-}</comment>h<comment>{-"}"-}</comment> e) [x0,x1,x2] 
</code></pre><p>由此例可看出融合條件 <code class="haskell">h (f x y) = g x (h y)</code> 的作用 --- 將 <code class="haskell">h</code> 往右推，並將途中經過的 <code class="haskell">f</code> 都變成 <code class="haskell">g</code>, 直到碰到 <code class="haskell">e</code> 為止。</p><p>定理<a href="Folds.html#thm:foldr-fusion">6.2 </a>可用例行的歸納證明證成：</p><div class="proof"><b>證明 </b><p>假設融合條件成立，我們需證明對所有 <code class="haskell">xs</code>, <code class="haskell">h (foldr f e xs) = foldr g (h e) xs</code>.</p><p><strong>情況</strong> <code class="haskell">xs := []</code>:</p><pre><code class="spec">      h (foldr f e [])
 ===  h e
 ===  foldr g (h e) [] 
</code></pre><p><strong>情況</strong> <code class="haskell">xs := x:xs</code>:</p><pre><code class="spec">      h (foldr f e (x:xs))
 ===    <comment>{- <code class="haskell">foldr</code> 之定義 -}</comment>
      h (f x (foldr f e xs))
 ===    <comment>{- 融合條件: <code class="haskell">h (f x y) = g x (h y)</code> -}</comment>
      g x (h (foldr f e xs))
 ===    <comment>{- 歸納假設 -}</comment>
      g x (foldr g (h e) xs)
 ===    <comment>{- <code class="haskell">foldr</code> 之定義 -}</comment>
      foldr g (h e) (x:xs) 
</code></pre></div><p id="para:bring-in-context-prelim"><b>註記</b> &emsp;&shy;我們在歸納情況的第二步使用了融合條件 <code class="haskell">h (f x y) = g x (h y)</code>. 欲使該步成立，融合條件不須對所有 <code class="haskell">y</code> 都成立 --- 我們只需要它在 <em><code class="haskell">y</code> 是 <code class="haskell">foldr f e</code> 的可能結果</em>時成立即可。這是定理<a href="Folds.html#thm:foldr-fusion">6.2 </a>中「在 <code class="haskell">foldr f e</code> 的值域中的 <code class="haskell">y</code>」這句話的由來。<span id="ix-6-9"></span></p><p>在本章接下來大部分的例子中，我們其實可以證明融合條件對<em>所有 <code class="haskell">y</code></em> 均成立。但只要我們處理的演算法問題稍微複雜些，我們便會常遇到融合條件只對 <code class="haskell">foldr f e</code> 的值域中的 <code class="haskell">y</code> 成立的情況。&shy;我們將在第<a href="Folds.html#sec:bring-in-context">6.2.6 </a>節中看到一些例子。</p><h3 class="subsection" id="sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</h3><p>定理<a href="Folds.html#thm:foldr-fusion">6.2 </a>有幾種用法：</p><ul><li><p>一種可能是用於證明性質：我們希望證明 <code class="haskell">h . foldr f e</code> 與 <code class="haskell">foldr g (h e)</code> 相等，此時我們已知 <code class="haskell">h</code>, <code class="haskell">f</code>, <code class="haskell">g</code>, 與 <code class="haskell">e</code>.</p></li><li><p>另一種可能是用於生成程式。此時我們通常已知 <code class="haskell">h</code>, <code class="haskell">f</code>, 與 <code class="haskell">e</code>, 但不知道 <code class="haskell">g</code>. 我們希望找到一個讓融合條件成立的 <code class="haskell">g</code>, 使得 <code class="haskell">h . foldr f e</code> 能在一個 <code class="haskell">foldr</code> 之中完成。</p></li></ul><p>我們先討論第一種情況。</p><div class="theorem" id="ex:map-fusion-foldr-fusion"><h5 class="theorem-title">例 6.3  </h5><p>回顧 <code class="haskell">map</code> 融合定理(<a href="Induction.html#thm:map-fusion">2.2 </a>): <code class="haskell">map f . map g = map (f.g)</code>.&shy;第  頁提供了一個歸納證明。&shy;由於 <code class="haskell">map g</code> 是一個摺，我們也可用摺融合定理證明如下。</p><pre><code class="haskell">      map f . map g
 ===   <comment>{- <code class="haskell">map</code> 的摺定義 -}</comment>
      map f . foldr (\x ys -&gt; g x : ys) []
 ===   <comment>{- 摺融合 -}</comment>
      foldr (\x ys -&gt; f (g x) : ys) []
 ===   <comment>{- <code class="haskell">map</code> 的摺定義 -}</comment>
      map (f . g) 
</code></pre><p>第二步需要的融合條件只需簡單展開定義即可滿足：</p><pre><code class="haskell">      map f (g x : ys)
 ===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
      f (g x) : map f ys 
</code></pre></div><p>將上述例子與第<a href="Induction.html#sec:induction-lists">2.4 </a>節的歸納證明比較。&shy;歸納證明中，最關鍵的是「使用歸納步驟」的一步，而使用摺融合定理的證明卻沒有這步 --- 歸納步驟的使用被包裝、隱藏在摺融合定理中了。&shy;而上述例子中關於融合條件的證明，恰巧是原歸納證明中和問題本身最相關的部分。</p><p>我們可說：摺融合定理之於證明，就如同摺之於程式。&shy;摺是抽象出的常見程式骨架，將拆解輸入串列、做遞迴呼叫等動作包裝起來。&shy;有了摺，我們不需自己做遞迴呼叫，只需填入針對特定問題的 <code class="haskell">f</code>, <code class="haskell">e</code> 等參數的值。&shy;摺融合定理則是抽象出的常見證明骨架，將狀況分析、使用歸納假設等動作包裝起來。&shy;有了摺融合定理，我們不需自己做狀況分析、引用歸納假設，只需填入針對這個問題的融合條件的證明。</p><p>事實上，<code class="haskell">map</code> 融合定理是下述定理的特例：</p><div class="theorem" id="thm:foldr-map-fusion" title="|foldr|-|map| 融合定理"><h5 class="theorem-title">定理 6.4  |foldr|-|map| 融合定理 </h5><p><code class="haskell">foldr f e . map g = foldr (f . g) e</code>.</p></div><p>我們時常看到 <code class="haskell">foldr</code> 與 <code class="haskell">map</code> 一起出現，此時定理<a href="Folds.html#thm:foldr-map-fusion">6.4 </a> 相當好用。</p><div class="theorem" id="eg:foldr-sum-map"><h5 class="theorem-title">例 6.5  </h5><p>我們嘗試證明 <code class="haskell">sum . map (2*) = (2*) . sum</code>.&shy;首先考慮等號左手邊的 <code class="haskell">sum . map (2*)</code>. 由於 <code class="haskell">sum</code> 是一個 <code class="haskell">foldr</code>, 我們可用定理<a href="Folds.html#thm:foldr-map-fusion">6.4 </a>將該式合併為一個 <code class="haskell">foldr</code>:</p><pre><code class="haskell">       sum . map (2*)
  ===    <comment>{- <code class="haskell">sum</code> 之摺定義 -}</comment>
       foldr (+) 0 . map (2*)
  ===    <comment>{- 定理\ref{thm:foldr-map-fusion}: <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合 -}</comment>
       foldr ((+).(2*)) 0 
</code></pre><p>另一方面，<code class="haskell">(2*) . sum</code> 可以融合成同一個 <code class="haskell">foldr</code>:</p><pre><code class="spec">       (2*) . sum
  ===  (2*) . foldr (+) 0
  ===    <comment>{- 摺融合 -}</comment>
       foldr ((+).(2*)) 0 
</code></pre><p>其中的融合條件證明如下：</p><pre><code class="haskell">      2*(x+y)
 ===   <comment>{- 乘法與加法之分配率 -}</comment>
      2*x + 2*y
 ===   <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
      ((+) . (2*)) x (2*y) 
</code></pre><p>由此我們證明了 <code class="haskell">sum . map (2*) = (2*) . sum</code>.</p></div><p>許多等式可用類似的模式證明：為證明 <code class="haskell">e1 = e2</code>, 我們對兩邊都做融合，看是否能製造出同一個 <code class="haskell">foldr</code>.</p><div class="theorem" id="eg:foldr-map-append"><h5 class="theorem-title">例 6.6  </h5><p>回顧練習<a href="Induction.html#ex:map-append">2.11 </a>：證明對所有 <code class="haskell">f</code>, <code class="haskell">xs</code>, 與 <code class="haskell">ys</code>, <code class="haskell">map f (xs ++ ys) = map f xs ++ map f ys</code>. 若把 <code class="haskell">xs</code> 提出，這相當於證明：</p><pre><code class="spec">  map f . (++ys) = (++ map f ys) . map f  
</code></pre><p>其中 <code class="haskell">(++ys)</code> 是 <code class="haskell">foldr</code>. 因此我們可使用摺融合與 <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合：</p><pre><code class="haskell">      (++ map f ys) . map f
 ===    <comment>{- <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合 -}</comment>
      foldr ((:) . f) (map f ys)
 ===    <comment>{- 摺融合 -}</comment>
      map f . (++ ys) 
</code></pre><p>其中，最後一步的融合條件為</p><pre><code class="spec">     map f (x : zs)
===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
     f x : map f zs
===    <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
     ((:) . f) x (map f zs) 
</code></pre><p>雖然看來複雜，其實是運用符號、展開定義即可證成的性質。</p></div><p>在本節的許多例子中，使用摺融合定理大大簡化了證明 --- 幾乎到了只要把式子寫下就快要證完了，「沒什麼可說」的地步。我們再看最後一個例子。</p><div class="theorem" id="eg:foldr-sunConcatMapSum"><h5 class="theorem-title">例 6.7  </h5><p>考慮證明第<a href="Induction.html#sec:data-prog-proof">2.5 </a>節中提及的性質: <code class="haskell">sum . concat = sum . map sum</code>.&shy;我們可使用 <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合定理與摺融合定理：</p><pre><code class="haskell">      sum . map sum
 ===  foldr (+) 0 . map sum
 ===    <comment>{- <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合 -}</comment>
      foldr (\xs n -&gt; sum xs + n) 0
 ===    <comment>{- 摺融合 -}</comment>
      sum . foldr (++) []
 ===  sum . concat 
</code></pre><p>第二步的 <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合能成立的原因是 <code class="haskell">(+) . sum</code> 展開之後確實成為 <code class="haskell">(\xs n -&gt; sum xs + n)</code>.&shy;這一步也可改用摺融合定理證明，其融合條件為 <code class="haskell">sum (sum xs : ys) = sum xs + sum ys</code>, 只需展開定義即可證成。</p><p>倒數第二步的摺融合的條件為：<code class="haskell">sum (xs ++ ys) = sum xs + sum ys</code>.&shy;這是第<a href="Induction.html#sec:data-prog-proof">2.5 </a>節的證明中必須發明的關鍵性質。&shy;我們再一次看到：使用摺融合定理讓我們只需提供一個證明中最與問題相關的關鍵部分。</p></div><div class="exlist"><div class="exercise exer" id="ex:foldr-map-fusion"><h5 class="exercise-title">練習 6.3 </h5><p>請用摺融合證明 <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合定理(<a href="Folds.html#thm:foldr-map-fusion">6.4 </a>).</p></div><div class="exercise exer" id="ex:foldr-length-concat"><h5 class="exercise-title">練習 6.4 </h5><p>使用 <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合和摺融合證明 <code class="haskell">sum . map length = length . concat</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-4" type="checkbox"/><label class="lbl-toggle" for="ans-6-4">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">      sum . map length
 ===    <comment>{- <code class="haskell">sum = foldr (+) 0</code>, <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合 -}</comment>
      foldr ((+) . length) 0
 ===    <comment>{- 摺融合 -}</comment>
      length . foldr (++) []
 ===  length . concat 
</code></pre><p>其融合條件證明如下：</p><pre><code class="haskell">       length (xs ++ ys)
  ===    <comment>{- <code class="haskell">length</code> 與 <code class="haskell">(++)</code> 的同態性 -}</comment>
       length xs + length ys
  ===    <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
       ((+) . length) xs (length ys) 
</code></pre></div></div><div class="exercise exer" id="ex:mapConcat-concatMapMap"><h5 class="exercise-title">練習 6.5 </h5><p>使用摺融合定理證明對所有 <code class="haskell">f</code>, <code class="haskell">map f . concat = concat . map (map f)</code>.</p></div><div class="exercise exer" id="ex:map-filter-split"><h5 class="exercise-title">練習 6.6 </h5><p>給定 <code class="haskell">f, g :: a -&gt; List a</code> 與 <code class="haskell">p :: a -&gt; Bool</code>, 試證明：&shy;如果 <code class="haskell">filter p (f x) = if p x then g x else []</code>, 則 <code class="haskell">concat . map (filter p . f) = concat . map g . filter p</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-6" type="checkbox"/><label class="lbl-toggle" for="ans-6-6">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>回顧：<code class="haskell">filter p = foldr (\x xs -&gt; if p x then x:xs else xs) []</code>,&shy;<code class="haskell">concat = foldr (++) []</code>.&shy;我們演算如下：</p><pre><code class="haskell">      concat . map g . filter p
 ===    <comment>{- 摺融合，如下述 -}</comment>
      foldr (\x ys -&gt; filter p (f x) ++ ys) []
 ===    <comment>{- <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合，如下述 -}</comment>
      concat . map (filter p . f) 
</code></pre><p>摺融合的條件為：</p><pre><code class="haskell">      concat (map g (if p x then x:xs else xs))
 ===    <comment>{- <code class="haskell">concat . map g</code> 分配進 <code class="haskell">if</code> 之中 -}</comment>
      if p x then g x ++ concat (map g xs) else concat (map g xs)
 ===    <comment>{- 提出 <code class="haskell">concat (map g xs)</code> -}</comment>
      (if p x then g x else []) ++ concat (map g xs)
 ===    <comment>{- 假設 -}</comment>
      filter p (f x) ++ concat (map g xs) 
</code></pre><p>至於 <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合, 只需驗證 <code class="haskell">((++) . filter p . f) x ys</code> 確實等於 <code class="haskell">filter p (f x) ++ ys</code>.</p></div></div></div><h3 class="subsection" id="sec:foldr-program-gen">6.2.2 以摺融合生成程式</h3><p>如前所述，另一種使用摺融合的理由是生成程式：我們希望 <code class="haskell">h . foldr f e</code> 能在一個 <code class="haskell">foldr</code> 之中完成。&shy;此時我們已知 <code class="haskell">h</code>, <code class="haskell">f</code>, 與 <code class="haskell">e</code>, 希望用融合條件找出適合的步驟函數。</p><div class="theorem" id="ex:sum-map-square-fusion"><h5 class="theorem-title">例 6.8  </h5><p>回顧第<a href="Derivation.html#sec:fold-unfold-transform">5.1 </a>節的例子：&shy;給定 <code class="haskell">sumsq = sum . map square</code>，我們希望找出一個不產生中間串列的版本。&shy;由於 <code class="haskell">map square</code> 是一個 <code class="haskell">foldr</code>, 我們嘗試將 <code class="haskell">sum</code> 融合進 <code class="haskell">map square</code> 中，&shy;希望找出能滿足 <code class="haskell">sumsq = foldr g e</code> 的 <code class="haskell">g</code> 與 <code class="haskell">e</code> .&shy;顯然 <code class="haskell">e = sumsq [] = 0</code>.&shy;為了找出滿足融合條件的步驟函數 <code class="haskell">g</code>, 我們推算：</p><pre><code class="haskell">      sum (square x : xs)
 ===    <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
      square x + sum xs
 ===    <comment>{- 提出 <code class="haskell">x</code> 與 <code class="haskell">sum xs</code> -}</comment>
      (\x y -&gt; square x + y) x (sum xs) 
</code></pre><p>因此，根據定理<a href="Folds.html#thm:foldr-fusion">6.2 </a>, <code class="haskell">sumsq = foldr (\x y -&gt; square x + y) 0</code>.</p></div><div class="theorem" id="ex:minimumMapSumInits"><h5 class="theorem-title">例 6.9  </h5><p>給定一個整數串列，其中由左到右的數字表示對一個帳戶存款或提款的金額：正數為存款、負數為提款。&shy;我們想確定在任何一個時刻帳戶金額不至於變成負數。&shy;一個可能做法是：對該串列的每一個前段算總和，我們可得到每個時刻的帳戶金額。&shy;接著看看其中最小值是否為負數即可。&shy;定義函數 <code class="haskell">noOverdraft</code> 如下：</p><pre><code class="spec">noOverdraft :: Int -&gt; Bool
noOverdraft = (&gt;= 0) . minimum . map sum . inits 
</code></pre><p>我們試著導出一個比較快速的版本。</p><p>為增進效率，我們試試看能否把 <code class="haskell">minimum . map sum . inits</code> 合併為一個 <code class="haskell">foldr</code>.&shy;回顧：<code class="haskell">inits = foldr (\x xss -&gt; [] : map (x:) xss) []</code>.&shy;我們可以一口氣把 <code class="haskell">minimum . map sum</code> 融合進 <code class="haskell">inits</code>, 也可分兩次進行，先將 <code class="haskell">map sum . inits</code> 融合成一個 <code class="haskell">foldr</code>, 再與 <code class="haskell">minimum</code> 融合。</p><p>此處我們嘗試後者，先將 <code class="haskell">map sum . inits</code> 融合。基底值為 <code class="haskell">map sum [[]] = [0]</code>, 而步驟函數 <code class="haskell">step1</code> 須滿足的融合條件為 <code class="haskell">map sum ([] : map (x:) xss) = step1 x (map sum xss)</code>. 試計算如下：</p><pre><code class="haskell">      map sum ([] : map (x:) xss)
 ===  0 : map sum (map (x:) xss)
 ===   <comment>{- <code class="haskell">map</code> 融合 -}</comment>
      0 : map (sum . (x:)) xss
 ===   <comment>{- <code class="haskell">sum (x:xs) = x + sum xs</code>, <code class="haskell">map</code> 融合 -}</comment>
      0 : map (x+) (map sum xss) 
</code></pre><p>因此我們得到</p><pre><code class="haskell">  map sum . inits === foldr (\x ys -&gt; 0 : map (x+) ys) [0] 
</code></pre><p>下一步是將 <code class="haskell">minimum</code> 融合進 <code class="haskell">map sum . inits</code>. 基底值為 <code class="haskell">minimum [0] = 0</code>, 而步驟函數 <code class="haskell">step2</code> 須滿足 <code class="haskell">minimum (0 : map (x+) ys) = step2 x (minimum ys)</code>. 計算如下：</p><pre><code class="haskell">      minimum (0 : map (x+) ys)
 ===  0 ↓ minimum (map (x+) ys)
 ===    <comment>{- <code class="haskell">minimum (x+) ys = x + minimum ys</code>，後述 -}</comment>
      0 ↓ (x + minimum ys) 
</code></pre><p>最後一步使用的性質 <code class="haskell">minimum (x+) ys = x + minimum ys</code> 尚待證明，其關鍵性質是 <code class="haskell">(x+)</code> 可分配進 <code class="haskell">(↓)</code> 之中：<code class="haskell">x + (y ↓ z) = (x + y) ↓ (x + z)</code>. 總之，我們得到</p><pre><code class="haskell">      noOverdraft
 ===  (&gt;= 0) . minimum . map sum . inits
 ===  (&gt;= 0) . foldr (\x y -&gt; 0 ↓ (x + y)) 0 
</code></pre><p>這是一個只需線性時間的演算法。</p><p>我們能否把 <code class="haskell">(&gt;=0)</code> 也融入 <code class="haskell">foldr</code> 之中呢？要使這個融合成立，我們得找到滿足&shy;<code class="haskell">0 ↓ (x+y) &gt;= 0 &lt;=&gt; step3 x (y &gt;= 0)</code> 的 <code class="haskell">step3</code>. 演算如下：</p><pre><code class="spec">     0 ↓ (x+y) &gt;= 0
&lt;=&gt;    <comment>{- <code class="haskell">a ↓ b &gt;= c &lt;=&gt; a &gt;= c ⋀ b &gt;= c</code> -}</comment>
     0 &gt;= 0 ⋀ x+y &gt;= 0
&lt;=&gt;  x + y &gt;= 0
&lt;=&gt;    <comment>{- 希望找到這樣的 <code class="haskell">step3</code> -}</comment>
     step3 x (y&gt;=0) 
</code></pre><p>然而我們無法找到這樣的 <code class="haskell">step3</code> --- 僅由 <code class="haskell">y&gt;=0</code> 我們無法得知 <code class="haskell">x+y &gt;= 0</code> 是否成立。&shy;我們可說 <code class="haskell">(&gt;=0)</code> 丟失了太多資訊，使得融合無法成立。</p><p>也由於同樣的理由，如果我們最初把問題定義為：</p><pre><code class="spec">  noOverdraft = and . map (&gt;=0) . map sum . inits 
</code></pre><p>函數 <code class="haskell">map (&gt;= 0)</code> 將無法融合進 <code class="haskell">map sum . inits</code> 之中。</p></div><p>使用摺融合論證兩個式子相等的證明常有如下的形式：</p><pre><code class="spec">     h1 . foldr f1 e1
===    <comment>{- 摺融合定理 -}</comment>
     foldr g (h1 e1)
===    <comment>{- 摺融合定理 -}</comment>
     h2 . foldr f2 e2 
</code></pre><p>此時，我們也常需要藉由兩個融合條件之一來發現步驟函數 <code class="haskell">g</code> 是什麼。</p><div class="theorem" id="eg:foldr-length-sublists"><h5 class="theorem-title">例 6.10  </h5><p>習題 <a href="Induction.html#ex:length-sublists">2.28 </a> 曾證明 <code class="haskell">length . sublists = exp 2 . length</code>.&shy;此處我們用摺融合定理試試看。</p><p>考慮等式的左手邊，我們嘗試將 <code class="haskell">length . sublists</code> 融合為一個 <code class="haskell">foldr</code>.&shy;由於 <code class="haskell">sublists = foldr (\x xss -&gt; xss ++ map (x:) xss) [[]]</code>（習題 <a href="Folds.html#ex:perms-sublists-splits-foldr">6.1 </a>(2)），融合後的 <code class="haskell">foldr</code> 之基底值為 <code class="haskell">length [[]] = 1</code>.&shy;為找出步驟函數，我們推算：</p><pre><code class="haskell">      length (xss ++ map (x:) xss)
 ===  length xss + length (map (x:) xss)
 ===    <comment>{- <code class="haskell">length (map f) = length</code> -}</comment>
      2 * length xss 
</code></pre><p>由此得到步驟函數 <code class="haskell">(\x n -&gt; 2 * n)</code>.</p><p>因此該等式可證明如下：</p><pre><code class="spec">     length . sublists
===  length . foldr (\x xss -&gt; xss ++ map (x:) xss) [[]]
===    <comment>{- 摺融合定理，如上 -}</comment>
     foldr (\x n -&gt; 2 * n) 1
===    <comment>{- 摺融合定理，如下 -}</comment>
     exp 2 . foldr Suc Zero
===  exp 2 . length 
</code></pre><p>在第二次摺融合中，基底值 <code class="haskell">exp 2 Zero</code> 確實是 <code class="haskell">1</code>.&shy;融合條件為 <code class="haskell">exp 2 (Suc n) = 2 * exp 2 n</code>.</p></div><div class="exlist"><div class="exercise exer" id="ex:foldr-map-sum-inits"><h5 class="exercise-title">練習 6.7 </h5><p>回顧例<a href="Folds.html#ex:minimumMapSumInits">6.9 </a>. 試著將 <code class="haskell">map (&gt;=0)</code> 融入 <code class="haskell">map sum . inits</code> 中，說說看為何該融合會失敗。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-7" type="checkbox"/><label class="lbl-toggle" for="ans-6-7">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>我們需要滿足融合條件 <code class="haskell">map (&gt;=0) (0 : map (x+) ys) = step x (map &gt;=0 ys)</code> 的 <code class="haskell">step</code>.&shy;演算如下：</p><pre><code class="spec">     map (&gt;=0) (0 : map (x+) ys)
===  True : map ((&gt;=0) . (x+)) ys
===  step x (map (&gt;=0) ys) 
</code></pre><p>然而我們無法由 <code class="haskell">map (&gt;=0) ys</code> 算出 <code class="haskell">map ((&gt;=0) . (x+)) ys</code>.</p></div></div><div class="exercise exer" id="ex:foldr-sum-distributivity"><h5 class="exercise-title">練習 6.8 </h5><p>使用摺融合定理證明 <code class="haskell">sum (xs ++ ys) = sum xs + sum ys</code>.&shy;<strong>提示</strong>：這相當於證明 <code class="haskell">sum . (++ys) = (+ (sum ys)) . sum</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-8" type="checkbox"/><label class="lbl-toggle" for="ans-6-8">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">      sum . (++ys)
 ===  sum . foldr (:) ys
 ===    <comment>{- 摺融合 -}</comment>
      foldr (+) (sum ys)
 ===    <comment>{- 摺融合 -}</comment>
      (+ (sum ys)) . foldr (+) 0
 ===  (+ (sum ys)) . sum 
</code></pre><p>其中第一個摺融合的條件為 <code class="haskell">sum (x:xs) = x + sum xs</code> ---&shy;我們由此發現融合後的步驟函數為 <code class="haskell">(+)</code>.&shy;第二個摺融合的條件證明如下：</p><pre><code class="haskell">      (+ (sum ys)) (x + y)
 ===  (x + y) + sum ys
 ===  x + (y + sum ys)
 ===  x + ((+ (sum ys)) y) 
</code></pre></div></div><div class="exercise exer" id="ex:foldr-lengthFan-SucLength"><h5 class="exercise-title">練習 6.9 </h5><p>參考習題 <a href="Folds.html#ex:fan-foldr">6.2 </a>, 使用摺融合定理證明 <code class="haskell">length (fan y xs) = Suc (length xs)</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-9" type="checkbox"/><label class="lbl-toggle" for="ans-6-9">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>相當於證明 <code class="haskell">length . fan y = Suc . length</code>. 推論如下：</p><pre><code class="spec">     length . fan y
===  length . foldr (\x xss -&gt; (y:x: tail (head xss)) : map (x:) xss) [[y]] 
===    <comment>{- 摺融合定理 -}</comment>
     foldr Suc 1
===    <comment>{- 摺融合定理 -}</comment>
     Suc . foldr Suc Zero
===  Suc . length 
</code></pre><p>其中第一次融合的融合條件可證明如下：</p><pre><code class="spec">     length ((y:x: tail (head xss)) : map (x:) xss)
===    <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
     Suc (length (map (x:) xss))
===    <comment>{- <code class="haskell">length . map f = length</code> -}</comment>
     Suc (length xss) 
</code></pre><p>由此發現步驟函數為 <code class="haskell">Suc</code>.&shy;第二次融合的融合條件則只需展開定義即可證成。</p></div></div><div class="exercise exer" id="ex:foldr-decimal"><h5 class="exercise-title">練習 6.10 </h5><p>回顧第<a href="Derivation.html#sec:exp-binary-roll">5.3.2 </a>節中將反轉表示的二進位數字轉為自然數的函數 <code class="haskell">decimal :: List Bool -&gt; Nat</code>.&shy;該函數可寫成一個摺：</p><pre><code class="spec">decimal = foldr (\c n -&gt; if c then 1 + 2 * n else 2 * n) 0 <comment>{-"~~"-}</comment>
</code></pre><p>請使用摺融合將 <code class="haskell">exp b . decimal</code> 表示成單一的摺。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-10" type="checkbox"/><label class="lbl-toggle" for="ans-6-10">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>基底值為 <code class="haskell">base = exp b 0 = 1</code>.&shy;為找出步驟函數，我們推論：</p><pre><code class="spec">     exp b (if c then 1 + 2 * n else 2 * n)
===    <comment>{- 函數分配進 <code class="haskell">if</code> -}</comment>
     if c then exp b (1 + 2 * n) else exp b (2 * n)
===    <comment>{- 因 $m^{x+y} = m^x \times m^y$ -}</comment>
     if c then b * exp b (2 * n) else exp b (2 * n)
===    <comment>{- 因 $m^{2n} = (m^n)^2$, 回顧：<code class="haskell">square x = x * x</code> -}</comment>
     if c then b * square (exp b n) else square (exp b n) 
</code></pre><p>因此可得</p><pre><code class="spec">  exp b . decimal = foldr (\d x -&gt; if c  then b * square x
                                         else square x) 1 
</code></pre></div></div></div><p><b>摺融合與尋找歸納定義</b> &emsp;&shy;回顧：<code class="haskell">id :: List a -&gt; List a</code> 可以寫成一個 <code class="haskell">foldr</code> --- <code class="haskell">id = foldr (:) []</code>.&shy;而任何函數 <code class="haskell">f :: List a -&gt; b</code> 都等於 <code class="haskell">f . id</code>.&shy;如果我們將 <code class="haskell">f</code> 與 <code class="haskell">id</code> 融合，會發生什麼事呢？&shy;首先我們需要找出基底值 <code class="haskell">f []</code> 是什麼。&shy;接著我們要找到滿足 <code class="haskell">f (x:xs) = step x (f xs)</code> 的步驟函數 <code class="haskell">step</code>.&shy;但這其實就是使用展開-收回轉換尋找 <code class="haskell">f</code> 的歸納定義！&shy;只是此處要求的歸納定義比較嚴格：在 <code class="haskell">f xs</code> 之外不能使用 <code class="haskell">xs</code>.</p><p>確實，第<a href="Derivation.html#sec:fold-unfold-transform">5.1 </a>與<a href="Derivation.html#sec:fold-unfold-transform-efficiency">5.3 </a>節中許多尋找歸納定義的演算都可以視為使用摺融合生成程式的例子。&shy;以第<a href="Derivation.html#sec:poly-horner">5.3.1 </a>節的 <code class="haskell">poly</code> 為例。&shy;找出其歸納定義的過程可以視為摺融合：</p><pre><code class="spec">   poly x
=  poly x . id
=   <comment>{- <code class="haskell">id = foldr (:) []</code> -}</comment>
   poly x . foldr (:) []
=   <comment>{- 摺融合定理 -}</comment>
   foldr step (poly x []) 
</code></pre><p>其中基底值 <code class="haskell">poly x [] = 0</code>.&shy;而函數 <code class="haskell">step</code> 須滿足融合條件 <code class="haskell">poly x (a:as) = step a (poly x as)</code>。&shy;尋找 <code class="haskell">step</code> 的過程和第頁的計算完全相同。&shy;我們會得到</p><pre><code class="spec">  poly x (a : as) = a + (poly x as) * x 
</code></pre><p>到此為止我們便找到了 <code class="haskell">poly x</code> 的歸納定義。&shy;也可以說，我們已得知 <code class="haskell">poly x = foldr (\a b -&gt; a + b * x) 0</code>.</p><h3 class="subsection" id="sec:scan-lemma">6.2.3 掃描</h3><p>本節將介紹一個本書首次提及，初見時較難理解，但在許多演算法中扮演重要角色的組件函數：<em>掃描</em>（<em>scan</em>）。<span id="ix-6-10"></span></p><p>如我們所知，函數 <code class="haskell">sum :: List Int -&gt; Int</code> 計算一個串列的總和。&shy;如果我們想計算一個串列由右到左的<em>累計和</em>，例如當給定串列 <code class="haskell">[3,7,2,4]</code>，我們希望得到 <code class="haskell">[16,13,6,4,0]</code>（其中 <code class="haskell">6 = 2 + 4</code>, <code class="haskell">13 = 7 + 2 + 4</code>，<code class="haskell">16 = 3 + 7 + 2 + 4</code>, 而 <code class="haskell">0</code> 是空串列的和），該怎麼做呢？</p><p>在第<a href="Induction.html#sec:list-segments">2.6.3 </a>節中，我們曾提及計算一個串列所有<em>後段</em>(<em>suffixes</em>)的函數 <code class="haskell">tails :: List a -&gt; List (List a)</code>。<span id="ix-6-11"></span>&shy;例如，<code class="haskell">tails [3,7,2,4]</code> 將得到 <code class="haskell">[[3,7,2,4],</code> <code class="haskell">[7,2,4],</code> <code class="haskell">[2,4],</code> <code class="haskell">[4],</code> <code class="haskell">[]]</code>。對串列的每一個後段算總和，我們便得到累計和 <code class="haskell">[16,13,6,4,0]</code> 了：</p><pre><code class="haskell">runsum :: List Int -&gt; List Int
runsum = map sum . tails 
</code></pre><p>由於使用多個 <code class="haskell">sum</code> 函數走訪每個後段，如此定義出的 <code class="haskell">runsum</code> 將是一個執行時間為 $O(n^2)$ 的函數。&shy;但讀者想必已覺得可不用如此費事：我們應該可以在由右到左走訪串列的過程中<em>記住目前為止的和</em>，避免重算 <code class="haskell">sum</code>。這該怎麼做呢？</p><p>回想： <code class="haskell">sum</code> 可寫成一個摺。因此我們可稍微推廣一下，定義函數 <code class="haskell">scanr</code> 如下：</p><pre><code class="spec">scanr :: (a -&gt; b -&gt; b) -&gt; b -&gt; List a -&gt; List b
scanr f e = map (foldr f e) . tails 
</code></pre><p>給定一個串列 <code class="haskell">xs</code>, <code class="haskell">scanr f e</code> 先算出 <code class="haskell">xs</code> 的所有後段，&shy;然後對每一個後段都做 <code class="haskell">foldr f e</code>. <span id="ix-6-12"></span>&shy;前述的 <code class="haskell">runsum</code> 其實是 <code class="haskell">scanr</code> 的特例：&shy;<code class="haskell">runsum = scanr (+) 0</code>.</p><p>如果把上述的 <code class="haskell">scanr</code> 定義當作演算法，處理長度為 <code class="haskell">n</code> 的串列時呼叫 <code class="haskell">f</code> 的次數為 $O(n^2)$.&shy;我們找找看是否有比較快的演算法。</p><p>第 <a href="Folds.html#sec:more-folds-on-lists">6.1.1 </a> 節中提及 <code class="haskell">tails</code> 是一個 <code class="haskell">foldr</code>:</p><pre><code class="spec">tails = foldr (\x xss -&gt; (x : head xss) : xss) [[]] 
</code></pre><p>也許我們可試著把 <code class="haskell">map (foldr f e)</code> 融合入 <code class="haskell">tails</code> 中，看看是否能找出一個較有效率的 <code class="haskell">scanr</code> 定義。&shy;其融合條件如下：</p><pre><code class="haskell">      map (foldr f e) ((x : head xss) : xss)
 ===    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
      foldr f e (x : head xss) : map (foldr f e) xss
 ===    <comment>{- <code class="haskell">foldr</code> 之定義 -}</comment>
      f x (foldr f e (head xss)) : map (foldr f e) xss
 ===    <comment>{- <code class="haskell">g (head ys) = head (map g ys)</code>; 令 <code class="haskell">g := foldr f e</code>, <code class="haskell">ys := xss</code> -}</comment>
      f x (head (map (foldr f e) xss)) : map (foldr f e) xss
 ===    <comment>{- 取出 <code class="haskell">map (foldr f e) xss</code> -}</comment>
      let ys = map (foldr f e) xss
      in f x (head ys) : ys 
</code></pre><p>於是我們推導出了 <code class="haskell">scanr</code> 的另一個定義：</p><div class="theorem" id="lma:scan-lemma" title="掃描引理"><h5 class="theorem-title">引理 6.11  掃描引理 </h5><p>對所有 <code class="haskell">f</code>, <code class="haskell">e</code>,</p><pre><code class="spec">scanr f e = foldr (\x ys -&gt; f x (head ys) : ys) [e] 
</code></pre></div><p>若將 <code class="haskell">foldr</code> 的定義展開，函數 <code class="haskell">scanr</code> 可寫成下列的歸納形式，也許比較容易理解：</p><pre><code class="spec">scanr f e []      = [e]
scanr f e (x:xs)  = f x (head ys) : ys 
    where ys = scanr f e xs 
</code></pre><p> 在第 <a href="Folds.html#sec:more-folds-on-lists">6.1.1 </a> 節中，使得 <code class="haskell">tails</code> 能寫成一個 <code class="haskell">foldr</code> 的重要性質是<code class="haskell">head (tails xs) = xs</code> -- <code class="haskell">tails xs</code> 的第一個元素就是 <code class="haskell">xs</code> 本身。使用 <code class="haskell">tails</code> 定義的 <code class="haskell">scanr</code> 自然繼承了相關的性質：<code class="haskell">scanr f e xs</code> 的第一個元素就是 <code class="haskell">foldr f e xs</code>, 因此可直接用 <code class="haskell">head</code> 取出，不需每次重新計算。&shy;用本節開頭的例子說明，以下我們令 <code class="haskell">scr = (\x ys -&gt; x + head ys : ys)</code>:</p><pre><code class="spec">     scanr (+) 0 [3,7,2,4]
===  scr 3 (scr 7 (scr 2 (scr 4 [0])))
===  scr 3 (scr 7 (scr 2 [4 + 0, 0]))
===  scr 3 (scr 7 [2 + 4 + 0, 4 + 0, 0])
===  scr 3 [7 + 2 + 4 + 0, 2 + 4 + 0, 4 + 0, 0]
===  [3 + 7 + 2 + 4 + 0, 7 + 2 + 4 + 0, 2 + 4 + 0, 4 + 0, 0]
===  [16,13,6,4,0] 
</code></pre><p>其中每個 <code class="haskell">scr</code> 都可直接使用之前累積計算的結果，不用從頭加起。</p><h3 class="subsection" id="sec:banana-split">6.2.4 香蕉船定理</h3><p>第<a href="Derivation.html#sec:tupling-conclude">5.5.4 </a>節簡短地提到一個例子：&shy;令 <code class="haskell">sumlen = fork sum length</code>,&shy;<input class="toggle" id="footnote-6-2-1" type="checkbox"/><label class="fnote-toggle" for="footnote-6-2-1">(註1) </label><span class="collapsible-footnote">分裂運算元 <code class="haskell">fork</code> 的定義請參照第<a href="Basics.html#sec:pairs">1.6.3 </a>節，頁。</span>&shy;直接執行的話，<code class="haskell">sum</code> 與 <code class="haskell">length</code> 將各自走訪輸入串列一次，&shy;但我們可推導出 <code class="haskell">sumlen</code> 的歸納定義，得到一個只走訪串列一次的版本。</p><p>上述例子還可以更通用一些。考慮 <code class="haskell">fork (foldr f1 e1) (foldr f2 e2)</code> --- 這個算式拿一個串列當輸入，兩個 <code class="haskell">foldr</code> 分別將串列走訪一次，兩個結果分別存放在序對中。我們有可能將它變成一個摺（因此只走訪串列一次）嗎？&shy;下述的「香蕉船定理(banana-split theorem)」告訴我們：<em>含兩個摺的分裂，可以寫成一個摺</em>。&shy;<span id="ix-6-13"></span></p><div class="theorem" id="thm:banana-split" title="香蕉船定理"><h5 class="theorem-title">定理 6.12  香蕉船定理 </h5><p>給定 <code class="haskell">f1 :: a -&gt; b -&gt; b</code>, <code class="haskell">e1 :: b</code> , <code class="haskell">f2 :: a -&gt; c -&gt; c</code>, <code class="haskell">e2 :: c</code>, 下述等式成立：</p><pre><code class="haskell"> fork (foldr f1 e1) (foldr f2 e2) === foldr g (e1,e2) 
</code></pre><p>其中 <code class="haskell">g x (y,z) = (f1 x y, f2 x z)</code>.</p></div><p>分裂運算元 <code class="haskell">fork</code> 的英文稱呼是 <code>split'', 在程式推導圈內有時會用一套稱作「香蕉括號(banana brackets)」的符號表示摺，兩者合起來便是</code>banana-split'' --- 甜點「香蕉船」的英文名稱。</p><p>定理<a href="Folds.html#thm:banana-split">6.12 </a>相當於把兩個處理同一份資料的迴圈合併成一個。&shy;但如同第<a href="Derivation.html#sec:tupling-conclude">5.5.4 </a>節提及，這並不保證效率會比較好。&shy;我們會使用定理<a href="Folds.html#thm:banana-split">6.12 </a>的原因可能是如果確定某函數是摺，&shy;我們能做更多後續處理（例如，使用掃描定理或其他只對摺成立的性質）。</p><div class="exlist"><div class="exercise exer" id="ex:banana-split"><h5 class="exercise-title">練習 6.11 </h5><p>證明香蕉船定理。&shy;你可以在輸入串列上做歸納證明，&shy;也可以利用&shy;<code class="haskell">fork (foldr f1 e1) (foldr f2 e2) = fork (foldr f1 e1) (foldr f2 e2) . id
= fork (foldr f1 e1) (foldr f2 e2) . foldr (:) []</code> 的特性，使用摺融合定理。</p></div></div><p>「組對」常可視為分裂與 <code class="haskell">id</code> 的融合。&shy;例如，在第<a href="Derivation.html#sec:steep">5.5.1 </a>節的陡串列問題中，我們定義&shy;<code class="haskell">steepsum xs = (steep xs, sum xs)</code>，並試著推導其歸納定義。&shy;該過程也可視為將 <code class="haskell">fork steep sum</code> 與 <code class="haskell">id</code> 融合：</p><pre><code class="haskell">     fork steep sum
 ===   <comment>{- <code class="haskell">f . id = f</code> -}</comment>
     fork steep sum . id
 ===   <comment>{- <code class="haskell">id = foldr (:) id</code> -}</comment>
     fork steep sum . foldr (:) []
 ===   <comment>{- 摺融合 -}</comment>
     foldr (\x (b, s) -&gt; (x &gt; s ⋀ b, x + s)) (True, 0) 
</code></pre><p>其融合條件的證明與第<a href="Derivation.html#sec:steep">5.5.1 </a>節中幾乎相同。</p><h3 class="subsection" id="sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</h3><p>第<a href="Derivation.html#sec:accumulating-param">5.6 </a>節介紹的「累積參數」技巧也常可視為高階函數與摺的融合。&shy;以第<a href="Derivation.html#sec:reversal-append">5.6.1 </a>節的經典例子 --- 串列反轉為例。&shy;函數 <code class="haskell">reverse :: List a -&gt; List a</code> 是一個 <code class="haskell">foldr</code>:</p><pre><code class="spec">reverse = foldr (\x xs -&gt; xs ++ [x]) [] 
</code></pre><p>為增進其效率，我們創造了函數 <code class="haskell">revcat</code>，其定義為：</p><pre><code class="spec">revcat :: List a -&gt; List a -&gt; List a
revcat xs ys = reverse xs ++ ys 
</code></pre><p>但如果把參數都移除，上述定義其實等同於：</p><pre><code class="spec">revcat = (++) . reverse 
</code></pre><p>推導 <code class="haskell">revcat</code> 的歸納定義就是計算 <code class="haskell">(++)</code> 與 <code class="haskell">reverse</code> 的融合！</p><p>為了導出一個較快的 <code class="haskell">revcat</code> 實作，我們嘗試把 <code class="haskell">(++) . reverse</code> 融合為一個 <code class="haskell">foldr</code>.&shy;其推導大綱如下：</p><pre><code class="haskell">      (++) . reverse
 ===  (++) . foldr (\x xs -&gt; xs ++ [x]) []
 ===    <comment>{- 摺融合，試著計算出 <code class="haskell">base</code> 與 <code class="haskell">step</code> -}</comment>
      foldr step base 
</code></pre><p>我們可暫停一下，看看這個式子的型別。&shy;函數 <code class="haskell">(++)</code> 的型別為 <code class="haskell">List a -&gt; (List a -&gt; List a)</code>, <code class="haskell">(++) . reverse</code> 與 <code class="haskell">foldr step base</code> 的型別也相同。&shy;如果摺融合成功，我們會得到的是一個<em>傳回函數的 <code class="haskell">foldr</code></em> --- 輸入為 <code class="haskell">List a</code>, 輸出為 <code class="haskell">List a -&gt; List a</code>.&shy;其中 <code class="haskell">base</code> 的型別為 <code class="haskell">List a -&gt; List a</code>, 而 <code class="haskell">step</code> 的型別將是 <code class="haskell">a -&gt; (List a -&gt; List a) -&gt; (List a -&gt; List a)</code> --- <code class="haskell">step x</code> 將一個函數轉成另一個函數。</p><p>根據摺融合定理，基底值 <code class="haskell">base</code> 是</p><pre><code class="spec">  (++) []  = (\xs -&gt; (++) [] xs)
           = (\xs -&gt; [] ++ xs)
           = (\xs -&gt; xs)
           = id 
</code></pre><p>步驟函數 <code class="haskell">step</code> 須滿足的融合條件如下</p><pre><code class="haskell">     (++) ((\x xs -&gt; xs ++ [x]) x xs) === step x ((++) xs) 
</code></pre><p>簡單地化簡等號左手邊，我們得到：</p><pre><code class="spec">     (++) (xs ++ [x]) === step x ((++) xs) 
</code></pre><p>這個式子無法再規約，因為 <code class="haskell">(++)</code> 還需要一個參數。&shy;因此我們根據外延相等（定義<a href="Basics.html#def:extensional-eq">1.8 </a>），在等號兩邊各補一個參數 <code class="haskell">ys</code>:</p><pre><code class="spec">     (++) (xs ++ [x]) ys === step x ((++) xs) ys
</code></pre><p>為找出 <code class="haskell">step</code>, 演算如下：</p><pre><code class="haskell">      (++) (xs ++ [x]) ys
 ===  (xs ++ [x]) ++ ys
 ===    <comment>{- <code class="haskell">(++)</code> 之結合律 -}</comment>
      xs ++ ([x] ++ ys)
 ===   <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
     (((++) xs) . (x:)) ys
 ===   <comment>{- 將 <code class="haskell">x</code>, <code class="haskell">((++) xs)</code>, 與 <code class="haskell">ys</code> 提出 -}</comment>
     (\x f -&gt; f . (x:)) x ((++) xs) ys 
</code></pre><p>根據外延相等，我們已證明</p><pre><code class="spec">  (++) (xs ++ [x]) = (\x f -&gt; f . (x:)) x ((++) xs) 
</code></pre><p>因此 <code class="haskell">step = (\x f -&gt; f . (x:))</code>, 而 <code class="haskell">revcat</code> 可寫成如下的摺：</p><pre><code class="haskell">revcat = foldr (\x f -&gt; f . (x:)) id 
</code></pre><p>例如 <code class="haskell">revcat "abc" = id . ('c':) . ('b':) . ('a':)</code>,&shy;而 <code class="haskell">revcat "abc" ys = 'c' : ('b' : ('a' : ys))</code>.</p><h3 class="subsection" id="sec:bring-in-context">6.2.6 引入脈絡</h3><p><span id="ix-6-14"></span></p><p>第<a href="Folds.html#sec:foldr-fusion">6.2 </a>節開頭（第頁）曾提及：&shy;使用摺融合定理將 <code class="haskell">h . foldr f e</code> 融合成 <code class="haskell">foldr g (h e)</code> 時，融合條件 <code class="haskell">h (f x y) = g x (h y)</code> 並不需對所有 <code class="haskell">y</code> 都成立，而只需對在 <code class="haskell">foldr f e</code> 的值域內的 <code class="haskell">y</code> 成立即可。&shy;截至目前為止我們看了不少摺融合的例子，但我們所證明的融合條件，均是較寬鬆、對所有 <code class="haskell">y</code> 都成立的。&shy;我們還沒看過只對特定 <code class="haskell">y</code> 成立（因此可能較難證明的）融合條件。</p><p>知道「<code class="haskell">y</code> 在 <code class="haskell">foldr f e</code> 的值域內」，意味著證明融合條件時，我們可以假設 <code class="haskell">y</code> 滿足所有 <code class="haskell">foldr f e</code> 的傳回值該滿足的性質。習慣上，「使用這些性質」被稱作「<em>引入脈絡</em>」(<em>bringing in the context</em>) --- 意指做證明時知道 <code class="haskell">y</code> 不是任意的值，而是由 <code class="haskell">foldr f e</code> 產生（有特定脈絡）的。此處我們看一個引入脈絡的簡單例子。</p><div class="theorem" id="ex:suc-map-square"><h5 class="theorem-title">例 6.13  </h5><p>回顧 <code class="haskell">sumsq = sum . map square</code>.&shy;我們在例<a href="Folds.html#ex:sum-map-square-fusion">6.8 </a>中曾導出 <code class="haskell">sumsq = foldr (\x y -&gt; square x + y) 0</code>.&shy;現在考慮下述函數：</p><pre><code class="spec">psuc n = if n &gt;= 0 then n+1 else 0 
</code></pre><p>如果參數是非負整數，<code class="haskell">psuc</code> 將它加一，否則傳回 <code class="haskell">0</code>.&shy;我們能將 <code class="haskell">psuc . sumsq</code> 融合為一個 <code class="haskell">foldr</code> 嗎？</p><p>直覺看來，由於 <code class="haskell">sumsq</code> 一定傳回非負整數，<code class="haskell">psuc</code> 只是將其結果加一。&shy;但如果使用摺融合，需要的融合條件是 <code class="haskell">psuc (square x + y) = step x (psuc y)</code>.&shy;我們找不到一個對任意 <code class="haskell">x</code> 與 <code class="haskell">y</code> 都能使該條件成立的 <code class="haskell">step</code>.</p><p>此時我們需要引入脈絡：由於 <code class="haskell">y</code> 是 <code class="haskell">sumsq</code> 的結果，必定是個非負整數。&shy;我們可證明對於非負整數 <code class="haskell">m</code> 與 <code class="haskell">n</code>,</p><pre><code class="spec">     psuc (m + n) = m + psuc n 
</code></pre><p>由於 <code class="haskell">square x</code> 與 <code class="haskell">y</code> 都是非負整數，我們有</p><pre><code class="spec">     psuc (square x + y) = square x + psuc y 
</code></pre><p>因此我們可選 <code class="haskell">step x y = square x + y</code> --- 與 <code class="haskell">sumsq</code> 的步驟函數相同。&shy;至於基底值則是 <code class="haskell">psuc 0 = 1</code>.&shy;因此，</p><pre><code class="spec">  psuc . sumsq = foldr (\x y -&gt; square x + y) 1 
</code></pre></div><p>例<a href="Folds.html#ex:suc-map-square">6.13 </a>是個刻意設計的、簡單的例子。在第TODO節中，我們會看到其他需要引入脈絡的演算法。</p><h2 class="section" id="sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</h2><p>為了完整性，本節介紹與串列的摺相關的另外幾個組件函數。&shy;初次閱讀時可跳過本節。</p><h3 class="subsection" id="sec:foldl">6.3.1 左摺</h3><p>除了 <code class="haskell">foldr</code>, Haskell 的標準函式庫有另一個函數 <code class="haskell">foldl</code>, 名字中的字母 <code class="haskell">l</code> 為「左」之意：&shy;<code class="haskell">foldr</code> 將串列中的元素往右括，<code class="haskell">foldl</code> 則往左括，例如，</p><pre><code class="spec"> foldl rhd e [x0,x1,x2,x3] = (((e `rhd` x0) `rhd` x1) `rhd` x2) `rhd` x3 
</code></pre><p>有了 <code class="haskell">foldl</code>, 串列反轉可直接定義為 <code class="haskell">reverse = foldl (\xs x -&gt; x:xs) []</code>.</p><p>函數 <code class="haskell">foldl</code> 可在輸入串列的長度上歸納定義如下：</p><pre><code class="spec">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; List a -&gt; b
foldl rhd e []         = e
foldl rhd e (xs++[z])  = foldl rhd e xs `rhd` z
</code></pre><p>由於運算元 <code class="haskell">rhd</code> 右邊的參數才是目前的元素，其型別為 <code class="haskell">b -&gt; a -&gt; b</code>.&shy;由此出發，我們不難導出下述將串列從左邊開始拆解的定義：</p><pre><code class="spec">foldl rhd e []      = e
foldl rhd e (x:xs)  = foldl rhd (e `rhd` x) xs 
</code></pre><p>我們可注意到這是一個尾遞迴定義，<span id="ix-6-15"></span>&shy;因此，如果將 <code class="haskell">sum</code>, <code class="haskell">prod</code> 等函數定義為 <code class="haskell">foldl (+) 0</code>, <code class="haskell">foldl (*) 1</code> 等等，執行時可不佔用堆疊的空間。&shy;由於這個特性，對一些將 Haskell 用於著重效率的應用的人們來說，<code class="haskell">foldl</code> 才是他們較常使用的「摺」。&shy;<input class="toggle" id="footnote-6-3-2" type="checkbox"/><label class="fnote-toggle" for="footnote-6-3-2">(註2) </label><span class="collapsible-footnote">為了效率因素更常被使用的可能是另一個嚴格(strict)版的函數 <code class="haskell">foldl'</code>, 該函數在遞迴呼叫前會先將 <code class="haskell">e `rhd` x</code> 規約成正規式，避免尚待計算的算式被累積著。</span></p><p>關於 <code class="haskell">foldl</code> 與 <code class="haskell">foldr</code> 的關係，<a href="Biblio.html#Bird:98:Introduction">Bird [1998]</a> 提及了三個定理。首先，</p><div class="theorem" id="thm:first-duality" title="第一對偶定理(The First Duality Theorem)"><h5 class="theorem-title">定理 6.14  第一對偶定理(The First Duality Theorem) </h5><p>如果 <code class="haskell">oplus :: a -&gt; a -&gt; a</code> 滿足遞移律，以 <code class="haskell">e :: a</code> 為單位元素，則 <code class="haskell">foldr oplus e xs = foldl oplus e xs</code>.</p></div><p>提醒一下：該定理及本節的其他定理中，<code class="haskell">xs</code> 需為歸納定義、有限長度的串列。&shy;遞移律意指 <code class="haskell">x ⊕ (y ⊕ z) = (x ⊕ y) ⊕ z</code> --- 由於此項要求，<code class="haskell">oplus</code> 的型別得是 <code class="haskell">a -&gt; a -&gt; a</code>. 由於 <code class="haskell">(+)</code>, <code class="haskell">(*)</code>, <code class="haskell">(↓)</code>, <code class="haskell">(↑)</code> 等運算元都有遞移律，<code class="haskell">sum</code>, <code class="haskell">prod</code>, <code class="haskell">maixmum</code>, <code class="haskell">minimum</code> 等函數都可用 <code class="haskell">foldl</code> 定義。事實上，他們在標準 Haskell Report 中的定義便是如此。</p><p>定理<a href="Folds.html#thm:first-duality">6.14 </a>其實是下述定理的特例。&shy;函數 <code class="haskell">foldl</code> 有個尾遞迴定義，其中參數 <code class="haskell">e</code> 的角色就像是個累積參數。&shy;第<a href="Derivation.html#sec:tail-recursion">5.6.3 </a>節中曾提及，尾遞迴函數時常和遞移律有關。&shy;函數 <code class="haskell">foldl</code> 是否也牽涉了某種遞移律呢？</p><div class="theorem" id="thm:second-duality" title="第二對偶定理(The Second Duality Theorem)"><h5 class="theorem-title">定理 6.15  第二對偶定理(The Second Duality Theorem) </h5><p>如果二元運算元 <code class="haskell">lhd :: a -&gt; b -&gt; b</code> 及 <code class="haskell">rhd :: b -&gt; a -&gt; b</code> 滿足 <code class="haskell">x `lhd` (y `rhd` z) = (x `lhd` y) `rhd` z</code> 以及 <code class="haskell">x `lhd` e = e `rhd` x</code>，&shy;則 <code class="haskell">foldr lhd e xs = foldl rhd e xs</code>.</p></div><p>定理 <a href="Folds.html#thm:second-duality">6.15 </a> 中的 <code class="haskell">x `lhd` (y `rhd` z) = (x `lhd` y) `rhd` z</code> 可視為一種擴充到兩個運算元的遞移律。定理 <a href="Folds.html#thm:first-duality">6.14 </a> 則是 <code class="haskell">lhd = rhd</code> 的特殊情況。</p><p>定理 <a href="Folds.html#thm:second-duality">6.15 </a> 的證明頗值得研究：</p><div class="proof"><b>證明 </b><p>我們在 <code class="haskell">xs</code> 上做歸納。基底狀況 <code class="haskell">xs := []</code> 中，等號兩邊都歸約為 <code class="haskell">e</code>.&shy;至於 <code class="haskell">xs := x : xs</code> 的情況，我們把兩邊都化簡並使用歸納假設，推論如下：</p><pre><code class="haskell">      foldr lhd e (x:xs)
 ===    <comment>{- <code class="haskell">foldr</code> 之定義 -}</comment>
      x `lhd` foldr lhd e xs
 ===    <comment>{- 歸納假設 -}</comment>
      x `lhd` foldl rhd e xs
 ===    <comment>{- 論證如後述 -}</comment>
      foldl rhd (x `lhd` e) xs
 ===    <comment>{- 假設： <code class="haskell">x `lhd` e = e `rhd` x</code> -}</comment>
      foldl rhd (e `rhd` x) xs
 ===    <comment>{- <code class="haskell">foldl</code> 之定義 -}</comment>
      foldl rhd e (x:xs) 
</code></pre><p>在等式推論中段，我們希望 <code class="haskell">x `lhd` foldl rhd e xs = foldl rhd (e `rhd` x) xs</code>.&shy;這會需要另一個歸納證明。&shy;但我們若直接證明此等式，到中途便會無法進行，且會發現我們需要稍做一下推廣，改證明一個較強的性質：</p><pre><code class="equation" id="eq:sndDualityGen">  |x `lhd` foldl rhd y xs = foldl rhd (x `lhd` y) xs |</code>    (6.1 )
</pre><p>兩者的差別是後者不針對特定的值 <code class="haskell">e</code>, 而是任何的 <code class="haskell">y</code>.&shy;這是一個「較強的性質反而比較好證明」的例子。</p><p>等式([RefUndefined])的證明如此進行：在 <code class="haskell">xs := []</code> 的情況中，等號兩側都規約為 <code class="haskell">x `lhd` y</code>.&shy;歸納情況 <code class="haskell">xs := z : xs</code> 證明如下：</p><pre><code class="haskell">      x `lhd` foldl rhd y (z:xs)
 ===    <comment>{- <code class="haskell">foldl</code> 之定義 -}</comment>
      x `lhd` foldl rhd (y `rhd` z) xs
 ===    <comment>{- 歸納假設 -}</comment>
      foldl rhd (x `lhd` (y `rhd` z)) xs
 ===    <comment>{- 假設：<code class="haskell">x `lhd` (y `rhd` z) = (x `lhd` y) `rhd` z</code> -}</comment>
      foldl rhd ((x `lhd` y) `rhd` z) xs
 ===    <comment>{- <code class="haskell">foldl</code> 之定義 -}</comment>
      foldl rhd (x `lhd` y) (z:xs) 
</code></pre></div><p>最後一個對偶定理則確認了我們的一個直覺理解：將一個串列反轉做 <code class="haskell">foldl</code>, 便相當於 <code class="haskell">foldr</code>:</p><div class="theorem" id="thm:third-duality" title="第三對偶定理(The Third Duality Theorem)"><h5 class="theorem-title">定理 6.16  第三對偶定理(The Third Duality Theorem) </h5><p>對所有 <code class="haskell">f :: a -&gt; b -&gt; b</code>, <code class="haskell">e :: b</code>, 以及 <code class="haskell">xs :: List a</code>,&shy;<code class="haskell">foldr f e xs = foldl (flip f) e (reverse xs)</code>.&shy;其中 <code class="haskell">flip f x y = f y x</code>.</p></div><h3 class="subsection" id="sec:list-homomorphism">6.3.2 串列同構</h3><p>考慮函數 <code class="haskell">h :: List a -&gt; b</code>. 如果存在 <code class="haskell">e :: b</code>, <code class="haskell">f :: a -&gt; b</code>, 和 <code class="haskell">odot :: b -&gt; b -&gt; b</code> 使得 <code class="haskell">h</code> 滿足下列等式：</p><pre><code class="spec">h []          = e
h [x]         = f x
h (xs ++ ys)  = h xs ⊙ h ys 
</code></pre><p>我們便說 <code class="haskell">h</code> 是一個<em>串列同構</em>(<em>list homomorphism</em>), 記為 <code class="haskell">h = hom odot f e</code>.&shy;<span id="ix-6-16"></span>&shy;注意第三個等式蘊含 <code class="haskell">odot</code>（至少在 <code class="haskell">h</code> 的值域內）須滿足結合律：&shy;<code class="haskell">h xs ⊙ (h ys ⊙ h zs) = h (xs++(ys++zs)) = h ((xs++ys)++zs) = (h xs ⊙ h ys) ⊙ h zs</code>.</p><p>串列同構有平行計算的可能性：計算 <code class="haskell">hom odot f e xs</code> 時，如果 <code class="haskell">xs</code> 有不只一個元素，我們可將 <code class="haskell">xs</code> 由中間任意截成兩段，分別給不同的處理器計算，再將結果用 <code class="haskell">odot</code> 結合。</p><p>顯然，<code class="haskell">hom dot f e</code> 可以寫成 <code class="haskell">foldr</code>, 也能寫成 <code class="haskell">foldl</code>:</p><pre><code class="haskell">  hom odot f e  === foldr (\x y -&gt; f x ⊙ y) e
                === foldl (\y x -&gt; y ⊙ f x) e 
</code></pre><p>下述定理則告訴我們反過來也成立：如果 <code class="haskell">h</code> 同時可寫成 <code class="haskell">foldr</code> 及 <code class="haskell">foldl</code>, 則 <code class="haskell">h</code> 是一個串列同構：</p><div class="theorem" id="thm:third-homo-thm" title="第三同構定理(The Third Homomorphism Theorem)"><h5 class="theorem-title">定理 6.17  第三同構定理(The Third Homomorphism Theorem) </h5><p>考慮 <code class="haskell">h :: List a -&gt; b</code>。如果存在 <code class="haskell">e :: b</code>, <code class="haskell">lhd :: a -&gt; b -&gt; b</code>, 及 <code class="haskell">rhd :: b -&gt; a -&gt; b</code> 使得 <code class="haskell">h = foldr lhd e = foldl rhd e</code>,&shy;則存在 <code class="haskell">odot :: b -&gt; b -&gt; b</code> 使得 <code class="haskell">h = hom odot f e</code> （其中 <code class="haskell">f x = x `lhd` e = e `rhd` x</code>）.</p></div><h3 class="subsection" id="sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</h3><p>如果我們把 <code class="haskell">foldr</code> 的限制放寬，允許 <code class="haskell">xs</code> 出現在遞迴呼叫之外，得到的模式稱為 <em>paramorphism</em>.&shy;串列版的 paramorphism 可定義如下：</p><pre><code class="haskell">para :: (a -&gt; List a -&gt; b -&gt; b) -&gt; b -&gt; List a -&gt; b
para f e []      = e
para f e (x:xs)  = f x xs (para f e xs) 
</code></pre><pre><code class="spec">para f e = fst . foldr (\x (y, xs) -&gt; (f x xs y, x:xs)) (e, []) 
</code></pre><h2 class="section" id="sec:foldN">6.4 自然數的摺</h2><p>自然數可以視為有兩個建構元 <code class="haskell">Zero</code> 和 <code class="haskell">Suc</code> 的歸納資料結構。&shy;我們也可為自然數定義一個摺：</p><pre><code class="haskell">foldN :: (a -&gt; a) -&gt; a -&gt; Nat -&gt; a
foldN f e Zero     = e
foldN f e (Suc n)  = f (foldN f e n) 
</code></pre><p>和串列的情況類似，函數 <code class="haskell">foldN f e</code> 拿一個自然數，將其中的 <code class="haskell">Zero</code> 代換成 <code class="haskell">e</code>, <code class="haskell">Suc</code> 代換成 <code class="haskell">f</code>.&shy;留意型別：<code class="haskell">Zero</code> 與 <code class="haskell">Suc</code> 的型別分別是 <code class="haskell">Nat</code> 與 <code class="haskell">Nat -&gt; Nat</code>,&shy;<code class="haskell">foldN</code> 要將一個型別為 <code class="haskell">Nat</code> 的值轉變為型別為 <code class="haskell">a</code> 的值,&shy;因此 <code class="haskell">e</code> 的型別為 <code class="haskell">a</code>, 而 <code class="haskell">f</code> 的型別為 <code class="haskell">a -&gt; a</code>.&shy;為方便稱呼，我們也將 <code class="haskell">e</code> 與 <code class="haskell">f</code> 分別稱為基底值與步驟函數。</p><p>許多我們定義過的、自然數上的函數都可寫成自然數的摺：</p><ul><li><p><code class="haskell">exp b = foldN (b*) 1</code>,</p></li><li><p><code class="haskell">(+n) = foldN (Suc) n</code>,</p></li><li><p><code class="haskell">(*n) = foldN (n+) 0</code>.</p></li></ul><p>自然數上的 <code class="haskell">id :: Nat -&gt; Nat</code> 也可寫成摺：<code class="haskell">id = foldN (Suc) 0</code>.</p><p>自然數的摺也有一個融合定理：</p><div class="theorem" id="thm:foldN-fusion" title="摺融合定理(自然數版)"><h5 class="theorem-title">定理 6.18  摺融合定理(自然數版) </h5><p><span id="ix-6-17"></span>&shy;給定 <code class="haskell">f :: a -&gt; a</code>, <code class="haskell">e :: a</code>, <code class="haskell">h :: a -&gt; b</code>.&shy;如果對所有在 <code class="haskell">foldN f e</code> 值域中的 <code class="haskell">x :: a</code>, 融合條件&shy;<code class="haskell">h (f x) = g (h x)</code> 成立, 則</p><pre><code class="spec">h . foldN f e = foldN g (h e) 
</code></pre></div><div class="theorem" id="eg:foldN-even"><h5 class="theorem-title">例 6.19  </h5><p>判斷一個自然數是否為偶數的述語 <code class="haskell">even :: Nat -&gt; Bool</code> 可寫成一個摺:</p><pre><code class="spec">  even = foldN not True 
</code></pre><p>函數 <code class="haskell">even . (+n)</code> 判斷一個數值加上 <code class="haskell">n</code> 之後是否為偶數。&shy;由於 <code class="haskell">(+ n) = foldN (Suc) n</code>, 我們可以嘗試把 <code class="haskell">even</code> 融入 <code class="haskell">(+n)</code>, 變成一個摺。&shy;根據定理<a href="Folds.html#thm:foldN-fusion">6.18 </a>, 基底值為 <code class="haskell">even n</code>;&shy;而由於 <code class="haskell">even (Suc n) = not (even n)</code>, 步驟函數為 <code class="haskell">not</code>.&shy;因此：</p><pre><code class="spec">even . (+n) = foldN not (even n) 
</code></pre></div><div class="exlist"><div class="exercise exer" id="ex:foldN-fib"><h5 class="exercise-title">練習 6.12 </h5><p>回顧第<a href="Induction.html#sec:complete-induction">2.11 </a>節中提到的費氏數定義：</p><pre><code class="spec">fib 0      = 0
fib 1      = 1
fib (2+n)  = fib (1+n) + fib n 
</code></pre><p>若直接將上述定義當作演算法，我們得做許多重複的計算。&shy;定義 <code class="haskell">fib2 n = (fib (1+n), fib n)</code>.&shy;請將 <code class="haskell">fib2</code> 融合進 <code class="haskell">id :: Nat -&gt; Nat</code>, 以便得到一個遞迴呼叫次數為 $O(n)$ 的演算法。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-12" type="checkbox"/><label class="lbl-toggle" for="ans-6-12">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>回顧 <code class="haskell">id = foldN (Suc) 0</code>.&shy;欲將 <code class="haskell">fib2</code> 融入 <code class="haskell">id</code>, 基底值為 <code class="haskell">fib2 0 = (fib 1, fib 0) = (1,0)</code>.&shy;為得到步驟函數，我們演算如下：</p><pre><code class="spec">   fib2 (Suc n)
=  (fib (Suc (Suc n)), fib (Suc n))
=    <comment>{- <code class="haskell">fib</code> 之定義 -}</comment>
   (fib (Suc n) + fib n, fib (Suc n))
=  (\(x,y) -&gt; (x+y,x)) (fib2 n) 
</code></pre><p>因此我們得到</p><pre><code class="spec">fib2 = foldN (\(x,y) -&gt; (x+y,x)) (1,0) 
</code></pre></div></div></div><h2 class="section" id="sec:fold-on-other-data-structures">6.5 其他資料結構</h2><p>既然串列與自然數都有摺，其他的資料結構也可以有。</p><p><b>二元樹</b> &emsp; 回顧我們提及的兩種常見二元樹：</p><pre><code class="spec">data ITree a  = Null   | Node a (ITree a) (ITree a) 
data ETree a  = Tip a  | Bin (ETree a) (ETree a) 
</code></pre><p>其中 <code class="haskell">ITree</code> 的摺可定義如下：</p><pre><code class="haskell">foldIT :: (a -&gt; b -&gt; b -&gt; b) -&gt; b -&gt; ITree a -&gt; b
foldIT f e Null          = e
foldIT f e (Node x t u)  = f x (foldIT f e t) (foldIT f e u) 
</code></pre><p>內標記二元樹 <code class="haskell">ITree</code> 的兩個建構元之型別分別為 <code class="haskell">Null :: ITree a</code> 與 <code class="haskell">Node :: a -&gt; ITree a -&gt; ITree a -&gt; ITree a</code>. 和串列的摺一樣，內標記二元樹的摺將一個 <code class="haskell">ITree a</code> 轉成一個型別為 <code class="haskell">b</code> 的值 --- 藉由將 <code class="haskell">Null</code> 代換為基底值 <code class="haskell">e :: b</code>, 以及將 <code class="haskell">Node</code> 代換為步驟函數 <code class="haskell">f :: a -&gt; b -&gt; b -&gt; b</code>.</p><p>外標記二元樹的摺則可定義如下：</p><pre><code class="haskell">foldET :: (b -&gt; b -&gt; b) -&gt; (a -&gt; b) -&gt; ETree a -&gt; b
foldET f k (Tip x)    = k x
foldET f k (Bin t u)  = f (foldET f k t) (foldET f k u) 
</code></pre><p>型別 <code class="haskell">ETree</code> 的建構元分別為 <code class="haskell">Tip :: a -&gt; ETree a</code> 和 <code class="haskell">Bin :: ETree a -&gt; ETree a -&gt; ETree a</code>.&shy;由於 <code class="haskell">Tip</code> 是一個由 <code class="haskell">a</code> 到 <code class="haskell">ETree a</code> 的函數，取代它的得是一個型別為 <code class="haskell">a -&gt; b</code> 的<em>基底函數</em>.&shy;取代 <code class="haskell">Bin</code> 的步驟函數之型別則為 <code class="haskell">b -&gt; b -&gt; b</code>. 有了這兩者，我們便可將 <code class="haskell">ETree a</code> 轉換為 <code class="haskell">b</code>.</p><p>例如，第<a href="Induction.html#sec:other-inductive-datatypes">2.8 </a>節中曾提到幾個定義在樹之上的函數：<code class="haskell">tags</code> 傳回一個 <code class="haskell">ITree</code> 的所有標記；<code class="haskell">size</code> 傳回其大小；<code class="haskell">minE</code> 傳回一個 <code class="haskell">ETree</code> 的最小元素，<code class="haskell">mapE f</code> 對樹中的每個標記做 <code class="haskell">f</code>. 它們都可用摺定義：</p><pre><code class="spec">tags    = foldIT (\x xs ys -&gt; xs ++ [x] ++ ys) [] 
size    = foldIT (\x m n -&gt; 1 + m + n) 0 
minE    = foldET min id 
mapE f  = foldET Bin f 
</code></pre><p>兩個二元樹的摺也有它們的融合定理：</p><div class="theorem" id="thm:fold-fusion-ITree" title="摺融合定理(|ITree|版)"><h5 class="theorem-title">定理 6.20  摺融合定理(|ITree|版) </h5><p><span id="ix-6-18"></span>&shy;給定 <code class="haskell">f :: a -&gt; b -&gt; b -&gt; b</code>, <code class="haskell">e :: b</code>, <code class="haskell">h :: b -&gt; c</code>, 與 <code class="haskell">g :: a -&gt; c -&gt; c -&gt; c</code>.&shy;如果融合條件 <code class="haskell">h (f x y z) = g x (h y) (h z)</code> 對任何 <code class="haskell">x :: a</code> 與在 <code class="haskell">foldIT f e</code> 值域中的 <code class="haskell">y, z :: b</code> 成立，&shy;我們有 <code class="haskell">h . foldIT f e = foldIT g (h e)</code>.</p></div><div class="theorem" id="thm:fold-fusion-ETree" title="摺融合定理(|ETree|版)"><h5 class="theorem-title">定理 6.21  摺融合定理(|ETree|版) </h5><p>給定 <code class="haskell">f :: b -&gt; b -&gt; b</code>, <code class="haskell">k :: a -&gt; b</code>, <code class="haskell">h :: b -&gt; c</code>, 與 <code class="haskell">g :: c -&gt; c -&gt; c</code>.&shy;如果融合條件 <code class="haskell">h (f x y) = g (h x) (h y)</code> 對任何在 <code class="haskell">foldET f k</code> 值域中的 <code class="haskell">x, y :: b</code> 成立，我們有&shy;<code class="haskell">h . foldET f k = foldET g (h . k)</code>.</p></div><p>兩個定理的融合條件都依循著與串列版相同的原則：當 <code class="haskell">h</code> 與步驟函數碰在一起，融合條件讓我們將 <code class="haskell">h</code> 往裡推。&shy;兩個定理都可用單純的歸納法證明。</p><div class="exlist"><div class="exercise exer" id="ex:fold-length-tags-size"><h5 class="exercise-title">練習 6.13 </h5><p>以摺融合定理證明 <code class="haskell">length (tags t) = size t</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-13" type="checkbox"/><label class="lbl-toggle" for="ans-6-13">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>即證明 <code class="haskell">length . tags = size</code>.&shy;回顧 <code class="haskell">tags = foldIT (\x xs ys -&gt; xs ++ [x] ++ ys) []</code>&shy;使用摺融合，由於 <code class="haskell">length [] = 0</code> 以及&shy;<code class="haskell">length (xs ++ [x] ++ ys) = 1 + length xs + length ys</code>,&shy;我們得到 <code class="haskell">length . tags = foldIT (\x m n -&gt; 1 + m + n) 0 = size</code>.</p></div></div><div class="exercise exer" id="ex:foldET-mapE-fusion"><h5 class="exercise-title">練習 6.14 </h5><p>串列有 <code class="haskell">foldr</code>-<code class="haskell">map</code> 融合定理(<a href="Folds.html#thm:foldr-map-fusion">6.4 </a>)，<code class="haskell">ETree</code> 也有類似的 <code class="haskell">foldET</code>-<code class="haskell">mapE</code> 融合定理。請寫出該定理並證明之。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-14" type="checkbox"/><label class="lbl-toggle" for="ans-6-14">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p><code class="haskell">ETree</code> 上的 <code class="haskell">foldET</code>-<code class="haskell">mapE</code> 融合定理為：</p><pre><code class="spec">  foldET f k . mapE g = foldET f (k . g) 
</code></pre><p>由於 <code class="haskell">mapE g = foldET Bin f</code>, 欲證明上式可用摺融合定理。&shy;其融合條件 <code class="haskell">foldET f k (Bin t u) = f (foldET f k t) (foldET f k u)</code> 恰巧是 <code class="haskell">foldET</code> 之定義。</p></div></div><div class="exercise exer" id="ex:foldIT-mapI-fusion"><h5 class="exercise-title">練習 6.15 </h5><p>函數 <code class="haskell">mapI :: (a -&gt; b) -&gt; ITree a -&gt; ITree b</code> 將一個 <code class="haskell">a -&gt; b</code> 的函數作用在 <code class="haskell">ITree</code> 的每一個標記上。&shy;請用 <code class="haskell">foldIT</code> 定義 <code class="haskell">mapI</code>, 並寫下 <code class="haskell">foldIT</code> 與 <code class="haskell">mapI</code> 的融合定理並證明之。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-15" type="checkbox"/><label class="lbl-toggle" for="ans-6-15">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>函數 <code class="haskell">mapI</code> 可定義如下：</p><pre><code class="spec">  mapI f = foldIT (\x t u -&gt; Node (f x) t u) Null 
</code></pre><p>考慮 <code class="haskell">foldIT f e . mapI g</code> 之融合。其基底值為 <code class="haskell">foldIT f e Null = e</code>.&shy;步驟函數的推導如下：</p><pre><code class="spec">      foldIT f e (Node (g x) t u)
 ===    <comment>{- <code class="haskell">foldIT</code> 之定義 -}</comment>
      f (g x) (foldIT f e t) (foldIT f e u)  
</code></pre><p>因此 <code class="haskell">foldIT f e . mapI g = foldIT (\x y z -&gt; f (g x) y z) e</code>.</p></div></div><div class="exercise exer" id="ex:fold-fusion-minE-mapE"><h5 class="exercise-title">練習 6.16 </h5><p>以摺融合定理證明 <code class="haskell">minE (mapE (x +) t) = x + minE t</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-16" type="checkbox"/><label class="lbl-toggle" for="ans-6-16">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>即證明 <code class="haskell">minE . mapE (x+) = (x+) . minE</code>.&shy;推論如下：</p><pre><code class="spec">      minE . mapE (x+)
 ===    <comment>{- <code class="haskell">foldET</code>-<code class="haskell">mapE</code> 融合，見習題 \ref{ex:foldET-mapE-fusion} -}</comment>
      foldET min (id . (x+))
 ===    <comment>{- <code class="haskell">foldET</code> 融合，如下述 -}</comment>
      (x+) . minE 
</code></pre><p>融合的基底函數為 <code class="haskell">id . (x+) = (x+) . id</code>,&shy;融合條件則為 <code class="haskell">x + (y ↓ z) = (x + y) ↓ (x + z)</code>。</p></div></div><div class="exercise exer" id="ex:fold-ITree-append-tags"><h5 class="exercise-title">練習 6.17 </h5><p>將 <code class="haskell">(++) . tags</code> 融合，以便推導出一個在線性時間內收集 <code class="haskell">ITree</code> 內所有標籤的演算法。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-17" type="checkbox"/><label class="lbl-toggle" for="ans-6-17">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>回想 <code class="haskell">tags = foldIT (\x xs ys -&gt; xs ++ [x] ++ ys) []</code>.&shy;融合後之基底值為 <code class="haskell">(++) [] = id</code>.&shy;融合後之步驟函數 <code class="haskell">step</code> 須滿足&shy;<code class="haskell">(++) (xs ++ [x] ++ ys) = step x (xs++) (ys++)</code>.&shy;但由於左手邊的 <code class="haskell">(++)</code> 還需一個參數才能化簡，我們在左右兩邊各補上一個參數 <code class="haskell">zs</code>.&shy;演算如下：</p><pre><code class="spec">      (++) (xs ++ [x] ++ ys) zs
 ===  (xs ++ [x] ++ ys) ++ zs
 ===    <comment>{- <code class="haskell">(++)</code> 之遞移律 -}</comment>
      xs ++ (x : (ys ++ zs))
 ===    <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
      ((xs++) . (x:) . (ys++)) zs 
</code></pre><p>因此我們得到 <code class="haskell">(++) . tags = foldIT (\x f g -&gt; f . (x:) . g) id</code>.</p></div></div></div><p><b>非空串列</b> &emsp;&shy;第<a href="Induction.html#sec:induction-variations">2.10 </a>節中曾提及我們可把至少有一個元素的串列想像成一個資料結構：<code class="haskell">data ListP a = [a] | a : ListP a</code>. 此種串列的摺可定義為：</p><pre><code class="haskell">foldrn :: (a -&gt; b -&gt; b) -&gt; (a -&gt; b) -&gt; ListP a -&gt; b
foldrn f k [x]     = k x
foldrn f k (x:xs)  = f x (foldrn f k xs) 
</code></pre><div class="theorem" id="eg:foldrn-partsP"><h5 class="theorem-title">例 6.22  </h5><p>例<a href="Induction.html#ex:partsP">2.13 </a>中的 <code class="haskell">partsP</code> 可以寫成</p><pre><code class="haskell">partsP :: ListP a -&gt; List (ListP (ListP a))
partsP = foldrn (\x -&gt; concat . map (extend x)) wrap3 
  where  extend x (ys:yss) = [[x]:ys:yss, (x:ys):yss]
         wrap3 x = [[[x]]] 
</code></pre></div><p>我們考慮一個定義在非空串列上的簡單演算法推導練習。&shy;其次，這也將是一個使用 <code class="haskell">foldrn</code> 與「引入脈絡」的例子，&shy;<span id="ix-6-19"></span></p><p>下述函數 <code class="haskell">ascending :: ListP Int -&gt; Bool</code> 判斷一個串列是否為遞增：</p><pre><code class="haskell">ascending [x]       = True
ascending (x:y:xs)  = x &lt;= y ⋀ ascending (y:xs) 
</code></pre><p>給定一個整數串列，如何將它切成一個個區段，使得每個區段都是遞增的？&shy;如果我們讓每個元素都自己成一段，似乎是滿足需求，但這沒什麼意思。&shy;我們希望讓遞增區段盡量連續，也就是說，我們要區段數目最少的分割法。&shy;下述函數 <code class="haskell">upHills</code> 將輸入串列以最精簡的方式切成段：</p><pre><code class="spec">upHills :: List Int -&gt; List (List Int)
upHills = shortest . filter (all ascending) . partsP 
</code></pre><p>其中 <code class="haskell">partsP</code> 把串列任意切段，<code class="haskell">filter (all ascending)</code> 挑出每個區段都是遞增的分割法，而 <code class="haskell">shortest</code> 挑選元素數目最少的串列。&shy;我們能由此導出一個比較快的演算法嗎？</p><p>我們先將 <code class="haskell">filter (all ascending)</code> 融入 <code class="haskell">partsP</code> 之中。&shy;經過一些稍繁瑣但原則上並不困難的計算，我們可得：</p><pre><code class="haskell"> filter (all ascending) . partsP ===
    foldrn (\x -&gt; concat . map (extendAsc x)) wrap3 
</code></pre><p>這和 <code class="haskell">partsP</code> 的差別只在 <code class="haskell">extend</code> 變成了 <code class="haskell">extendAsc</code>. 後者的定義為：</p><pre><code class="haskell">extendAsc x (ys:yss) = if x &gt;= head ys  then [[x]:ys:yss, (x:ys):yss]
                                        else [[x]:ys:yss] 
</code></pre><p>函數 <code class="haskell">extendAsc</code> 比 <code class="haskell">extend</code> 多做了一個檢查，只在 <code class="haskell">x &gt;= head ys</code> 時將 <code class="haskell">(x:ys):yss</code> 列為一個可能選項。&shy;注意：由於 <code class="haskell">ys</code> 的型別是 <code class="haskell">ListP Int</code>, <code class="haskell">head</code> 一定可成功。&shy;如果我們使用 <code class="haskell">List Int</code>, 在這裡就得多做些條件判斷。&shy;雖然每個非空串列 <code class="haskell">ListP</code> 都可用 <code class="haskell">List</code> 表達, 有些問題使用 <code class="haskell">ListP</code> 描述時會比較便於證明與推論。</p><p>接著我們試圖融合 <code class="haskell">shortest</code> 與 <code class="haskell">filter (all ascending) . partsP</code>.&shy;基底函數為 <code class="haskell">(shortest . wrap3) x = shortest [[[x]]] = [[x]]</code>.&shy;至於步驟函數，我們希望找到滿足下述融合條件的 <code class="haskell">step</code>:</p><pre><code class="spec">  shortest (concat (map (extendAsc x) ysss)) === step x (shortest ysss) 
</code></pre><p>由左手邊開始，由於 <code class="haskell">shortest</code> 可分配進 <code class="haskell">concat</code> （意即 <code class="haskell">shortest . concat = shortest . map shortest</code>），我們可推論：</p><pre><code class="spec">     shortest (concat (map (extendAsc x) ysss))
 ===   <comment>{- <code class="haskell">shortest</code> 分配進 <code class="haskell">concat</code>; <code class="haskell">map</code> 融合 -}</comment>
     shortest (map (shortest . extendAsc x) ysss) 
</code></pre><p>為了有些進展，我們看看 <code class="haskell">shortest . extendAsc x</code> 能如何化簡。&shy;將輸入（非空串列）寫成 <code class="haskell">ys : yss</code>:</p><pre><code class="spec">      shortest (extendAsc x (ys:yss)) =
 ===    <comment>{- <code class="haskell">extend'</code> 之定義; 提出 <code class="haskell">if</code> -}</comment>
      if x &gt;= head ys  then shortest [[x]:ys:yss, (x:ys):yss]
                       else shortest [[x]:ys:yss]
 ===    <comment>{- <code class="haskell">shortest</code> 挑選較短之串列 -}</comment>
      if x &gt;= head ys then (x:ys):yss else [x]:ys:yss 
</code></pre><p>因此，融合條件的左手邊可歸約如下：</p><pre><code class="spec">     shortest (map (shortest . extendAsc x) ysss)
===    <comment>{- 前述推導 -}</comment>
     shortest (map (\(ys:yss) -&gt;  if x &gt;= head ys then (x:ys):yss
                                       else [x]:ys:yss) ysss) 
</code></pre><p>我們希望繼續將 <code class="haskell">shortest</code> 往裡推，但此時似乎卡住了。</p><pre><code class="spec">     shortest (map (\(ys:yss) -&gt;  if x &gt;= head (head (head ysss)) then (x:ys):yss
                                       else [x]:ys:yss) ysss) 
===  shortest (  if x &gt;= head (head (head ysss))
                 then map (\(ys:yss) -&gt; (x:ys):yss) ysss
                 else map (\(ys:yss) -&gt; [x]:ys:yss) ysss)
===  if x &gt;= head (head (head ysss))
       then shortest (map (\(ys:yss) -&gt; (x:ys):yss) ysss)
       else shortest (map (\(ys:yss) -&gt; [x]:ys:yss) ysss)
===  if x &gt;= head (head (head ysss))
       then (\(ys:yss) -&gt; (x:ys):yss) (shortest ysss)
       else (\(ys:yss) -&gt; [x]:ys:yss) (shortest ysss)
===  let (ys:yss) = shortest ysss
     in  if x &gt;= head ys
         then (x:ys):yss else [x]:ys:yss 
</code></pre><pre><code class="spec">upHills = foldrn step (\x -&gt; [[x]]) 
  where  step x (ys:yss) = if x &gt;= head ys  then (x:ys):yss
                                            else [x]:ys:yss 
</code></pre><div class="exlist"><div class="exercise exer" id="ex:filtAscPExtend"><h5 class="exercise-title">練習 6.18 </h5><p>將 <code class="haskell">filter (all ascending) . partsP</code> 融合為 <code class="haskell">foldrn (\x -&gt; concat . map (extendAsc x)) wrap3</code>, 並在過程中推導 <code class="haskell">extendAsc</code> 的定義。&shy;您可能用得上習題<a href="Folds.html#ex:map-filter-split">6.6 </a>提及的性質：&shy;如果 <code class="haskell">filter p (f x) = if p x then g x else []</code>, 則 <code class="haskell">concat . map (filter p . f) = concat . map g . filter p</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-6-18" type="checkbox"/><label class="lbl-toggle" for="ans-6-18">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>基底函數為 <code class="haskell">filter (all ascending) . wrap3 = wrap3</code>.&shy;為求出步驟函數，我們推論：</p><pre><code class="haskell">      filter (all ascending) (concat (map (extend x) ysss))
 ===    <comment>{- <code class="haskell">filter p . concat = concat . map (filter p)</code>, <code class="haskell">map</code> 融合 -}</comment>
      concat (map (filter (all ascending) . extend x) ysss)
 ===    <comment>{- 推導 <code class="haskell">extendAsc</code>, 如下述 -}</comment>
      concat (map (extendAsc x) (filter (all ascending) ysss)) 
</code></pre><p>欲使得最後一步成立，我們使用習題<a href="Folds.html#ex:map-filter-split">6.6 </a>中的性質，&shy;試圖找到滿足下述條件的 <code class="haskell">extendAsc</code>：</p><pre><code class="spec">  filter (all ascending) (extend x yss) =
      if all ascending yss then extendAsc x yss else [] 
</code></pre><p>我們演算如下：</p><pre><code class="haskell">      filter (all ascending) (extend x (ys:yss))
 ===  filter (all ascending) [[x]:ys:yss, (x:ys):yss]
 ===     <comment>{- <code class="haskell">filter</code> 之定義; 因 <code class="haskell">ascending [x] = True</code> -}</comment>
      if all ascending (ys:yss) then
           ([x]:ys:yss) : filter (all ascending) [(x:ys):yss]
         else filter (all ascending) [(x:ys):yss]
 ===     <comment>{- <code class="haskell">filter</code> 與 <code class="haskell">ascending</code> 之定義；重安排 <code class="haskell">if</code> 的幾個分支 -}</comment>
      if all ascending (ys:yss) then
             if x &gt;= head ys  then [[x]:ys:yss, (x:ys):yss]
                                    else [[x]:ys:yss]
         else []
 ===     <comment>{- 抽取出 <code class="haskell">extendAsc</code> 如下 -}</comment>
      if all ascending (ys:yss) then extend' x (ys:yss) else []
</code></pre><p>其中 <code class="haskell">extendAsc</code> 的定義如下：</p><pre><code class="haskell">extendAsc x (ys:yss) = if x &gt;= head ys  then [[x]:ys:yss, (x:ys):yss]
                                        else [[x]:ys:yss] 
</code></pre></div></div></div><h2 class="section" id="sec:folds-ref">6.6 參考資料</h2><p><a href="Biblio.html#GibbonsHutton:01:When">Gibbons et al. [2001]</a></p></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
