<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" checked type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" checked type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:induction">2 歸納定義與證明</h1></div><div class="navi"><div class="previous">&laquo;<a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></div><div class="next"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:induction-lists">2.4 串列與其歸納定義</h2><p>如同第<a href="Basics-8.html#sec:lists">1.8 </a>節所述，「元素型別為<code class="haskell">a</code>的串列」可定義成如下的資料型別：<input class="toggle" id="footnote-2-4-5" type="checkbox"/><label class="fnote-toggle" for="footnote-2-4-5">(註5) </label><span class="collapsible-footnote">Haskell 中「元素型別為<code class="haskell">a</code>的串列」寫成<code class="haskell">[a]</code>. 由於這樣的符號在教學中遇到許多困難，本書中寫成<code class="haskell">List a</code>.</span></p><pre><code class="spec">data List a = [] | a : List a 
</code></pre><p>這個定義可以理解為</p><ol><li><p><code class="haskell">[]</code> 是一個串列，</p></li><li><p>若 <code class="haskell">xs</code> 是一個元素型別為<code class="haskell">a</code>的串列，<code class="haskell">x</code> 型別為 <code class="haskell">a</code>, 則 <code class="haskell">x:xs</code> 也是一個元素型別為<code class="haskell">a</code>的串列，</p></li><li><p>此外沒有其他元素型別為<code class="haskell">a</code>的串列。</p></li></ol><p>我們不難發現 <code class="haskell">List a</code> 和 <code class="haskell">Nat</code> 是相當類似的資料結構：<code class="haskell">[]</code> 相當於 <code class="haskell">Zero</code>, <code class="haskell">(:)</code> 則類似 <code class="haskell">Suc</code>, 只是此處我們不只「加一」，添加的那個東西多了一些資訊，是一個型別為<code class="haskell">a</code>的元素。
或著我們可反過來說，串列「只是」在每個<code class="haskell">Suc</code>上都添了一些資訊的自然數！
既然自然數與串列有類似的結構，不難想像許多自然上的函數、自然數的性質，都有串列上的類似版本，</p><h3 class="subsection" id="sec:induction-lists-defn">2.4.1 串列上之歸納定義</h3><p>和自然數類似，許多串列上的函數可歸納地定義出來。
由於串列只可能由<code class="haskell">[]</code>或<code class="haskell">(:)</code>做出，定義串列上的函數時也分別處理這兩個情況。
基底情況為<code class="haskell">[]</code>, 而欲定義 <code class="haskell">f (x:xs)</code> 的值時，可假設 <code class="haskell">f xs</code> 已算出來了：</p><pre><code class="spec">f :: List a -&gt; b
f []      = e
f (x:xs)  = ... f xs ...
</code></pre><p>來看些例子吧！「算一個陣列的和」可能是許多人學到陣列後得寫的頭幾個練習程式。串列版的和可以這麼寫：</p><pre><code class="spec">sum :: List Int -&gt; Int
sum []      = 0
sum (x:xs)  = x + sum xs 
</code></pre><p>基底狀況中，空串列的和應是<code class="haskell">0</code>。歸納步驟中，我們要算<code class="haskell">x:xs</code> 的和，可假設我們已算出<code class="haskell">xs</code> 的和，再加上<code class="haskell">x</code> 即可。計算串列長度的 <code class="haskell">length</code> 有很類似的定義 ：</p><pre><code class="haskell">length :: List a -&gt; Nat
length []      = Zero
length (x:xs)  = Suc (length xs) 
</code></pre><p>在歸納步驟中，我們想計算<code class="haskell">x:xs</code> 的長度，只需假設我們已知<code class="haskell">xs</code> 的長度，然後加一。
事實上，<code class="haskell">length</code> 剛好體現了前述「<code class="haskell">List a</code> 只是在每個<code class="haskell">Suc</code>上添了資訊的自然數」一事：
<code class="haskell">length</code> 把串列走過一遍，將 <code class="haskell">[]</code> 代換成 <code class="haskell">Zero</code>，並將每個 <code class="haskell">(_:)</code> 中附加的資訊拋棄，代換成 <code class="haskell">Suc</code>。</p><p>函數 <code class="haskell">map f :: List a -&gt; List b</code>，也就是 <code class="haskell">map</code> 給定函數 <code class="haskell">f</code> 的結果，也可在串列上歸納定義：</p><pre><code class="spec">map :: (a -&gt; b) -&gt; List a -&gt; List b
map f []      = []
map f (x:xs)  = f x : map f xs 
</code></pre><p>基底狀況的合理結果是<code class="haskell">[]</code>. 歸納步驟中，要對 <code class="haskell">x:xs</code> 中的每個元素都做 <code class="haskell">f</code>,
我們可假設已經知道如何對 <code class="haskell">xs</code> 中的每個元素都做 <code class="haskell">f</code>, 把其結果接上 <code class="haskell">f x</code> 即可。</p><p>函數 <code class="haskell">(++)</code> 把兩個串列接起來。如果我們在其左邊的參數上做歸納定義，可得到：
<input class="toggle" id="footnote-2-4-6" type="checkbox"/><label class="fnote-toggle" for="footnote-2-4-6">(註6) </label><span class="collapsible-footnote">依照 Haskell 的運算元優先順序，<code class="haskell">x : (xs ++ ys)</code> 其實可寫成 <code class="haskell">x : xs ++ ys</code>, 一般也常如此寫。此處為了清楚而加上括號。</span></p><pre><code class="spec">(++) :: List a -&gt; List a -&gt; List a
[]      ++ ys  = ys
(x:xs)  ++ ys  = x : (xs ++ ys) 
</code></pre><p>空串列接上 <code class="haskell">ys</code> 仍是 <code class="haskell">ys</code>. 歸納步驟中，要把 <code class="haskell">x:xs</code> 接上 <code class="haskell">ys</code>, 我們可假設已有辦法把 <code class="haskell">xs</code> 接上 <code class="haskell">ys</code>, 然後只需添上 <code class="haskell">x</code> 即可。</p><p>請讀者比較一下<code class="haskell">(++)</code>與自然數加法<code class="haskell">(+)</code>的定義，會發現兩者的結構一模一樣！
如果串列是在每個<code class="haskell">Suc</code>中加上資料的自然數，<code class="haskell">(++)</code>就是串列上的加法了。
若要形式化地把 <code class="haskell">List a</code>, <code class="haskell">Nat</code>, <code class="haskell">(++)</code>, 與 <code class="haskell">(+)</code> 牽上關係，連接他們的橋樑就是 <code class="haskell">length</code> --- <code class="haskell">xs ++ ys</code> 的長度，應是 <code class="haskell">xs</code> 與 <code class="haskell">ys</code> 的長度之和！意即：</p><pre><code class="equation" id="eq:length-append">  |length (xs ++ ys) = length xs + length ys| \mbox{~~.}</code>    (2.3 )
</pre><p>習題 <a href="#ex:length-append">2.10 </a> 中將證明此性質。</p><p>最後，<code class="haskell">(++)</code> 是反覆使用 <code class="haskell">(:)</code>, 函數 <code class="haskell">concat</code> 則是反覆使用 <code class="haskell">(++)</code>:</p><pre><code class="spec">concat :: List (List a) -&gt; List a
concat [] = []
concat (xs:xss) = xs ++ concat xss 
</code></pre><h3 class="subsection" id="sec:induction-lists-proof">2.4.2 串列上之歸納證明</h3><p>如果 <code class="haskell">List a</code> 是一個歸納定義出的資料結構，我們應可以在 <code class="haskell">List a</code> 之上做歸納證明。確實，串列上的歸納法可寫成：</p><pre><code class="equation" title="串列上之歸納法：">  |(forall xs . P xs)  &lt;==   P [] ⋀ (forall x xs . P (x:xs) &lt;== P xs) |</code>    (2.4 )
</pre><p>以文字敘述的話：給定一個述語 <code class="haskell">P :: List a -&gt; Bool</code>, 若要證明 <code class="haskell">P xs</code> 對所有 <code class="haskell">xs</code> 都成立，只需證明 <code class="haskell">P []</code> 和「對所有 <code class="haskell">x</code> 和 <code class="haskell">xs</code>, 若 <code class="haskell">P xs</code> 則 <code class="haskell">P (x:xs)</code>」。</p><p>下述的 <em><code class="haskell">map</code> 融合定理</em>(<em>map-fusion theorem</em>)
<span id="ix-2-7"></span>
是關於 <code class="haskell">map</code> 極常用的定理之一。所謂「融合」在此處是把兩個 <code class="haskell">map</code> 融合為一。
我們日後會見到更多的融合定理。</p><div class="theorem" id="thm:map-fusion" title="|map| 融合定理"><h5 class="theorem-title">定理 2.2  |map| 融合定理 </h5><p>對任何 <code class="haskell">f</code> 與 <code class="haskell">g</code>,
<code class="haskell">map f . map g = map (f.g)</code>.</p></div><p>作為一個例子，我們試著證明定理<a href="#thm:map-fusion">2.2 </a>。
我們目前只會用歸納證明，但是 <code class="haskell">map f . map g = map (f.g)</code> 的左右邊都是函數，
沒有出現串列也沒有出現自然數。該拿什麼東西來歸納呢？</p><p>回顧<em>外延相等</em>（定義<a href="Basics-4.html#def:extensional-eq">1.8 </a>）：
當<code class="haskell">h</code>, <code class="haskell">k</code> 均是函數，<code class="haskell">h = k</code> 的意思是對任何參數 <code class="haskell">x</code>, <code class="haskell">h x = k x</code>.
因此，將待證式左右邊各補上參數，並將 <code class="haskell">(.)</code> 展開，可得知其意義為對任何 <code class="haskell">xs</code>,</p><pre><code class="equation">    |map f (map g xs) = map (f.g) xs| \mbox{~ ~.}</code>    (2.5 )
</pre><p>我們便可以在<code class="haskell">xs</code>上做歸納了！</p><div class="proof"><b>證明 </b><p>當 <code class="haskell">xs := []</code>，等式兩邊皆歸約為 <code class="haskell">[]</code>.
考慮 <code class="haskell">xs := x:xs</code> 的情況：</p><pre><code class="spec">  map f (map g (x:xs))
=   <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
  map f (g x : map g xs)
=   <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
  f (g x) : map f (map g xs)
=   <comment>{- <code class="haskell">(.)</code> 之定義 -}</comment>
  (f.g) x : map f (map g xs)
=   <comment>{- 歸納假設 -}</comment>
  (f.g) x : map (f.g) xs
=   <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
  map (f.g) (x:xs) 
</code></pre></div><div class="infobox infobox" title="等式證明的步驟該多詳細？"><h5 class="infobox-title">等式證明的步驟該多詳細？</h5><p>本書中目前為止的等式證明相當細：每一個定義展開都成為獨立的步驟。
這是為了教學目的，實務上不一定得如此。
以我而言，自己的研究手稿中可能會將步驟寫得極詳細，
為確保每個細節正確，並讓他人（或幾年後已經忘記細節的自己）在不需知道上下文的情況下也能機械化地檢查每個步驟。
但在論文中，因篇幅有限，及考量讀者一次能處理的資訊量有限，
發表出的證明可能會省略許多步驟。</p><p>實務上，被認為簡單、不寫出也不妨礙理解的步驟或說明都可被省略。
但何謂簡單則很依靠作者的判斷與習慣。
一般說來，僅展開定義的步驟用電腦便可自動做到，通常是可精簡掉的。
最好寫出的步驟則可能是決定整個證明之結構的、不易以電腦決定而得靠人類智慧與經驗的，等等。
這可能包括使用歸納假設的那步，或使用較特別的引理時。
例如，性質 [RefUndefined]的歸納步驟證明可能被精簡如下：</p><pre><code class="spec">   length ((x:xs) ++ ys)
=  Suc (length (xs ++ ys))
=    <comment>{- 歸納假設 -}</comment>
   Suc (length xs + length ys)
=  length (x:xs) + length ys 
</code></pre></div><div class="exlist"><div class="exercise exer" id="ex:append-nil"><h5 class="exercise-title">練習 2.4 </h5><p>證明對所有 <code class="haskell">xs</code>, <code class="haskell">xs ++ [] = xs</code>. 比較本題與習題<a href="Induction-3.html#ex:add-right-id">2.3 </a>的證明。</p></div><div class="exercise exer" id="ex:reverse"><h5 class="exercise-title">練習 2.5 </h5><p>定義函數 <code class="haskell">reverse :: List a -&gt; List a</code>, 將輸入的串列反轉。例如 <code class="haskell">reverse [1,2,3,4,5] = [5,4,3,2,1]</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-5" type="checkbox"/><label class="lbl-toggle" for="ans-2-5">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="spec">reverse :: List a -&gt; List a
reverse []      = []
reverse (x:xs)  = reverse xs ++ [x] 
</code></pre><p>另，關於 <code class="haskell">reverse</code> 效率的討論詳見第 <a href="Derivation-2.html#sec:efficiency-basics">5.2 </a> 節。</p></div></div><div class="exercise exer" id="ex:length-map"><h5 class="exercise-title">練習 2.6 </h5><p>證明對所有 <code class="haskell">f</code>, <code class="haskell">length . map f = length</code>.</p></div><div class="exercise exer" id="ex:sum-map-times"><h5 class="exercise-title">練習 2.7 </h5><p>證明對所有 <code class="haskell">x</code>, <code class="haskell">sum . map (x*) = (x*) . sum</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-7" type="checkbox"/><label class="lbl-toggle" for="ans-2-7">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>欲證明<code class="haskell">sum (map (x*) ys) = x * sum ys</code>, 在 <code class="haskell">ys</code> 上歸納。</p><p><strong>情況</strong> <code class="haskell">ys := []</code>, 兩邊都歸約為 <code class="haskell">0</code>.</p><p><strong>情況</strong> <code class="haskell">ys := y:ys</code>:</p><pre><code class="spec">   sum (map (x*) (y:ys))
=    <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
   sum (x*y : map (x*) ys)
=    <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
   x * y + sum (map (x*) ys)
=    <comment>{- 歸納假設 -}</comment>
   x * y + x * sum ys
=    <comment>{- 乘法與加法之分配律 -}</comment>
   x * (y+sum ys)
=    <comment>{- <code class="haskell">sum</code> 之定義 -}</comment>
   x * sum (y:ys) 
</code></pre></div></div><div class="exercise exer" id="ex:sum-map-suc"><h5 class="exercise-title">練習 2.8 </h5><p>證明對所有 <code class="haskell">xs</code>, <code class="haskell">sum (map (Suc) xs) = length xs + sum xs</code>.</p></div><div class="exercise exer" id="ex:sum-map-const"><h5 class="exercise-title">練習 2.9 </h5><p>證明對所有 <code class="haskell">xs</code> 與 <code class="haskell">y</code>,
<code class="haskell">sum (map (const y) xs) = y * length xs</code>.</p></div></div><p>討論自然數時，習題<a href="Induction-3.html#ex:add-associative">2.2 </a>曾請讀者證明加法都滿足結合律。此處示範證明類似定理的串列版：</p><div class="theorem" id="thm:append-associative"><h5 class="theorem-title">定理 2.3  </h5><p><code class="haskell">(++)</code> 滿足結合律。意即，對任何 <code class="haskell">xs</code>, <code class="haskell">ys</code>, 和<code class="haskell">zs</code>,
<code class="haskell">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</code>.</p></div><div class="proof"><b>證明 </b><p>上述式子中有三個變數，我們怎麼得知該在哪一個變數上做歸納呢？
此時絕對別急著把三個變數都拆開，變成多達八種狀況。
觀察：如果要歸約等號左邊的 <code class="haskell">(xs ++ ys) ++ zs</code>，根據 <code class="haskell">(++)</code> 的定義，得對 <code class="haskell">xs ++ ys</code> 做狀況分析；要歸約 <code class="haskell">xs ++ ys</code>，又得對 <code class="haskell">xs</code> 做狀況分析。
同樣地，根據 <code class="haskell">(++)</code> 的定義，要歸約等號右邊的 <code class="haskell">xs ++ (ys ++ zs)</code> 得對 <code class="haskell">xs</code> 做狀況分析。
不論左右邊，最關鍵的值都是 <code class="haskell">xs</code>.
因此我們在 <code class="haskell">xs</code> 之上做歸納。</p><p><strong>狀況</strong> <code class="haskell">xs:=[]</code>:</p><pre><code class="spec">   ([] ++ ys) ++ zs
=   <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   ys ++ zs
=   <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   [] ++ (ys ++ zs) 
</code></pre><p><strong>狀況</strong> <code class="haskell">xs:= x:xs</code>:</p><pre><code class="spec">   ((x:xs) ++ yz) ++ zs
=    <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   (x : (xs ++ ys)) ++ zs
=    <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   x : ((xs ++ ys) ++ zs)
=    <comment>{- 歸納假設 -}</comment>
   x : (xs ++ (ys ++ zs))
=    <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
   (x : xs) ++ (ys ++ zs) 
</code></pre></div><p>基底狀況的證明很簡單。至於歸納步驟，同樣地，前兩步都是為了湊出 <code class="haskell">(xs ++ ys) ++ zs</code>, 以便使用歸納假設。既然 <code class="haskell">(++)</code> 滿足結合律，日後我們寫 <code class="haskell">xs ++ ys ++ zs</code> 就可不加括號了。</p><div class="exlist"><div class="exercise exer" id="ex:length-append"><h5 class="exercise-title">練習 2.10 </h5><p>證明性質([RefUndefined])：對所有 <code class="haskell">xs</code> 與 <code class="haskell">ys</code>, <code class="haskell">length (xs ++ ys) = length xs + length ys</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-10" type="checkbox"/><label class="lbl-toggle" for="ans-2-10">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>檢視 <code class="haskell">length</code>, <code class="haskell">(++)</code>, 與 <code class="haskell">(+)</code> 的定義，會發現等號兩邊都須對 <code class="haskell">xs</code> 做分析才能化簡。因此我們對 <code class="haskell">xs</code> 做歸納。</p><p><strong>狀況</strong> <code class="haskell">xs := []</code>.</p><pre><code class="haskell">      length ([] ++ ys)
 ===    <comment>{- <code class="haskell">(++)</code> 之定義 -}</comment>
      length ys
 ===   <comment>{- <code class="haskell">(+)</code> 之定義 -}</comment>
      Zero + length ys
 ===   <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
      length [] + length ys 
</code></pre><p><strong>狀況</strong> <code class="haskell">xs := x : xs</code>.</p><pre><code class="haskell">   length ((x:xs) ++ ys)
 ===    <comment>{- <code class="haskell">(++)</code> 之定義  -}</comment>
   length (x : (xs ++ ys))
 ===    <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
   Suc (length (xs ++ ys))
 ===    <comment>{- 歸納假設 -}</comment>
   Suc (length xs + length ys)
 ===    <comment>{- <code class="haskell">(+)</code> 之定義 -}</comment>
   (Suc (length xs)) + length ys
 ===    <comment>{- <code class="haskell">length</code> 之定義 -}</comment>
   length (x:xs) + length ys 
</code></pre></div></div><div class="exercise exer" id="ex:map-append"><h5 class="exercise-title">練習 2.11 </h5><p>證明對所有 <code class="haskell">f</code>, <code class="haskell">xs</code>, 與 <code class="haskell">ys</code>, <code class="haskell">map f (xs ++ ys) = map f xs ++ map f ys</code>.</p></div></div></div><div class="navi"><div class="previous">&laquo;<a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></div><div class="next"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
