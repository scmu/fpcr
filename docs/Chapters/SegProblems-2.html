<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" checked type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:segment-problems">7 區段問題</h1></div><div class="navi"><div class="previous">&laquo;<a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></div><div class="next"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:maximum-plateau-length">7.2 最長高原問題</h2><p>如果一個區段的每個元素都相等，我們稱之為一個「高原(plateau)」。
本節考慮這個問題：給一個串列，找出其中最長的高原的長度。
例如當輸入為 <code class="haskell">[2,3,3,2,2,2,1,6,6]</code> 時，輸出應為 <code class="haskell">3</code> --- 即最長的高原 <code class="haskell">[2,2,2]</code> 的長度。
以下是本問題的一種可能的規格寫法：</p><pre><code class="haskell">lp :: List Int -&gt; Int
lp = maximum . map length . filter plateau . segmentsP 
</code></pre><p>其中 <code class="haskell">segmentsP</code> 算出所有的區段，<code class="haskell">plateau</code> 判斷一個區段是否為高原。
過濾出所有的高原後，我們計算每個高原的長度，然後找出最大值。
<input class="toggle" id="footnote-7-2-3" type="checkbox"/><label class="fnote-toggle" for="footnote-7-2-3">(註3) </label><span class="collapsible-footnote">函數 <code class="haskell">lp</code> 與 <code class="haskell">plateau</code> 可以有更通用的型別 <code class="haskell">Eq a =&gt; List a -&gt; Int</code>, <code class="haskell">Eq a =&gt; List a -&gt; Bool</code>.</span></p><p>函數 <code class="haskell">segmentsP</code> 和 <code class="haskell">segments</code> 類似，其定義為：</p><pre><code class="haskell">segmentsP :: List a -&gt; List (ListP a)
segmentsP = concat . map initsP . tailsP 
</code></pre><p>函數 <code class="haskell">initsP</code> 與 <code class="haskell">tailsP</code> 則與 <code class="haskell">inits</code> 與 <code class="haskell">tails</code> 類似，但只傳回非空的前後段，定義如下：</p><div class="multicols"><div class="mcol" width="0.5\textwidth"><pre><code class="haskell">initsP :: List a -&gt; List (ListP a)
initsP []      = []
initsP (x:xs)  = [x] : map (x:) (initsP xs) <comment>{-"~,"-}</comment>

</code></pre></div><div class="mcol" width="0.5\textwidth"><pre><code class="haskell">tailsP :: List a -&gt; List (ListP a)
tailsP []      = []
tailsP (x:xs)  = (x:xs) : tailsP xs 
</code></pre></div></div><p>以上三個函數的回傳型別都是 <code class="haskell">List (ListP a)</code> ---
每個傳回的前/後/區段都是非空的，但並非每個串列都有非空的前/後/區段。
函數 <code class="haskell">lp</code> 仍可接受空串列作為輸入，但（我們等下將看到）在規格中使用 <code class="haskell">segmentsP</code> 將帶來不少方便。
我們也可使用 <code class="haskell">segments</code> 定最長平原問題的規格，只是會增加一些不利於講解的細節。</p><p>函數 <code class="haskell">plateau</code> 可定義如下：</p><pre><code class="haskell">plateau :: ListP Int -&gt; Bool
plateau [x]       = True
plateau (x:y:xs)  = x == y ⋀ plateau (y:xs) 
</code></pre><p>由於輸入是非空串列，<code class="haskell">plateau</code> 的定義中考慮的是「有一個元素」和「有兩個以上元素」的兩種情況。</p><div class="infobox infobox" title="區段問題不傳回區段？"><h5 class="infobox-title">區段問題不傳回區段？</h5><p>為何我們在最大區段和問題中只傳回最大區段的和、在最長高原問題中只傳回長度，而不傳回該區段本身呢？</p><p>\quad 這是許多演算法題目常見的簡化：當真正的問題是尋找「使得某值最大的聚合資料結構」時，我們常只要求解題者傳回該值，而不是整個聚合資料結構。如此做的好處之一是讓我們能暫時忽略「如何組出需傳回的資料結構」的細節，更專注在問題本身。這使得問題的規格與推導過程都簡單許多。</p><p>\quad 如果我們真的需要整個區段，我們總能將前述的簡單版程式擴充為傳回資料結構的程式。讀者不妨試試能否將第  頁的 <code class="haskell">mpsAll</code> 改寫為型別為
<code class="haskell">List Int -&gt; List (Int × List Int)</code> 的程式 --- 對每個後段，計算其<em>最佳前段和，以及該前段</em>。您會發現程式結構並沒有改變，只是多了些繁瑣的細節。</p><p>\quad 另一個理由是：具有最大和的區段可能不只一個。在<em>函數</em>程式推導之中，如果我們要傳回區段，由於規格也是函數，我們似乎必須在規格中就決定傳回哪一個。若希望規格是「傳回<em>任一個</em>具有最大和的區段」，我們會需要更多機制，例如使用<em>關係</em>(<em>relation</em>)或使用單子。</p></div><p><b>前段-後段分解</b> &emsp;
和最大區段和問題一樣，我們先嘗試把這個區段問題分解為「對每個後段，計算最佳前段」：</p><pre><code class="haskell">      maximum . map length . filter plateau . segmentsP
 ===  maximum . map length . filter plateau . concat . map initsP . tailsP
 ===     <comment>{- 因 <code class="haskell">filter p . concat = concat . map (filter p)</code> -}</comment>
      maximum . map length . concat . map (filter plateau . initsP) . tailsP
 ===     <comment>{- 因  <code class="haskell">map f . concat = concat . map (map f)</code>, <code class="haskell">map</code> 融合 -}</comment>
      maximum . concat . map (map length . filter plateau . initsP) . tailsP
 ===     <comment>{- 因 <code class="haskell">maximum . concat = maximum . map maximum</code>, <code class="haskell">map</code> 融合 -}</comment>
      maximum . map (maximum . map length . filter plateau . initsP) . tailsP 
</code></pre><p><b>嘗試使用掃描引理</b> &emsp;
下一步：我們把 <code class="haskell">maximum . map length . filter plateau . initsP</code> 簡寫為 <code class="haskell">lpp</code>，
並嘗試將它寫成 ([RefUndefined]) 的形式，以便使用掃描引理。演算如下：</p><pre><code class="haskell">      (maximum . map length . filter plateau . initsP $ (x:xs))
 ===  (maximum . map length . filter plateau $ [x] : map (x:) (initsP xs))
 ===    <comment>{- <code class="haskell">filter</code> 之定義，<code class="haskell">plateau [x] = True</code> -}</comment>
      maximum (1 : map length (filter plateau (map (x:) (initsP xs))))
 ===  1 ↑ maximum (map length (filter plateau (map (x:) (initsP xs)))) 
</code></pre><p>演算至此的問題是：如何把 <code class="haskell">map (x:)</code> 提出來呢？
定理<a href="Induction-6.html#thm:filter-map">2.4 </a>允許我們把 <code class="haskell">map</code> 搬到 <code class="haskell">filter</code> 的左邊：</p><pre><code class="spec"> filter p . map f = map f . filter (p . f) 
</code></pre><p>至於 <code class="haskell">plateau . (x:)</code> 能否再化簡？觀察 <code class="haskell">plateau</code> 定義的第二個子句：</p><pre><code class="spec">plateau (x:y:xs)  = x == y ⋀ plateau (y:xs) 
</code></pre><p>寫成函數組合的形式便是：</p><pre><code class="spec">plateau . (x:) = ((x ==) . head) ⋀: plateau 
</code></pre><p>其中 <code class="haskell">(⋀:)</code> 為「提升成函數版」的 <code class="haskell">(⋀)</code>, 定義為</p><pre><code class="haskell">(⋀:) :: (a -&gt; Bool) -&gt; (a -&gt; Bool) -&gt; a -&gt; Bool
(f ⋀: g) x = f x ⋀ g x 
</code></pre><p>函數 <code class="haskell">(⋀) :: Bool -&gt; Bool -&gt; Bool</code> 拿兩個布林值、算出一個新布林值，<code class="haskell">(⋀:)</code> 則拿兩個函數 <code class="haskell">f, g :: a -&gt; Bool</code>，組合成另一個型別為 <code class="haskell">a -&gt; Bool</code> 的函數，其結果是 <code class="haskell">f</code> 與 <code class="haskell">g</code> 之傳回值的合取。函數 <code class="haskell">filter</code> 與 <code class="haskell">(⋀:)</code> 有如下的性質：</p><pre><code class="equation" id="eq:filter-conjunct">  |filter (p ⋀: q)| & |= filter p . filter q| \mbox{~~.}</code>    (7.3 )
</pre><p>有了以上眾多性質，我們演算如下：</p><pre><code class="haskell">      filter plateau . map (x:)
 ===    <comment>{- 定理 \ref{thm:filter-map} -}</comment>
      map (x:) . filter (plateau . (x:))
 ===    <comment>{- <code class="haskell">plateau</code> 之定義 -}</comment>
      map (x:) . filter (((x ==) . head) ⋀: plateau)
 ===    <comment>{- 因 \eqref{eq:filter-conjunct}: <code class="haskell">filter (p ⋀: q) = filter p . filter q</code> -}</comment>
      map (x:) . filter plateau . filter ((x ==) . head) 
</code></pre><p>現在整個式子成為 <code class="haskell">1 ↑ (maximum . map (length . (x:)) . filter plateau . filter ((x ==) . head) . initsP) $ xs</code>.</p><p>把 <code class="haskell">map (x:)</code> 往左搬之後，式子的右邊出現了 <code class="haskell">filter ((x ==) . head) (initsP xs)</code> --- 產生所有 <code class="haskell">xs</code> 的非空前段，取出第一個元素為 <code class="haskell">x</code> 的。但讀者們可能立刻發現：<code class="haskell">initsP</code> 傳回的每個前段的第一個元素都是一樣的！也就是說我們有以下性質。</p><p>考慮非空前段的好處在這兒可看出：<code class="haskell">head</code> 對非空串列才有值。</p><p>回到 <code class="haskell">lpp</code>，我們可繼續推導如下：</p><pre><code class="haskell">      lpp (x : xs)
 ===   <comment>{- 前述演算, <code class="haskell">map</code> 融合 -}</comment>
      1 ↑  (maximum . map (length . (x:)) . filter plateau .
                  filter ((x ==) . head) . initsP $ (x : xs))
 ===   <comment>{- 因 \eqref{eq:initsP-heads} -}</comment>
      1 ↑  (maximum . map (length . (x:)) . filter plateau $
                  if x == head xs then initsP xs else [])
 ===   <comment>{- \eqref{eq:fn-if-distribute}: 函數分配進 <code class="haskell">if</code> -}</comment>
      if x == head xs
        then 1 ↑  (maximum . map (length . (x:)) . filter plateau . initsP $ xs)
        else 1 ↑ (maximum . map (length . (x:)) . filter plateau $ [])
 ===   <comment>{- <code class="haskell">length . (x:) = (1+) . length</code>, 及其他化簡 -}</comment>
     if x == head xs
        then 1 + (maximum . map length . filter plateau . initsP $ xs)
        else 1
 ===   <comment>{- <code class="haskell">lpp</code> 之定義 -}</comment>
     if x == head xs then 1 + lpp xs else 1 
</code></pre><p>由此我們得到</p><pre><code class="haskell">lpp [x]     = 1
lpp (x:xs)  = if x == head xs then 1 + lpp xs else 1 
</code></pre><p>然而，我們雖為 <code class="haskell">lpp</code> 推導出了一個歸納定義，該定義並不符合 ([RefUndefined])！
後者要求 <code class="haskell">lpp</code> 的右手邊必須是 <code class="haskell">x ⊕ lpp xs</code> 的形式 --- 在 <code class="haskell">lpp xs</code> 之外不能有其他的 <code class="haskell">xs</code>, 而上述的 <code class="haskell">lpp</code> 右手邊多了一個 <code class="haskell">head xs</code>.</p><p>這時組對的技巧又派上用場了。定義：</p><pre><code class="spec">lpph xs = (lpp xs, head xs) 
</code></pre><p>我們可推導出</p><pre><code class="haskell">lpph [x]     = (1, x)
lpph (x:xs)  = (if x == y then 1 + n else 1, x) 
   where (n,y) = lpph xs 
</code></pre><p>該函數符合 ([RefUndefined]) 的形式，其中 <code class="haskell">e = (1,x)</code>, <code class="haskell">x ⊕ (y,n) = (if x == y then 1 + n else 1, x)</code>.</p><p><b>總結</b> &emsp;
綜合目前為止的推導，函數 <code class="haskell">lpp</code> 的推導大架構如下：</p><pre><code class="haskell">      lpp
 ===    <comment>{- 前段-後段分解 -}</comment>
      maximum . map (maximum . map length . filter plateau . initsP) . tailsP
 ===    <comment>{- 前述演算：尋找歸納定義 -}</comment>
      maximum . map lpp . tailsP
 ===    <comment>{- 因 <code class="haskell">lpp = fst . lpph</code>  -}</comment>
      maximum . map (fst . lpph) . tailsP
 ===    <comment>{- 掃描引理 -}</comment>
      maximum . map fst . lpphAll 
</code></pre><p>其中 <code class="haskell">lpphAll</code> 的定義如下：</p><pre><code class="haskell">lpphAll [x]     = [(1,x)]
lpphAll (x:xs)  = (if x == y then 1 + n else 1, x) : (n,y) : ys 
  where ((n,y) : ys) = lpphAll xs 
</code></pre><p>這是一個使用線性時間、線性空間的演算法。</p></div><div class="navi"><div class="previous">&laquo;<a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></div><div class="next"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
