<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" checked type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:induction">2 歸納定義與證明</h1></div><div class="navi"><div class="previous">&laquo;<a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></div><div class="next"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:complete-induction">2.11 完全歸納</h2><p>說到遞迴定義，費氏數(Fibonacci number)
<span id="ix-2-33"></span>是最常見的教科書例子之一。
簡而言之，第零個費氏數是 <code class="haskell">0</code>, 第一個費氏數是 <code class="haskell">1</code>, 之後的每個費氏數是之前兩個的和。
寫成遞迴定義如下：</p><pre><code class="spec">fib :: Nat -&gt; Nat
fib 0      = 0
fib 1      = 1
fib (2+n)  = fib (1+n) + fib n 
</code></pre><p>但這和我們之前談到的歸納定義稍有不同。
我們已知定義 <code class="haskell">f (Suc n)</code> 時可假設 <code class="haskell">f</code> 在 <code class="haskell">n</code> 之上已有定義。
但在 <code class="haskell">fib</code> 的定義中，<code class="haskell">fib (2+n)</code> 用到了 <code class="haskell">fib</code> 的前<em>兩個</em>值。這樣的定義是可以的嗎？</p><p>函數 <code class="haskell">fib</code> 的定義可以視為<em>完全歸納</em><span id="ix-2-34"></span>%
（又稱作<em>強歸納</em>）的例子。
回顧：先前介紹的數學歸納法中，使 <code class="haskell">P n</code> 成立的前提之一是「對所有 <code class="haskell">n</code>, 若 <code class="haskell">P n</code> 成立， <code class="haskell">P (Suc n)</code> 亦成立」。完全歸納則把這個前提增強如下：</p><blockquote><p>給定述語<code class="haskell">P :: Nat -&gt; Bool</code>. 若</p><ul><li><p>對所有小於 <code class="haskell">n</code> 的值 <code class="haskell">i</code>，<code class="haskell">P i</code> 皆 成立，則 <code class="haskell">P n</code> 亦成立，</p></li></ul><p>則我們可得知 <code class="haskell">P</code> 對所有自然數皆成立。</p></blockquote><p>以更形式化的方式可寫成：</p><pre><code class="equation" id="eq:complete-induction" title="完全歸納：">  |(forall n . P n)   &lt;==  (forall n . P n  &lt;== (forall i &lt; n . P i)) |</code>    (2.17 )
</pre><p>請注意：前提 <code class="haskell">P n  &lt;== (forall i &lt; n . P i)</code> 隱含 <code class="haskell">P 0</code> 成立，因為當 <code class="haskell">n := 0</code>, 由於沒有自然數 <code class="haskell">i</code> 滿足 <code class="haskell">i &lt; n</code>, 算式 <code class="haskell">(forall i &lt; n . P i)</code> 可化簡為 <code class="haskell">True</code>.</p><p>在完全歸納法之中，證明 <code class="haskell">P n</code> 時，我們可假設 <code class="haskell">P</code> 對<em>所有</em>小於 <code class="haskell">n</code> 的值都已成立了。
對寫程式的人來說，有了完全歸納法，表示我們日後定義自然數上的函數 <code class="haskell">f :: Nat -&gt; a</code> 時，每個 <code class="haskell">f n</code> 都可以自由使用 <code class="haskell">f</code> 在<em>所有</em>小於 <code class="haskell">n</code> 的輸入之上的值。因此 <code class="haskell">fib (2+n)</code> 可以用到 <code class="haskell">fib (1+n)</code> 與 <code class="haskell">fib n</code>, 因為 <code class="haskell">n &lt; 1+n &lt; 2+n</code>.</p><div class="theorem" id="eg:complete-induction-example"><h5 class="theorem-title">例 2.15  </h5><p>關於完全歸納，離散數學教科書中的一個常見例子是「試證明所有自然數都可寫成不相同的二的乘冪的和」，例如 $50 = 2^5 + 2^4 + 2$.
這可用完全歸納證明。我們以半形式的方式論述如下：
令 <code class="haskell">P n</code> 為「$n$可寫成一串不相同的二的乘冪的和」. 對所有 <code class="haskell">n</code>, 我們想要證明 <code class="haskell">P n  &lt;== (forall i &lt; n . P i)</code>. 當 <code class="haskell">n</code> 為 <code class="haskell">Zero</code>, 這一串數字即是空串列。
當 <code class="haskell">n</code> 大於零，</p><ul><li><p>我們可找到最接近 <code class="haskell">n</code> 但不超過 <code class="haskell">n</code> 的二之乘冪，稱之為 <code class="haskell">m</code>（也就是 $m = 2^k$ 而且 $m \leq n < 2\times m$）.</p></li><li><p>由於 $n$ 不是 <code class="haskell">Zero</code>, $m$ 也不是 <code class="haskell">Zero</code>. 也因此 <code class="haskell">n - m &lt; n</code>.</p></li><li><p>依據歸納假設 <code class="haskell">(forall i &lt; n . P i)</code>, 以及 <code class="haskell">n - m &lt; n</code>, <code class="haskell">P (n-m)</code> 成立 --- <code class="haskell">n - m</code> 可以寫成不相同的二的乘冪的和。</p></li><li><p>也因此 <code class="haskell">n</code> 可寫成不相同的二的乘冪的和 --- 把 <code class="haskell">n-m</code> 加上 $m$ 即可.</p></li></ul><p>上述證明僅用口語描述，因為如果形式化地寫下這個證明，就等同於寫個將自然數轉成一串二的乘冪的程式，並證明其正確性！下述函數 <code class="haskell">binary</code> 做這樣的轉換，例如，<code class="haskell">binary 50 = [32,16,2]</code>:</p><pre><code class="haskell">binary :: Nat -&gt; List Nat
binary Zero  = []
binary n     = m : binary (n - m) 
   where  m     = last (takeWhile (&lt;=n) twos)
          twos  = iterate (2 *:) 1 
</code></pre><p>函數 <code class="haskell">binary</code> 是一個完全歸納定義，和上述的證明對應得相當密切：串列 <code class="haskell">twos</code> 是 <code class="haskell">[1,2,4,8...]</code> 等等所有二的乘冪，<code class="haskell">m</code> 是其中最接近而不超過 <code class="haskell">n</code> 的。
遞迴呼叫 <code class="haskell">binary (n - m)</code> 是許可的，因為 <code class="haskell">n - m &lt; n</code>, 而根據完全歸納，我們已假設對所有 <code class="haskell">i &lt; n</code>, <code class="haskell">binary i</code> 皆有定義。</p></div><p>有了完全歸納法，我們在定義自然數上的函數時可允許更靈活的函數定義：</p><pre><code class="spec">f :: Nat -&gt; a
f b = ....                 <comment>{- 一些基底情況 -}</comment>
f n = ... f m ... f k ...  <comment>{- 如果 <code class="haskell">m &lt; n</code> 且 <code class="haskell">k &lt; n</code> -}</comment>
</code></pre><p><code class="haskell">f n</code> 的右手邊可以出現不只一個遞迴呼叫，只要參數都小於 <code class="haskell">n</code>.
但我們必須<em>確定上述定義中的幾個子句足以包含所有狀況，沒有狀況被遺漏</em>。
例如，我們若 把 <code class="haskell">fib</code> 定義中的 <code class="haskell">fib 1 = ...</code> 基底狀況去掉，
計算 <code class="haskell">fib 2 = fib 1 + fib 0</code> 時便會出錯。</p><div class="exlist"><div class="exercise exer" id="ex:sum-binary"><h5 class="exercise-title">練習 2.43 </h5><p>證明 <code class="haskell">sum (binary n) = n</code>.</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-43" type="checkbox"/><label class="lbl-toggle" for="ans-2-43">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>使用完全歸納。</p><p><strong>狀況</strong> <code class="haskell">n := Zero</code>: 等號兩邊都歸約為 <code class="haskell">[]</code>.</p><p><strong>狀況</strong> <code class="haskell">n &gt; Zero</code>。
假設對於任何 <code class="haskell">0 &lt;= i &lt; n</code>, <code class="haskell">sum (binary i) = i</code>.</p><pre><code class="spec">   sum (binary n) =
=    <comment>{- 令 <code class="haskell">m = last (takeWhile (&lt;=n) twos)</code>, <code class="haskell">sum</code> 之定義 -}</comment>
   m + sum (binary (n - m))
=    <comment>{- 因 <code class="haskell">n - m &lt; n</code>, 歸納假設 -}</comment>
   m + (n - m)
=  n 
</code></pre></div></div><div class="exercise exer" id="ex:fib-alpha"><h5 class="exercise-title">練習 2.44 </h5><p>證明當 <code class="haskell">n &gt;= 1</code>, <code class="haskell">fib (2+n) &gt; {-"\alpha^n"-}</code>, 其中
$\alpha = (1+\sqrt{5})/2$. 這個證明可用 <code class="haskell">n := 1</code> 和 <code class="haskell">n := 2</code> 當基底狀況。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-2-44" type="checkbox"/><label class="lbl-toggle" for="ans-2-44">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>本證明的關鍵性質是 $\alpha^2 = (3+\sqrt{5})/2 = \alpha + 1$.
使用完全歸納證明 <code class="haskell">fib (2+n) &gt; {-"\alpha^n"-}</code>，以 <code class="haskell">n := 1</code> 和 <code class="haskell">n := 2</code> 當基底狀況。</p><p><strong>狀況</strong> <code class="haskell">n := 1</code>: <code class="haskell">fib 3 = 2 &gt; {-"\alpha"-}</code>.</p><p><strong>狀況</strong> <code class="haskell">n := 2</code>: <code class="haskell">fib 4 = 3 &gt; {-"(3+\sqrt{5})/2 = \alpha^2"-}</code>.</p><p><strong>狀況</strong> <code class="haskell">n := 2+n</code> 且 <code class="haskell">2+n &gt; 4</code>。
假設對於任何 <code class="haskell">3 &lt;= i &lt; 2+n</code>, <code class="haskell">fib i &gt; {-"\alpha^{i-2}"-}</code>. 論證：</p><pre><code class="spec">    fib (2+n)
 =  fib (1+n) + fib n
 &gt;    <comment>{- 歸納假設 -}</comment>
    <comment>{-"\alpha^{n-1}"-}</comment> + <comment>{-"\alpha^{n-2}"-}</comment>
 =    <comment>{- 提出 $\alpha^{n-2}$-}</comment>
    <comment>{-"(\alpha + 1) \times \alpha^{n-2}"-}</comment>
 =    <comment>{- $\alpha^2 = \alpha + 1$ -}</comment>
    <comment>{-"\alpha^2 \times \alpha^{n-2}"-}</comment>
 =  <comment>{-"\alpha^n"-}</comment> 
</code></pre></div></div></div><p><b>完全歸納 vs 簡單歸納</b> &emsp;
完全歸納有個較早的稱呼：<em>強歸納</em>(strong induction)。<span id="ix-2-35"></span>
原本的歸納法則相對被稱呼為<em>簡單歸納</em>或<em>弱歸納</em>。
強/弱歸納的稱呼可能使人以為完全歸納比簡單歸納更強 --- 意謂前者能證明出一些後者無法證明的定理。
事實上，完全歸納與簡單歸納是等價的：能用一個方法證出的定理，用另一個方法也能證出。
因此，使用哪一個純粹只是方便性的考量。</p><p>反應在程式設計上，給任一個完全歸納定義函數 <code class="haskell">f :: Nat -&gt; A</code>, 我們總能做出一個以簡單歸納定義的函數 <code class="haskell">fs :: Nat -&gt; List A</code>,
滿足 <code class="haskell">fs n = map f [n, n-1, ... 0]</code>.
例如，函數 <code class="haskell">fibs n</code> 傳回 <code class="haskell">[fib n, fib (n-1).., fib 0]</code>.</p><pre><code class="haskell">fibs :: Nat -&gt; List Nat
fibs 0        = [0]
fibs 1        = [1,0]
fibs (Suc n)  = (x1+x0) : x1 : x0 : xs  
    where (x1:x0:xs) = fibs n 
</code></pre><p>由 <code class="haskell">fib</code> 到 <code class="haskell">fibs</code> 的轉換可能令讀者想起演算法中的<em>動態規劃</em>(<em>dynamic programming</em>)<span id="ix-2-36"></span>。我們將在日後談到這個話題。</p><p><b>串列上的完全歸納</b> &emsp;
串列與自然數是類似的資料結構。串列上的完全歸納原則便是將 <code class="haskell">Zero</code> 代換為 <code class="haskell">[]</code>,
將 <code class="haskell">Suc</code> 代換為 <code class="haskell">(x:)</code>. 至於「小於」的關係，可定義為：</p><pre><code class="spec">ys &lt; xs  &lt;=&gt; ys ∈ tails xs ⋀ ys /= xs 
</code></pre><p>也就是說 <code class="haskell">ys</code> 是 <code class="haskell">xs</code> 的一個後段，但不是 <code class="haskell">xs</code> 自己。
有了如上定義，串列上的完全歸納法是：</p><pre><code class="equation" title="串列的完全歸納：">|(forall xs . P xs)   &lt;==  (forall xs . P xs  &lt;== (forall ys &lt; xs . P ys)) |</code>    (2.18 )
</pre><p>應用在編程上，當定義 <code class="haskell">f (xs:)</code> 時，遞迴呼叫可作用在 <code class="haskell">xs</code> 的任何後段上。</p><p>但對許多串列上的函數而言，這樣的模式還不夠靈活。我們得用下一節說到的良基歸納。</p></div><div class="navi"><div class="previous">&laquo;<a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></div><div class="next"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
