<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" checked type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-3.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="Derivation-3.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:induction">2 歸納定義與證明</h1></div><div class="navi"><div class="previous">&laquo;<a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></div><div class="next"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:well-founded-induction">2.12 良基歸納</h2><p><em>良基歸納</em>(<em>well-founded induction</em>)
<span id="ix-2-37"></span>
可視為完全歸納的再推廣。
如果說完全歸納的主角是自然數，使用的是自然數上的「小於<code class="haskell">(&lt;)</code>」關係，良基歸納則將其推廣到任何型別，使用任一個<em>良基序</em>。</p><div class="theorem"><h5 class="theorem-title">定義 2.16  </h5><p>給定某型別 <code class="haskell">A</code> 之上的二元關係 <code class="haskell">(&lt;:)</code>。如果從任意一個 <code class="haskell">a0 :: A</code> 開始，均<em>不</em>存在無限多個滿足如下關係的 <code class="haskell">a1</code>, <code class="haskell">a2</code>\ldots :</p><pre><code class="equation">   \ldots |&lt;: a2 &lt;: a1 &lt;: a0| \mbox{~~,}</code>    (2.19 )
</pre><p>則 <code class="haskell">(&lt;:)</code> 可稱為一個<em>良基序</em>(<em>well-founded ordering</em>)<span id="ix-2-38"></span>。</p></div><p>把<code class="haskell">b &lt;: a</code> 簡稱為「<code class="haskell">b</code> 小於 <code class="haskell">a</code>」。
上述定義可以這麼地直覺理解：
給定任一個 <code class="haskell">a0 :: A</code>，我們找一個滿足 <code class="haskell">a1 &lt;: a0</code> 的值 <code class="haskell">a1</code>。
這種 <code class="haskell">a1</code> 可能已不存在，但如果存在，我們再找一個滿足 <code class="haskell">a2 &lt;: a1</code> 的 <code class="haskell">a2</code>.
說 <code class="haskell">(&lt;:)</code> 是個良基序的意思便是前述過程不可能永遠做下去：總有一天我們得停在一個「最小」的某<em>基底</em> <code class="haskell">an :: A</code>。</p><p>舉例說明：自然數上的「小於<code class="haskell">(&lt;)</code>」關係是個良基序，但整數上的<code class="haskell">(&lt;)</code>關係則不是 --- 由於負數的存在。實數上的<code class="haskell">(&lt;)</code>關係也不是。良基序並非得是個全序(total order)。例如，我們可定義序對上的比較關係如下：</p><pre><code class="spec">  (x1,y1) &lt;: (x2,y2)  &lt;=&gt;  x1 &lt; x2 ⋀ y1 &lt; y2 
</code></pre><p>其中 <code class="haskell">x1</code>, <code class="haskell">y1</code>, <code class="haskell">x2</code>, <code class="haskell">y2</code> 都是自然數。
這麼一來，不論 <code class="haskell">(1,4) &lt;: (2,3)</code> 或 <code class="haskell">(2,3) &lt;: (1,4)</code> 都不成立，但 <code class="haskell">(&lt;:)</code> 仍是個良基序 --- 任何兩個自然數形成的序對不論以什麼方式遞減，最晚也得停在 <code class="haskell">(0,0)</code>.</p><p>如果 <code class="haskell">(&lt;:)</code> 是個良基序，我們便可在其上做歸納。以直覺來理解的話，如果某函數定義成如此的形式（假設這幾個子句已經包括參數的所有可能情況）：</p><pre><code class="spec">f :: A -&gt; B
f b = ....                 <comment>{- 一些基底情況 -}</comment>
f x = ... f y ... f z ...  <comment>{- 如果 <code class="haskell">y &lt;: x</code> 且 <code class="haskell">z &lt;: x</code> -}</comment>
</code></pre><p>由任何 <code class="haskell">f x</code> 開始，若 <code class="haskell">x</code> 不是基底情況之一，我們需遞迴呼叫 <code class="haskell">f y</code> 和 <code class="haskell">f z</code>。
但 <code class="haskell">y</code> 和 <code class="haskell">z</code> 在 <code class="haskell">(&lt;:)</code> 這個序上比 <code class="haskell">x</code>「小」了一點。
此後即使再做遞迴呼叫，每次使用的參數又更小了一點。
而由於 <code class="haskell">(&lt;:)</code> 是良基序，<code class="haskell">f</code> 的參數不可能永遠「小」下去 --- <code class="haskell">f</code> 非得停在某個基底情況不可。
因此 <code class="haskell">f</code> 必須正常終止。
同樣的原則也用在證明上：</p><blockquote><p>給定述語<code class="haskell">P :: A -&gt; Bool</code> 以及 <code class="haskell">A</code> 之上的良基序 <code class="haskell">(&lt;:)</code>。若</p><ul><li><p>對所有滿足 <code class="haskell">y &lt;: x</code> 的值 <code class="haskell">y</code>，<code class="haskell">P y</code> 皆 成立，則 <code class="haskell">P x</code> 亦成立，</p></li></ul><p>則我們可得知 <code class="haskell">P</code> 對所有 <code class="haskell">A</code> 皆成立。</p></blockquote><p>或著可寫成如下形式：</p><pre><code class="equation" title="良基歸納：">|(forall x . P x)   &lt;==  (forall x . P x  &lt;== (forall y &lt;: x . P y)) <comment>{-"~~,\\"-}</comment>
<comment>{-"\qquad\mbox{其中 $(\lhd)$ 為一個良基序。}"-}</comment>|</code>    (2.20 )
</pre><p><b>終止證明與良基歸納</b> &emsp;
我們已在許多地方強調：確定程式正常終止是很重要的。
我們也知道以簡單歸納與完全歸納定義出的程式均是會正常終止的。
但這兩種歸納定義的限制很多。雖然我們已舉了許多例子，仍有些程式難以套入它們所要求的模板中。
相較之下，良基歸納寬鬆許多。大部分我們已知、會終止的程式都可視為良基歸納定義。</p><p>或著，上述段落應該反過來說。
在函數程設中，欲證明某個遞迴定義的函數會終止，最常見的方式是證明該函數每次遞迴呼叫時使用的參數都在某個度量上「變小」了，而這個度量又不可能一直變小下去。
因此該函數遲早得碰到基底狀況。
換句話說，該函數每次遞迴呼叫的參數符合某個良基序；
<em>當我們如此證明一個函數會終止，其實就相當於在論證該函數是一個良基歸納定義</em>。
在指令式編程中證明某迴圈會終止的做法也類似。
最常見的方式是證明該迴圈每多執行一次，某個量值就會變小，而該量值是不可能一直變小的。
也就是說這些量值在每趟迴圈執行時的值符合某個良基序。</p><p>以下我們將看幾個遞迴定義的例子。請讀者們想想：這些函數總會正常終止嗎？為何？如果它們是良基歸納，使用的良基序是什麼？</p><div class="theorem" id="ex:quicksort" title="快速排序"><h5 class="theorem-title">例 2.17  快速排序 </h5><p>以下是大家熟悉的<em>快速排序</em>(quicksort)
<span id="ix-2-39"></span>  <a href="../Biblio.html#Hoare:62:Quicksort">[Hoare 1962]</a>:</p><pre><code class="spec">qsort :: List Int -&gt; List Int
qsort []      = []
qsort (x:xs)  = qsort ys ++ [x] ++ qsort zs 
  where (ys,zs) = (filter (&lt;=x) xs, filter (&lt;x) xs) 
</code></pre><p>空串列是已經排序好的。當輸入為非空串列 <code class="haskell">x:xs</code>，我們將 <code class="haskell">xs</code> 分為小於等於 <code class="haskell">x</code> 的，以及大於 <code class="haskell">xs</code> 的，分別遞迴排序，再將結果接在一起。</p><p>函數 <code class="haskell">qsort</code> 會正常終止，因為每次遞迴呼叫時，作為參數的串列都會減少至少一個元素（因為 <code class="haskell">x</code> 被取出了），而串列的長度又不可能小於 <code class="haskell">0</code>. 若要稍微形式地談這件事，可從良基歸納的觀點來看。如果定義：</p><pre><code class="spec">ys &lt;: xs  &lt;=&gt;  length ys &lt; length xs 
</code></pre><p>在 <code class="haskell">qsort (x:xs)</code> 子句中，<code class="haskell">ys &lt;: xs</code> 和 <code class="haskell">zs &lt;: xs</code> 均被滿足，而 <code class="haskell">(&lt;:)</code> 是一個良基序。因此 <code class="haskell">qsort</code> 是一個奠立在 <code class="haskell">(&lt;:)</code> 之上的良基歸納定義。</p></div><div class="theorem" id="eg:mergesort" title="合併排序"><h5 class="theorem-title">例 2.18  合併排序 </h5><p>在串列上，合併排序<span id="ix-2-40"></span>也是很常使用的排序方式。
我們在第<a href="Basics-9.html#sec:wholemeal">1.9 </a>節中示範過以全麥編程方式寫成、由下往上的合併排序。
此處的寫法則更接近大家一般的認知：拿到一個長度為 <code class="haskell">n</code> 的串列，將之分割為長度大致為 <code class="haskell">n/2</code> 的兩段，分別排序之後合併。
同樣地，假設我們已有一個函數 <code class="haskell">merge :: List Int -&gt; List Int -&gt; List Int</code>,
如果 <code class="haskell">xs</code> 與 <code class="haskell">ys</code> 已經排序好，<code class="haskell">merge xs ys</code> 將它們合併為一個排序好的串列。
合併排序可寫成：</p><pre><code class="spec">msort :: List Int -&gt; List Int
msort []   = []
msort [x]  = [x]
msort xs   = merge (msort ys) (msort zs) 
  where (ys,zs) = (take (n `div` 2) xs, drop (n `div` 2) xs) 
</code></pre><p>要論證 <code class="haskell">msort</code> 會正常終止，或著說，要將 <code class="haskell">msort</code> 視為一個良基歸納定義，我們可用和例<a href="#ex:quicksort">2.17 </a>中一樣的良基序<code class="haskell">(&lt;:)</code>.</p><p>但此處請讀者小心檢查：在 <code class="haskell">msort xs</code> 子句中，<code class="haskell">ys &lt;: xs</code> 和 <code class="haskell">zs &lt;: xs</code> 有被滿足嗎？
當 <code class="haskell">length xs = n</code>, 串列 <code class="haskell">ys</code> 與 <code class="haskell">zs</code> 的長度分別是 <code class="haskell">n `div` 2</code> 和 <code class="haskell">n - n `div` 2</code>. 當 <code class="haskell">length xs = 1</code> 時，<code class="haskell">ys</code> 與 <code class="haskell">zs</code> 的長度分別是... <code class="haskell">0</code> 和 <code class="haskell">1</code> --- <code class="haskell">zs</code> 並沒有變短！</p><p>這是為何我們需要 <code class="haskell">msort [x]</code> 這個子句把 <code class="haskell">length xs = 1</code> 的情況分開處理。如果沒有這個子句，<code class="haskell">msort</code> 將有可能不終止 --- 讀者不妨試試看。</p></div><div class="theorem" id="eg:gcd" title="最大公因數"><h5 class="theorem-title">例 2.19  最大公因數 </h5><p>歐幾里得(Euclid)的《幾何原本》成書於西元前三百年，其中描述「計算最大公因數」<span id="ix-2-41"></span>的做法可能是世界上最古老的演算法。
以下函數計算兩個自然數 <code class="haskell">(m,n)</code> 的最大公因數。
如果兩數相等，它們的最大公因數也是自身。
若兩數不相等，其最大公因數會是「大數減小數」與「小數」的最大公因數：</p><pre><code class="haskell">gcd :: (Nat × Nat) -&gt; Nat
gcd (m,n)  | m == n     = n
           | otherwise  = gcd ((m ↑ n) - (m ↓ n), m ↓ n) 
</code></pre><p>這個程式總會正常終止嗎？為什麼？</p><p>事實上，若 <code class="haskell">m</code> 或 <code class="haskell">n</code> 其中之一為 <code class="haskell">0</code>, <code class="haskell">gcd (m,n)</code> 是不會終止的 ---
讀者不妨也試試看。
若 <code class="haskell">m</code>, <code class="haskell">n</code> 均為<em>正</em>整數呢？
首先我們先確立：如果初始的 <code class="haskell">m</code>, <code class="haskell">n</code> 均為正整數，<code class="haskell">gcd</code> 每次遞迴呼叫拿到的參數也都是正整數 ---
確實如此，因為如果 <code class="haskell">m &gt; 0</code>, <code class="haskell">n &gt; 0</code>, 且 <code class="haskell">m /= n</code>, 那麼 <code class="haskell">(m ↑ n) - (m ↓ n)</code> 與 <code class="haskell">m ↓ n</code> 都不會是零或負數。
接下來我們可論證：如果 <code class="haskell">m</code>, <code class="haskell">n</code> 均為正整數，每次遞迴呼叫中，<em>兩參數的和</em>都變小了一些。確實：</p><pre><code class="spec">   (m ↑ n) - (m ↓ n) + (m ↓ n)
=  m ↑ n
&lt;   <comment>{- <code class="haskell">m</code>, <code class="haskell">n</code> 均為正整數 -}</comment>
   m + n 
</code></pre><p>因此，我們可得知 <code class="haskell">gcd</code> 在 <code class="haskell">m</code>, <code class="haskell">n</code> 均為正整數時會正常終止。
如果把 <code class="haskell">gcd</code> 當作一個良基歸納，我們用了如下的良基序：</p><pre><code class="spec">  (m1, n1) &lt;: (m2, n2)  &lt;=&gt;   m1+n1 &lt; m2+n2 
</code></pre><p>其中 <code class="haskell">m1</code>, <code class="haskell">n1</code>, <code class="haskell">m2</code>, <code class="haskell">n2</code> 均為正整數。</p></div><div class="theorem" id="ex:interleave" title="Curried 函數"><h5 class="theorem-title">例 2.20  Curried 函數 </h5><p>下述函數 <code class="haskell">interleave</code> 將兩個參數中的元素交錯放置。
例如 <code class="haskell">interleave [1,2,3] [4,5] = [1,4,2,5,3]</code>.</p><pre><code class="haskell">interleave :: List a -&gt; List a -&gt; List a
interleave []      ys  = ys
interleave xs      []  = xs
interleave (x:xs)  ys  = x : interleave ys xs 
</code></pre><p>這可視為一個良基歸納定義嗎？
若將 <code class="haskell">interleave</code> 做為傳回函數的高階函數看待，我們比較難看出它是定義在什麼良基序上的。
但若把 <code class="haskell">interleave</code> 的兩個參數一起考慮，我們不難看出什麼度量在遞迴呼叫後「變小」了：兩個參數長度的和！</p><p>凡是遇到像 <code class="haskell">interleave</code> 的 curried 函數，我們也可考慮它的 uncurried 版本：</p><pre><code class="haskell">interleave' :: (List a × List a)-&gt; List a
interleave' ([],    ys)  = ys
interleave' (xs,    [])  = xs
interleave' (x:xs,  ys)  = x : interleave' (ys,xs) 
</code></pre><p>函數 <code class="haskell">interleave'</code> 是個良基定義 --- 參數中的兩個串列雖然交換位置，但它們長度的總和會變小。也就是說 <code class="haskell">interleave'</code> 可視為定義在這個良基序上的函數：</p><pre><code class="spec">  (xs1,ys1) &lt;: (xs2,ys2)  &lt;=&gt;  length xs1 + length ys1 &lt; length xs2 + length ys2 
</code></pre><p>凡是 <code class="haskell">interleave'</code> 有的性質，不難找出 <code class="haskell">interleave</code> 的相對應版本；
證明 <code class="haskell">interleave</code> 的性質時，可當成是在證明 <code class="haskell">interleave'</code> 的相對性質。
因此我們也會比較寬鬆地說 <code class="haskell">interleave</code> 也是 <code class="haskell">(&lt;:)</code> 之上的良基歸納定義。</p></div><div class="theorem" id="eg:McCarthy91"><h5 class="theorem-title">例 2.21  </h5><p>下列函數被稱作「McCarthy 91 函數」：</p><pre><code class="haskell">mc91 :: Nat -&gt; Nat
mc91 n  | n &gt; 100    = n - 10
        | otherwise  = mc91 (mc91 (n + 11)) 
</code></pre><p>讀者不妨先猜猜看 <code class="haskell">mc91</code> 會傳回什麼？答案是，<code class="haskell">mc</code> 和以下函數是等價的：</p><pre><code class="spec">mc91'  | n &gt; 100    = n - 10
       | otherwise  = 91 
</code></pre><p>\todo{finish this.}</p></div></div><div class="navi"><div class="previous">&laquo;<a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></div><div class="next"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
