<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="../ToC.html">目錄</a></p><p><a href="../Preface.html">前言</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction-1.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li>
<li class="pure-menu-item"><a href="Introduction-2.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li>
<li class="pure-menu-item"><a href="Introduction-3.html#sec:abstraction">0.3 抽象化</a></li>
<li class="pure-menu-item"><a href="Introduction-4.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li>
<li class="pure-menu-item"><a href="Introduction-5.html#sec:correctness">0.5 正確性</a></li>
<li class="pure-menu-item"><a href="Introduction-6.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li>
<li class="pure-menu-item"><a href="Introduction-7.html#sec:relevant-information">0.7 相關資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics-1.html#sec:evaluation">1.1 值與求值</a></li>
<li class="pure-menu-item"><a href="Basics-2.html#sec:function-defns">1.2 函數定義</a></li>
<li class="pure-menu-item"><a href="Basics-3.html#sec:higher-order-func">1.3 高階函數</a></li>
<li class="pure-menu-item"><a href="Basics-4.html#sec:func-comp">1.4 函數合成</a></li>
<li class="pure-menu-item"><a href="Basics-5.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-6.html#sec:boolean">1.6.1 布林值</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:char">1.6.2 字元</a></li>
<li class="pure-menu-item"><a href="Basics-6.html#sec:pairs">1.6.3 序對</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-7.html#sec:weak-head-normal-form">1.7 弱首範式</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics-8.html#sec:list-deconstruct">1.8.1 串列解構</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-generation">1.8.2 串列生成</a></li>
<li class="pure-menu-item"><a href="Basics-8.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Basics-9.html#sec:wholemeal">1.9 全麥編程</a></li>
<li class="pure-menu-item"><a href="Basics-10.html#sec:user-defined-data">1.10 自訂資料型別</a></li>
<li class="pure-menu-item"><a href="Basics-11.html#sec:refs-basics">1.11 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction-1.html#sec:math-induction">2.1 數學歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-2.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-3.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li>
<li class="pure-menu-item"><a href="Induction-4.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-5.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction-6.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:list-segments">2.6.3 串列區段</a></li>
<li class="pure-menu-item"><a href="Induction-6.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Induction-7.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li>
<li class="pure-menu-item"><a href="Induction-8.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li>
<li class="pure-menu-item"><a href="Induction-9.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li>
<li class="pure-menu-item"><a href="Induction-10.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li>
<li class="pure-menu-item"><a href="Induction-11.html#sec:complete-induction">2.11 完全歸納</a></li>
<li class="pure-menu-item"><a href="Induction-12.html#sec:well-founded-induction">2.12 良基歸納</a></li>
<li class="pure-menu-item"><a href="Induction-13.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li>
<li class="pure-menu-item"><a href="Induction-14.html#sec:mutual-induction">2.14 交互歸納</a></li>
<li class="pure-menu-item"><a href="Induction-15.html#sec:induction-ref">2.15 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-1.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.1 紅黑樹插入</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.2 紅黑樹之性質：高度</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.3 紅黑樹之性質：平衡</a></li>
<li class="pure-menu-item"><a href="SearchTrees-2.html#">3.2.4 紅黑樹之性質：顏色</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics-1.html#sec:denotational-semantics">4.1 指稱語意</a></li>
<li class="pure-menu-item"><a href="Semantics-2.html#sec:operational-semantics">4.2 操作語意</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" checked type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-1.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li>
<li class="pure-menu-item"><a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></li>
<li class="pure-menu-selected pure-menu-item"><a href="#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" checked type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li>
<li class="pure-menu-item"><a href="#sec:exp-binary-roll">5.3.2 二進位表示法</a></li>
<li class="pure-menu-item"><a href="#sec:wrap-reminder">5.3.3 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-5.html#sec:steep">5.5.1 陡串列</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li>
<li class="pure-menu-item"><a href="Derivation-5.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation-6.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion">5.6.3 尾遞迴</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li>
<li class="pure-menu-item"><a href="Derivation-6.html#sec:difference-list">5.6.6 函數作為串列</a></li>
</ul></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-1.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li>
<li class="pure-menu-item"><a href="Folds-1.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:scan-lemma">6.2.3 掃描</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:banana-split">6.2.4 香蕉船定理</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li>
<li class="pure-menu-item"><a href="Folds-2.html#sec:bring-in-context">6.2.6 引入脈絡</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds-3.html#sec:foldl">6.3.1 左摺</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:list-homomorphism">6.3.2 串列同構</a></li>
<li class="pure-menu-item"><a href="Folds-3.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Folds-4.html#sec:foldN">6.4 自然數的摺</a></li>
<li class="pure-menu-item"><a href="Folds-5.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li>
<li class="pure-menu-item"><a href="Folds-6.html#sec:folds-ref">6.6 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems-1.html#sec:maximum-segment-sum">7.1 最大區段和</a></li>
<li class="pure-menu-item"><a href="SegProblems-2.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li>
<li class="pure-menu-item"><a href="SegProblems-3.html#sec:segProblems-ref">7.3 參考資料</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads.html#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads-1.html#sec:exceptions">8.1 例外處理</a></li>
<li class="pure-menu-item"><a href="Monads-2.html#sec:monad-class-laws">8.2 單子與單子律</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-3.html#sec:var-env-reader">8.3.1 變數與環境</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li>
<li class="pure-menu-item"><a href="Monads-3.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-4.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads-4.html#sec:hanoi">8.4.1 河內塔問題</a></li>
</ul></li>
<li class="pure-menu-item"><a href="Monads-5.html#sec:monads-ref">8.5 參考資料</a></li>
</ul></li>
</ul></nav><p><a href="../Ix.html">索引</a></p><p><a href="../Biblio.html">參考書目</a></p><p class="author-info"><a href="https://homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div>
<div id="main"><div class="header"><h1 class="chapter" id="ch:derivation">5 一般程式推導</h1></div><div class="navi"><div class="previous">&laquo;<a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></div><div class="next"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a>&raquo;</div></div><div class="content"><h2 class="section" id="sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</h2><p>在前面的例子中，我們手動推導出的 <code class="haskell">sumsq</code> 只比原來的版本快了一點點，並沒有複雜度上的改進。
本節我們來看一些使用程式推導改進複雜度的例子。</p><h3 class="subsection" id="sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</h3><p>給定整數串列 $\Varid{as} = [a_0, a_1, a_2 \ldots a_n]$ 以及 <code class="haskell">x :: Int</code>, 我們想計算如下的多項式：</p><pre><code class="equation">    a_0 + a_1 x + a_2 x^2 + ... + a_n x^n \mbox{~~.}</code>    (5.2 )
</pre><p>這問題的規格能清楚寫成：</p><pre><code class="haskell">poly x as = sum (zipWith (*) as (iterate (* x) 1)) 
</code></pre><p>其中 <code class="haskell">iterate (* x) 1</code> 產生無限串列 $[1, x, x^2, x^3 ...]$, <code class="haskell">zipWith</code> 計算 $[a_0, a_1 x, \ldots a_n x^n]$, <code class="haskell">sum</code> 計算總和。</p><p>讀者應已對 <code class="haskell">sum</code> 和 <code class="haskell">zipWith</code> 很熟悉了。函數 <code class="haskell">iterate</code> 在第 <a href="Basics-8.html#sec:list-generation">1.8.2 </a> 節中使用過，<code class="haskell">iterate f x</code> 會展開為無限長的串列 <code class="haskell">[x, f x, f (f x)...]</code>，每個元素分別是把 <code class="haskell">f</code> 使用<code class="haskell">0</code>次、<code class="haskell">1</code>次、<code class="haskell">2</code>次... 的結果。
函數 <code class="haskell">iterate</code> 可定義為</p><pre><code class="spec">iterate :: (a -&gt; a) -&gt; a -&gt; List a
iterate f x = x : map f (iterate f x) 
</code></pre><p>我們可將之理解成：<code class="haskell">iterate f x</code> 的第一個元素是 <code class="haskell">x</code>；剩下的元素呢？是把 <code class="haskell">iterate f x</code> 本身拿來，對每個元素多做一次 <code class="haskell">f</code>!</p><p>讀到此的讀者可能有些疑問：這是一個合法的歸納定義嗎？以及，我們原已說定不談無限的資料結構，何以在此卻出現了呢？</p><p>上述 <code class="haskell">iterate</code> 的定義方式確實不是歸納，而是「餘歸納」(coinduction)的一個例子。<span id="ix-5-3"></span>
第<a href="Induction-9.html#sec:induction-set-theory">2.9 </a>節中曾提及，餘歸納與歸納互為對偶，以餘歸納定義出的資料結構稱作「餘資料」，可以是能無限地展開的。<span id="ix-5-4"></span>
「餘串列」和歸納定義的串列應該視為不同的型別，但它們可共存於同一個程式中，只要我們確定不在餘資料上做歸納定義或證明。</p><p>為培養一些對 <code class="haskell">iterate</code> 的直覺，我們試著展開它：</p><pre><code class="spec">  iterate f x
=   <comment>{- <code class="haskell">iterate</code> 之定義 -}</comment>
  x : map f (iterate f x)
=   <comment>{- <code class="haskell">map</code> 之定義 -}</comment>
  x : map f (x : map f (iterate f x))
=   <comment>{- <code class="haskell">map</code> 融合 -}</comment>
  x : f x : map (f . f) (iterate f x)
=   <comment>{- <code class="haskell">iterate</code> 與 <code class="haskell">map</code> 之定義 -}</comment>
  x : f x : f (f x) : map (f . f) (map f (iterate f x))
=   <comment>{- <code class="haskell">map</code> 融合 -}</comment>
  x : f x : f (f x) : map (f . f . f) (iterate f x)
</code></pre><p>可發現越展開，式子中便累積越多個 <code class="haskell">map f</code>.</p><p>在 <code class="haskell">poly</code> 之中，<code class="haskell">iterate</code> 雖產生無限長的餘資料，但立刻被 <code class="haskell">zipWith</code> 截短了。
<input class="toggle" id="footnote-5-3-2" type="checkbox"/><label class="fnote-toggle" for="footnote-5-3-2">(註2) </label><span class="collapsible-footnote">此處我們假設 <code class="haskell">as</code> 為有限長的串列，並把 <code class="haskell">zipWith</code> 視為在其第一個參數之上的歸納定義。</span>
若我們試著展開 <code class="haskell">poly x [a,b,c,d]</code>, 會得到：</p><pre><code class="spec">   poly x [a,b,c,d]
=  sum (zipWith (*) [a,b,c,d] (iterate (* x) 1))
=    <comment>{- 展開 <code class="haskell">iterate</code>, 將「<code class="haskell">f</code>自我組合四次」記為 <code class="haskell">quad f</code> -}</comment>
   sum (zipWith (*) [a,b,c,d]
     (1 : (1*x) : (1*x*x) : (1*x*x*x) : map (quad (*x)) (iterate (*x) 1)))
=  a  +  b *x  +  c * x * x  +  d * x * x * x 
</code></pre><p>可看到式子越長，便累積越多個 <code class="haskell">(*x)</code>。當 <code class="haskell">as</code> 長度為 <code class="haskell">n</code>, 需要的乘法數目為 $O(n^2)$.
我們有可能降低做乘法的次數嗎？</p><p>我們試著找出 <code class="haskell">poly</code> 在 <code class="haskell">as</code> 上的歸納定義。
當 <code class="haskell">as := []</code> 時，<code class="haskell">poly x []</code> 可歸約為 <code class="haskell">0</code>.
考慮 <code class="haskell">as := a:as</code> 的情況，和做證明時一樣，我們先將 <code class="haskell">poly x (a:as)</code> 展開，然後試著整理出 <code class="haskell">sum (zipWith (*) as (iterate (* x) 1)</code>，以便收回成為 <code class="haskell">poly x as</code>。
計算中的每一步都以此為目的，試著將 <code class="haskell">sum</code> 與 <code class="haskell">zipWith</code> 移動至 <code class="haskell">iterate</code> 旁邊:</p><pre><code class="haskell" id="ex:polyDer1">      poly x (a : as)
 ===   <comment>{- <code class="haskell">poly</code> 的定義 -}</comment>
      sum (zipWith (*) (a:as) (iterate (* x) 1))
 ===   <comment>{- <code class="haskell">iterate</code> 的定義 -}</comment>
      sum (zipWith (*) (a:as) (1 : map (* x) (iterate (* x) 1)))
 ===   <comment>{- <code class="haskell">zipWith</code> 與 <code class="haskell">sum</code> 的定義 -}</comment>
      a + sum (zipWith (*) as (map (* x) (iterate (* x) 1)))
 ===   <comment>{- <code class="haskell">zipWith (*) as . map (* x) = map (* x) . zipWith (*) as</code>，見習題 -}</comment>
      a + sum (map (* x) (zipWith (*) as (iterate (* x) 1)))
 ===   <comment>{- <code class="haskell">sum . map (* x) = (* x) . sum</code> -}</comment>
      a + (sum (zipWith (*) as (iterate (* x) 1))) * x
 ===   <comment>{- <code class="haskell">poly</code> 的定義 -}</comment>
      a + (poly x as) * x 
</code></pre><p>第 <code class="haskell">4</code> 步中關於 <code class="haskell">zipWith</code> 與 <code class="haskell">map</code> 的性質幫助我們將 <code class="haskell">map (*x)</code> 往外提、將 <code class="haskell">zipWith</code> 往裡推。事實上，該性質不限於乘法，而可適用於任何滿足結合律的運算子 <code class="haskell">otimes</code>。我們可非正式地理解如下：</p><pre><code class="spec">   zipWith otimes [a,b,c] (map (⊗ x) [d,e,f])
=  [a ⊗ (d ⊗ x), b ⊗ (e ⊗ x), c ⊗ (f ⊗ x)]
=    <comment>{- 結合律: <code class="haskell">m ⊗ (n ⊗ k) = (m ⊗ n) ⊗ k</code> -}</comment>
   [(a ⊗ d) ⊗ x, (b ⊗ e) ⊗ x, (c ⊗ f) ⊗ x]
=  map (⊗ x) (zipWith otimes [a,b,c] [d,e,f]) 
</code></pre><p>第 <code class="haskell">5</code> 步之中的 <code class="haskell">sum . map (* x) = (* x) . sum</code> 在習題<a href="Induction-4.html#ex:sum-map-times">2.7 </a>中證明過，需要乘法與加法的分配律。
在本推導中，它的功能是將 <code class="haskell">sum</code> 往右推。
它也是使 <code class="haskell">poly</code> 可以加速的關鍵性質：共同的 <code class="haskell">(*x)</code> 可以提出來 ---
左手邊可能做了的許多次 <code class="haskell">(*x)</code> 其實只需做一次。
追根究底，<code class="haskell">poly</code> 之所以能算得更快，都歸功於乘法與加法的分配律。
經過上述計算，我們可得：</p><pre><code class="spec">poly x []        = 0
poly x (a : as)  = a + (poly as) * x 
</code></pre><p>在這個定義中，函數 <code class="haskell">poly</code> 遞迴多少次，便做多少個乘法。
因此本演算法所需的乘法數目為 $O(n)$.</p><p>快速版本的函數 <code class="haskell">poly</code> 相當於把 $a_0 + a_1 x + a_2 x^2 + ... + a_n x^n$ 轉換成</p><pre><code class="equation">    a_0 + x \times (a_1 + x \times (a_2 + ... + (a_{n-1} + x \times a_n)))\mbox{~~.}</code>    (5.3 )
</pre><p>這條規則在 William George Horner 1819 年的一篇論文中出現並證明，因此通常被稱作 <em>Horner 法則</em><span id="ix-5-5"></span>，
雖然 Horner 本人和許多歷史學家們都相信該規則可被追溯得更早。</p><div class="exlist"><div class="exercise exer" id="ex:zipWith-otimes-map"><h5 class="exercise-title">練習 5.8 </h5><p>試證明：如果 <code class="haskell">otimes</code> 滿足結合律，<code class="haskell">zipWith otimes as . map (⊗ x) = map (⊗ x) . zipWith otimes as</code>。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-8" type="checkbox"/><label class="lbl-toggle" for="ans-5-8">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>欲證明<code class="haskell">zipWith otimes as (map (⊗ x) bs) = map (⊗ x) (zipWith otimes as bs)</code>, 在 <code class="haskell">as</code> 上做歸納。
當 <code class="haskell">as := []</code>, 等號兩邊都歸約成 <code class="haskell">[]</code>.
考慮 <code class="haskell">as := a:as</code> 的情況。若 <code class="haskell">bs := []</code>, 等號兩邊仍均為 <code class="haskell">[]</code>.
當 <code class="haskell">bs := b:bs</code>:</p><pre><code class="haskell">      zipWith otimes (a:as) (map (⊗ x) (b:bs))
 ===    <comment>{- <code class="haskell">zipWith</code> 與 <code class="haskell">map</code> 之定義 -}</comment>
      (a ⊗ (b ⊗ x)) : zipWith otimes as (map (⊗ x) bs)
 ===    <comment>{- 歸納假設 -}</comment>
      (a ⊗ (b ⊗ x)) : map (⊗ x) (zipWith otimes as bs)
 ===    <comment>{- <code class="haskell">otimes</code> 滿足結合律 -}</comment>
      ((a ⊗ b) ⊗ x) : map (⊗ x) (zipWith otimes as bs)
 ===    <comment>{- <code class="haskell">zipWith</code> 與 <code class="haskell">map</code> 之定義 -}</comment>
      map (⊗ x) (zipWith otimes (a:as) (b:bs)) 
</code></pre></div></div></div><h3 class="subsection" id="sec:exp-binary-roll">5.3.2 二進位表示法</h3><p>回顧第<a href="Induction-2.html#sec:induction-on-Nat">2.2 </a>節中的函數 <code class="haskell">exp</code>。該函數計算乘冪 --- $|exp b n| = b^n$，其定義如下:</p><pre><code class="spec">exp :: Nat -&gt; Nat -&gt; Nat
exp b Zero     = 1
exp b (Suc n)  = b *: exp b n 
</code></pre><p>以這個演算法計算 $b^n$ 時會需要 $O(n)$ 個乘法。是否有更快的做法呢？</p><p>我們先定義函數 <code class="haskell">binary :: Nat -&gt; List Bool</code>，可將一個自然數轉換成<em>反轉</em>的二進位表示法（即最低有效位在左邊，最高有效位在右邊）。以下我們將 <code class="haskell">False</code> 簡寫為 <code class="haskell">ff</code>, <code class="haskell">True</code> 簡寫為 <code class="haskell">tt</code>：</p><pre><code class="haskell">binary 0  = []
binary n  | even n  = ff : binary (n `div` 2)
          | odd n   = tt : binary (n `div` 2) 
</code></pre><p>例如，<code class="haskell">map binary [1,2,3,4] = [[tt], [ff,tt], [tt,tt], [ff,ff,tt]]</code>.
函數 <code class="haskell">binary</code> 在每次遞迴呼叫時將參數減半，因此 <code class="haskell">binary n</code> 只需要 $O(\log n)$ 的時間。
我們讓 <code class="haskell">binary</code> 傳回反轉的二進位數是為了方便定義 <code class="haskell">decimal :: List Bool -&gt; Nat</code> --- <code class="haskell">binary</code> 的反函數，將 <code class="haskell">binary</code> 的結果轉回成原有的數字：</p><pre><code class="haskell">decimal []      = 0
decimal (c:cs)  = if c then 1 + 2 * decimal cs else 2 * decimal cs 
</code></pre><p>我們可證明 <code class="haskell">decimal . binary = id</code>.</p><p>回到 <code class="haskell">exp</code>, 試計算如下</p><pre><code class="spec">   exp b
=    <comment>{- <code class="haskell">id</code> 為 <code class="haskell">(.)</code> 的單位元 -}</comment>
   exp b . id
=    <comment>{- <code class="haskell">decimal . binary = id</code> -}</comment>
   exp b . decimal . binary 
</code></pre><p>由於 <code class="haskell">binary n</code> 只需 $O(\log n)$ 的時間，如果我們能把 <code class="haskell">exp b . decimal</code> 的計算時間也縮減到 $O(\log n)$, 我們就有個只需對數時間的演算法了！</p><p>令 <code class="haskell">roll b = exp b . decimal</code>。顯然 <code class="haskell">roll b [] = 1</code>. 考慮輸入為 <code class="haskell">c:cs</code> 的情況，在以下的推導中，我們假設 $|exp b n| = b^n$ 擁有乘冪該有的各種算術性質：</p><pre><code class="haskell">    roll b (c:cs)
 ===    <comment>{- <code class="haskell">exp2</code> 與 <code class="haskell">decimal</code> 之定義  -}</comment>
    exp b (if c then 1 + 2 * decimal cs else 2 * decimal cs)
 ===    <comment>{- 函數分配進 <code class="haskell">if</code> -}</comment>
    if c then exp b (1 + 2 * decimal cs) else exp b (2 * decimal cs)
 ===    <comment>{- 算術：$b^{i + 2 \times x} = b^i \times {(b^x)}^2 $ -}</comment>
    if c then b * square (exp b (decimal cs)) else square (exp b (decimal cs))
 ===    <comment>{- <code class="haskell">roll</code> 之定義  -}</comment>
    if c then b * square (exp2 b cs) else square (roll b cs)
</code></pre><p>因此，我們推導出了在 $O(\log n)$ 時間內計算 $b^n$ 的程式如下：</p><pre><code class="spec">exp b = roll b . binary

roll b []      = 1
roll b (c:cs)  = if c then b * square (exp2 b cs) else square (exp2 b cs)
</code></pre><div class="exlist"><div class="exercise exer" id="binary-termination"><h5 class="exercise-title">練習 5.9 </h5><p>如何得知 <code class="haskell">binary</code> 會終止？它的定義用的是什麼歸納方式？</p></div><div class="exercise exer" id="ex:decimal-binary-id"><h5 class="exercise-title">練習 5.10 </h5><p>證明 <code class="haskell">decimal . binary = id</code>.</p></div><div class="exercise exer" id="ex:exp-roll-binary"><h5 class="exercise-title">練習 5.11 </h5><p>展開 <code class="haskell">exp b = roll b . binary</code> 以導出一個不產生中間串列的 <code class="haskell">exp</code> 定義。
這個定義用的是什麼歸納方式呢？</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-11" type="checkbox"/><label class="lbl-toggle" for="ans-5-11">顯示答案</label><div class="collapsible-content"><h5>答案</h5><pre><code class="haskell">exp b 0 = 1
exp b n  | even n  = square (exp b (n `div` 2))
         | odd n   = b * square (exp b (n `div` 2)) 
</code></pre><p>由於遞迴呼叫中的 <code class="haskell">n</code> 總是變小，本定義可視為 <code class="haskell">n</code> 之上的良基歸納。</p></div></div></div><h3 class="subsection" id="sec:wrap-reminder">5.3.3 小結與提醒</h3><p>如果回顧本節發生了什麼，該說：我們為 <code class="haskell">poly</code> 和 <code class="haskell">roll . decimal</code> 找出了歸納定義。
它們的效率因此提升了，但這只能說是<em>湊巧</em>：兩個演算中，都有些代數性質可運用，使得推導出的歸納定義在每一步需要做的工作不多，剛好是有效率的。</p><p>一般說來，歸納定義和效率提升不見得能畫上等號。導出了某函數的歸納定義後，仍需針對它做分析，才能知道這個推導是否值得。
有些情況下，推導出的程式有較好的時間複雜度，這樣的程式<em>通常</em>能表現得比原來的程式好。
有些情況下，找出歸納定義能消除中間串列，或著減少走訪資料結構的次數。
這時，導出的程式仍有同樣的時間複雜度，但<em>可能</em>有較小的常數。
此時需注意：本章談的僅是時間複雜度，而且只考慮一些特定運算元被使用的次數。
實際上的執行效率受到許多因素的影響，例如：不同運算元花費不同的時間；
空間的使用量也影響效率（例如，使用大量記憶體的程式可能需要較多次垃圾收集）；
某些演算法適合快取，等等。
我們在之後的章節中將看到一些歸納定義程式走訪資料結構的次數雖較少，但反而執行得慢的例子。</p><div class="exlist"><div class="exercise exer" id="sublist-choose"><h5 class="exercise-title">練習 5.12 </h5><p>回顧第 <a href="Induction-6.html#sec:fan-perm">2.6.4 </a> 節的 <code class="haskell">sublists</code>:</p><pre><code class="spec">sublists :: List a -&gt; List (List a)
sublists []      = [[]]
sublists (x:xs)  = sublists xs ++ map (x:) (sublists xs) 
</code></pre><p>定義</p><pre><code class="spec">choose :: Nat -&gt; List a -&gt; List (List a)
choose k = filter ((k ==) . length) . sublists 
</code></pre><p>使得 <code class="haskell">choose k xs</code> 傳回 <code class="haskell">xs</code> 的子串列中長度為 <code class="haskell">k</code> 者，例如 <code class="haskell">choose 3 "abcde" =</code> <code class="haskell">["cde","bde","bce","bcd","ade","ace",</code> <code class="haskell">"acd",</code> <code class="haskell">"abe",</code> <code class="haskell">"abd","abc"]</code>.
使用展開-收回轉換導出 <code class="haskell">choose</code> 的歸納定義。
<strong>提示</strong>: 依照 <code class="haskell">choose k xs</code> 的定義，我們會在 <code class="haskell">xs</code> 上做歸納。但此例之中，先對 <code class="haskell">k</code> 做歸納，再對 <code class="haskell">xs</code> 做歸納，得到的程式會比較精簡。</p></div><div class="wrap-collabsible"><input class="toggle" id="ans-5-12" type="checkbox"/><label class="lbl-toggle" for="ans-5-12">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>先對 <code class="haskell">k</code> 做歸納，再對 <code class="haskell">xs</code> 做歸納。我們只列出最複雜的情況：</p><p><strong>情況</strong> <code class="haskell">k := Suc k</code>, <code class="haskell">xs := x:xs</code>.</p><pre><code class="haskell">     choose (Suc k) (x:xs)
 ===   <comment>{- <code class="haskell">choose</code> 之定義 -}</comment>
     filter ((Suc k ==) . length') (sublists (x:xs))
 ===   <comment>{- <code class="haskell">sublists</code> 之定義 -}</comment>
     filter ((Suc k ==) . length') (sublists xs ++ map (x:) (sublists xs))
 ===   <comment>{- <code class="haskell">filter</code> 分配入 <code class="haskell">(++)</code> -}</comment>
     filter ((Suc k ==) . length') (sublists xs) ++
     filter ((Suc k ==) . length') (map (x:) (sublists xs))
 ===   <comment>{- <code class="haskell">choose</code> 之定義 -}</comment>
     choose (Suc k) xs ++
     filter ((Suc k ==) . length') (map (x:) (sublists xs))
 ===   <comment>{- 定理 \ref{thm:filter-map} -}</comment>
     choose (Suc k) xs ++
     map (x:) (filter ((Suc k ==) . length' . (x:)) (sublists xs))
 ===  <comment>{- <code class="haskell">(Suc k ==) . length' . (x:) = (k ==) . length'</code> -}</comment>
     choose (Suc k) xs ++
     map (x:) (filter ((k ==) . length') (sublists xs))
 ===  <comment>{- <code class="haskell">choose</code> 之定義 -}</comment>
     choose (Suc k) xs ++
     map (x:) (choose k xs) 
</code></pre><p>我們得到：</p><pre><code class="haskell">choose :: Nat -&gt; List a -&gt; List (List a)
choose Zero     xs      =  [[]]
choose (Suc k)  []      =  []
choose (Suc k)  (x:xs)  =  choose (Suc k) xs ++
                           map (x:) (choose k xs) 
</code></pre><p>確實是一般組合數學教材中會給的 $C^n_k$ 定義。</p></div></div></div></div><div class="navi"><div class="previous">&laquo;<a href="Derivation-2.html#sec:efficiency-basics">5.2 關於執行效率</a></div><div class="next"><a href="Derivation-4.html#sec:var-cons">5.4 變數換常數</a>&raquo;</div></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
