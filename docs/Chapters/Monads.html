<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="函數程設與推論">
    <title>函數程設與推論</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <!-- link rel="stylesheet" href="/css/pure/pure-min.css" -->

    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../css/styles.css">

    <script> MathJax = {
              loader: {
                load: ['input/tex-base', 'output/chtml']
                },
              tex: {
                inlineMath: [['$', '$']]
             }};
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/startup.js">
    </script>
</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
<div id="menu"><div class="pure-menu"><h1 class="pure-menu-heading">函數程設與推論</h1><h2 class="pure-menu-heading">Functional Program Construction and Reasoning</h2><p><a href="ToC.html">目錄</a></p><nav class="nav" role="navigation"><ul class="pure-menu-list menu-level-1"><li class="pure-menu-item"><a href="Introduction.html#ch:intro">0 符號、演算、與抽象化</a><input class="toggle" id="menu-li-0" type="checkbox"/><label class="menu-toggle" for="menu-li-0"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Introduction.html#sec:knight-knave-island">0.1 騎士與惡棍之島</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:let-symbols-work">0.2 讓符號為你工作</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction">0.3 抽象化</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:abstraction-and-expression">0.4 抽象化與表達力</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:correctness">0.5 正確性</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:calculable-programming-language">0.6 可演算的程式語言</a></li><li class="pure-menu-item"><a href="Introduction.html#sec:relevant-information">0.7 相關資料</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#ch:basics">1 值、函數、與定義</a><input class="toggle" id="menu-li-1" type="checkbox"/><label class="menu-toggle" for="menu-li-1"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:evaluation">1.1 值與求值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:function-defns">1.2 函數定義</a></li><li class="pure-menu-item"><a href="Basics.html#sec:higher-order-func">1.3 高階函數</a></li><li class="pure-menu-item"><a href="Basics.html#sec:func-comp">1.4 函數合成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lambda-terms">1.5 $\lambda$ 算式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:elementary-datatypes">1.6 簡單資料型態</a><input class="toggle" id="menu-li-1-6" type="checkbox"/><label class="menu-toggle" for="menu-li-1-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:boolean">1.6.1 布林值</a></li><li class="pure-menu-item"><a href="Basics.html#sec:char">1.6.2 字元</a></li><li class="pure-menu-item"><a href="Basics.html#sec:pairs">1.6.3 序對</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:weak-head-normal-form">1.7 弱首範式</a></li><li class="pure-menu-item"><a href="Basics.html#sec:lists">1.8 串列</a><input class="toggle" id="menu-li-1-8" type="checkbox"/><label class="menu-toggle" for="menu-li-1-8"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Basics.html#sec:list-deconstruct">1.8.1 串列解構</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-generation">1.8.2 串列生成</a></li><li class="pure-menu-item"><a href="Basics.html#sec:list-combinators">1.8.3 串列上的種種組件函數</a></li></ul></li><li class="pure-menu-item"><a href="Basics.html#sec:wholemeal">1.9 全麥編程</a></li><li class="pure-menu-item"><a href="Basics.html#sec:user-defined-data">1.10 自訂資料型別</a></li><li class="pure-menu-item"><a href="Basics.html#sec:refs-basics">1.11 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#ch:induction">2 歸納定義與證明</a><input class="toggle" id="menu-li-2" type="checkbox"/><label class="menu-toggle" for="menu-li-2"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:math-induction">2.1 數學歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-on-Nat">2.2 自然數上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:inductive-proof-on-Nat">2.3 自然數上之歸納證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists">2.4 串列與其歸納定義</a><input class="toggle" id="menu-li-2-4" type="checkbox"/><label class="menu-toggle" for="menu-li-2-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-defn">2.4.1 串列上之歸納定義</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-lists-proof">2.4.2 串列上之歸納證明</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:data-prog-proof">2.5 從資料、程式、到證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:more-inductive-defns">2.6 更多歸納定義與證明</a><input class="toggle" id="menu-li-2-6" type="checkbox"/><label class="menu-toggle" for="menu-li-2-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Induction.html#sec:filter-takeWhile-dropWhile">2.6.1 <code class="haskell">filter</code>, <code class="haskell">takeWhile</code>, 與 <code class="haskell">dropWhile</code></a></li><li class="pure-menu-item"><a href="Induction.html#sec:elem-neq-proof">2.6.2 <code class="haskell">elem</code> 與不等式證明</a></li><li class="pure-menu-item"><a href="Induction.html#sec:list-segments">2.6.3 串列區段</a></li><li class="pure-menu-item"><a href="Induction.html#sec:fan-perm">2.6.4 插入、排列、子串列、與劃分</a></li></ul></li><li class="pure-menu-item"><a href="Induction.html#sec:using-hints-from-symbols">2.7 再談「讓符號為你工作」</a></li><li class="pure-menu-item"><a href="Induction.html#sec:other-inductive-datatypes">2.8 其他歸納資料結構</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-set-theory">2.9 由集合論看歸納法</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-variations">2.10 歸納定義的簡單變化</a></li><li class="pure-menu-item"><a href="Induction.html#sec:complete-induction">2.11 完全歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:well-founded-induction">2.12 良基歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:lexicographic-induction">2.13 詞典序歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:mutual-induction">2.14 交互歸納</a></li><li class="pure-menu-item"><a href="Induction.html#sec:induction-ref">2.15 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SearchTrees.html#ch:induction-search-trees">3 搜尋樹</a><input class="toggle" id="menu-li-3" type="checkbox"/><label class="menu-toggle" for="menu-li-3"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-binary-search-tree">3.1 二元搜尋樹</a></li><li class="pure-menu-item"><a href="SearchTrees.html#sec:induction-red-black-tree">3.2 紅黑樹</a><input class="toggle" id="menu-li-3-2" type="checkbox"/><label class="menu-toggle" for="menu-li-3-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.1 紅黑樹插入</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.2 紅黑樹之性質：高度</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.3 紅黑樹之性質：平衡</a></li><li class="pure-menu-item"><a href="SearchTrees.html#">3.2.4 紅黑樹之性質：顏色</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Semantics.html#ch:semantics">4 關於語意的基本概念</a><input class="toggle" id="menu-li-4" type="checkbox"/><label class="menu-toggle" for="menu-li-4"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Semantics.html#sec:denotational-semantics">4.1 指稱語意</a></li><li class="pure-menu-item"><a href="Semantics.html#sec:operational-semantics">4.2 操作語意</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#ch:derivation">5 一般程式推導</a><input class="toggle" id="menu-li-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform">5.1 展開-收回轉換</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:efficiency-basics">5.2 關於執行效率</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:fold-unfold-transform-efficiency">5.3 用展開-收回轉換增進效率</a><input class="toggle" id="menu-li-5-3" type="checkbox"/><label class="menu-toggle" for="menu-li-5-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:poly-horner">5.3.1 計算多項式 -- Horner 法則</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:exp-binary-roll">5.3.2 二進位表示法</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:wrap-reminder">5.3.3 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:var-cons">5.4 變數換常數</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling">5.5 組對</a><input class="toggle" id="menu-li-5-5" type="checkbox"/><label class="menu-toggle" for="menu-li-5-5"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:steep">5.5.1 陡串列</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:repl-tree">5.5.2 以串列標記樹狀結構</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:rep-minE">5.5.3 代換為最小標籤 --- 循環程式</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tupling-conclude">5.5.4 小結與提醒</a></li></ul></li><li class="pure-menu-item"><a href="Derivation.html#sec:accumulating-param">5.6 累積參數</a><input class="toggle" id="menu-li-5-6" type="checkbox"/><label class="menu-toggle" for="menu-li-5-6"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Derivation.html#sec:reversal-append">5.6.1 串列反轉與連接</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:accum-info-flow">5.6.2 由上到下的資訊流</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion">5.6.3 尾遞迴</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-more">5.6.4 更多尾遞迴範例</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:tail-recursion-efficiency">5.6.5 尾遞迴的效率考量</a></li><li class="pure-menu-item"><a href="Derivation.html#sec:difference-list">5.6.6 函數作為串列</a></li></ul></li></ul></li><li class="pure-menu-item"><a href="Folds.html#ch:fold">6 摺</a><input class="toggle" id="menu-li-6" type="checkbox"/><label class="menu-toggle" for="menu-li-6"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:folds-on-lists">6.1 串列的摺</a><input class="toggle" id="menu-li-6-1" type="checkbox"/><label class="menu-toggle" for="menu-li-6-1"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:more-folds-on-lists">6.1.1 更多串列上的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:not-foldr">6.1.2 不是 <code class="haskell">foldr</code> 的函數</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion">6.2 摺融合定理</a><input class="toggle" id="menu-li-6-2" type="checkbox"/><label class="menu-toggle" for="menu-li-6-2"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldr-fusion-theorem-proof">6.2.1 將摺融合用於定理證明</a></li><li class="pure-menu-item"><a href="Folds.html#sec:foldr-program-gen">6.2.2 以摺融合生成程式</a></li><li class="pure-menu-item"><a href="Folds.html#sec:scan-lemma">6.2.3 掃描</a></li><li class="pure-menu-item"><a href="Folds.html#sec:banana-split">6.2.4 香蕉船定理</a></li><li class="pure-menu-item"><a href="Folds.html#sec:accum-param-fold-fusion">6.2.5 累積參數與摺融合</a></li><li class="pure-menu-item"><a href="Folds.html#sec:bring-in-context">6.2.6 引入脈絡</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldl-listHomo-para">6.3 左摺、串列同構、與 Paramorphism</a><input class="toggle" id="menu-li-6-3" type="checkbox"/><label class="menu-toggle" for="menu-li-6-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Folds.html#sec:foldl">6.3.1 左摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:list-homomorphism">6.3.2 串列同構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:paramorphism">6.3.3 Paramorphism 與本原遞迴</a></li></ul></li><li class="pure-menu-item"><a href="Folds.html#sec:foldN">6.4 自然數的摺</a></li><li class="pure-menu-item"><a href="Folds.html#sec:fold-on-other-data-structures">6.5 其他資料結構</a></li><li class="pure-menu-item"><a href="Folds.html#sec:folds-ref">6.6 參考資料</a></li></ul></li><li class="pure-menu-item"><a href="SegProblems.html#ch:segment-problems">7 區段問題</a><input class="toggle" id="menu-li-7" type="checkbox"/><label class="menu-toggle" for="menu-li-7"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-segment-sum">7.1 最大區段和</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:maximum-plateau-length">7.2 最長高原問題</a></li><li class="pure-menu-item"><a href="SegProblems.html#sec:segProblems-ref">7.3 參考資料</a></li></ul></li><li class="pure-menu-selected pure-menu-item"><a href="#ch:monads">8 單子與副作用</a><input class="toggle" id="menu-li-8" checked type="checkbox"/><label class="menu-toggle" for="menu-li-8"></label><ul class="pure-menu-list menu-level-2 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:exceptions">8.1 例外處理</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-class-laws">8.2 單子與單子律</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader">8.3 讀取單子</a><input class="toggle" id="menu-li-8-3" type="checkbox"/><label class="menu-toggle" for="menu-li-8-3"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:var-env-reader">8.3.1 變數與環境</a></li><li class="pure-menu-item"><a href="Monads.html#sec:reader-is-monad">8.3.2 「讀取」副作用是單子</a></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#sec:monad-state">8.4 狀態單子</a><input class="toggle" id="menu-li-8-4" type="checkbox"/><label class="menu-toggle" for="menu-li-8-4"></label><ul class="pure-menu-list menu-level-3 collapsible-menu"><li class="pure-menu-item"><a href="Monads.html#sec:hanoi">8.4.1 河內塔問題</a></li></ul></li><li class="pure-menu-item"><a href="Monads.html#">8.5 參考資料</a></li></ul></li></ul></nav><p><a href="Ix.html">索引</a></p><p><a href="Biblio.html">參考書目</a></p><p class="author-info"><a href="https://  homepage.iis.sinica.edu.tw/pages/scm/">穆信成 Shin-Cheng Mu</a><br/>中央研究院 資訊科學研究所</p></div></div><div id="main"><div class="header"><h1 class="chapter" id="ch:monads">8 單子與副作用</h1></div><div class="content"><p>從純函數語言的觀點而言，程式是函數，而函數的「本分」是把一個輸入值對應到一個輸出值，除此之外發生的都是<em>副作用</em>(side effects)<span id="ix-8-1"></span>。&shy;一個程式執行時若可能改變某個<em>可變變數</em>(<em>mutable variable</em>)的值，是一種副作用 --- 這可能是大家最耳熟能詳的例子。<input class="toggle" id="footnote-8-0-1" type="checkbox"/><label class="fnote-toggle" for="footnote-8-0-1">(註1) </label><span class="collapsible-footnote">在數學式或函數語言程式中，例如 <code class="haskell">x + 2*y + 1</code>, 其中的 <code class="haskell">x</code> 和 <code class="haskell">y</code> 被稱為 ``variables''，譯為「變數」。這名稱的由來是：相對於 <code class="haskell">1</code>, <code class="haskell">2</code> 等等常數，「變數」的值被其所屬環境而決定。但在同一個環境與範圍(scope)中，一個變數仍代表同一個值。&shy;命令式語言中的「變數」則是存放值的容器，我們可使用賦值(assignment)指令改變變數中的值。為了區分，我們把後者這種能被賦值而改變內容的變數稱作「可變變數(mutable variables)」。</span>&shy;此外，讀寫檔案、抓滑鼠的位置、往螢幕寫東西、和系統問現在的日期時間、取亂數等等，也是副作用。&shy;程式若拋出例外(exception)、不傳回值了，是一種副作用。&shy;一個程式若有不止一個可能的傳回值（程式員無法預測是哪一個），也是一種副作用。&shy;在更嚴格的定義中，一個程式如果進入無窮迴圈而不終止（因此不傳回值），也可視為副作用。</p><p>許多程式設計典範都大量依靠副作用完成各種工作：更新變數、輸出入、用例外處理執行時間遇到的錯誤...。&shy;在大家的一般印象中，純函數語言反其道而行，其特徵就是「不能有副作用」。&shy;但這其實是個過度簡化的說法。&shy;實情正好相反：純函數語言不僅允許副作用，甚至允許多種副作用並存，並且可把一個程式所被允許的副作用標示在其型別中。&shy;只是，副作用也必須被納入嚴謹的數學架構中。&shy;在純函數語言中，我們需好好地談每個副作用到底「是什麼」（即其語意為何），滿足哪些性質，而這些性質便可用來推論含副作用的程式的正確性。</p><p>例如，「拋出例外(exception)」<span id="ix-8-2"></span>算是一種副作用。&shy;如果我們定義如下的型別：</p><pre><code class="spec">data Except b = Exception String | Return b 

</code></pre><p>那麼一個正常終止時傳回型別為 <code class="haskell">b</code> 的值、但也有可能拋一個例外（並附帶一個字串錯誤訊息）的程式可視為一個值域為 <code class="haskell">Except b</code> 的全函數 --- 正常終止時傳回 <code class="haskell">Return x</code>, 「拋出例外」則可用傳回 <code class="haskell">Exception msg</code> 來模擬。&shy;有多個可能傳回值（型別均為<code class="haskell">b</code>）的程式可視為值域為 <code class="haskell">Set b</code> 的全函數 --- 所有可能的回傳值都被收集在集合之中。&shy;假設有一個型別為 <code class="haskell">s</code> 的可變變數，那麼一個執行完畢後會傳回 <code class="haskell">b</code>、但可能改變該可變變數的程式可以視為一個型別為 <code class="haskell">s -&gt; (b, s)</code> 的函數 --- 輸入的 <code class="haskell">s</code> 為該可變變數的初始值，輸出的序對中，<code class="haskell">b</code> 是程式的結果，<code class="haskell">s</code> 是可變變數的新值。例如，當 <code class="haskell">s</code> 為 <code class="haskell">Int</code>, 一個傳回該可變變數的現有值、並同時將變數加一的「指令」可表示成一個函數 <code class="haskell">\s -&gt; (s, 1+s)</code>.</p><p>如此一來，我們可在純函數語言中實作出許多種副作用。&shy;這可能和讀者心目中的「實作」相當不同 ---&shy;此處的「將可變變數加一」並沒有真正去修改原記憶體位置中的值，而是產生了一個新值；&shy;「拋例外」並未採用高效率的實作（例如到系統堆疊中把回傳位置一個個 pop 出來），而和一般函數一樣，只是傳回一個資料結構。&shy;但我們可把前述這些較有效率的做法當作交給編譯器做的最佳化 --- 當編譯器看到傳回 <code class="haskell">Except b</code> 的函數，或著看到 <code class="haskell">s -&gt; (b, s)</code> 這樣的函數，可自己想辦法去找有效率的編譯方式。<input class="toggle" id="footnote-8-0-2" type="checkbox"/><label class="fnote-toggle" for="footnote-8-0-2">(註2) </label><span class="collapsible-footnote">實務上這相當不容易...TODO</span>&shy;身為程式員，我們在乎的是將「會拋例外的程式其實是什麼？會修改可變變數的程式其實是什麼？」給描述出來。</p><p>另一個可能令讀者困擾的是：這樣寫程式實在不方便。一個使用 <code class="haskell">Except</code> 的程式可能得有許多 <code class="haskell">case</code> 將子程式的結果配對拆開。一個程式若由許多型別為 <code class="haskell">s -&gt; (b, s)</code> 的組成，得手動將序對配對，將輸入與輸出的 <code class="haskell">s</code> 傳來傳去。&shy;這些做法都太低階，我們希望能在抽象一點的層次上工作，方便我們寫程式、讓我們能做抽象些的思考。&shy;這個抽象概念必須能適用於種種副作用，抓出這些副作用的共同模式。</p><p>在 Haskell 中，描述副作用最常用的抽象概念是<em>單子</em>(<em>monad</em>)。<span id="ix-8-3"></span>&shy;大家常認為單子是學習函數語言碰上的第一個難關。&shy;希望讀者讀完本章後，會發現它其實沒那麼難。&shy;一般談單子的方式是由下往上的：由例外、可變變數等等特例的實作開始，歸納出這些特例的共同模式，使讀者可發現引出單子這個概念的動機。&shy;從第 <a href="Monads.html#sec:exceptions">8.1 </a> 節開始，我們也將由這種觀點出發解說單子。&shy;但也有另一種由上而下的看法：先討論單子與每個副作用的運算子該滿足什麼性質，才談他們可怎麼實作。我們認為這種看法一樣重要。</p><p><b>例：簡單算式求值</b> &emsp;&shy;以下的資料結構 <code class="haskell">Expr</code> 表達一個只有整數、負號、和加法的數學式：</p><pre><code class="spec">data Expr = Num Int | Neg Expr | Add Expr Expr 
</code></pre><p>例如 <code class="haskell">-3 + 4</code> 可表達為 <code class="haskell">Add (Neg (Num 3)) (Num 4)</code>.&shy;我們可輕易寫一個歸納定義，將一個 <code class="haskell">Expr</code> 計算成一個整數：</p><pre><code class="spec">eval :: Expr -&gt; Int
eval (Num n)      = nw
eval (Neg e)      = - (eval e)
eval (Add e0 e1)  = eval e0 + eval e1 
</code></pre><p>看來這是個再單純也不過的純函數。但只要我們稍加擴充這個數學式型別，情況就變複雜了。&shy;如果數學式有除法，分母為零時 <code class="haskell">eval</code> 就得拋出例外；&shy;我們可以為數學式加入變數，那麼 <code class="haskell">eval</code> 碰到變數時得查閱該變數的值；&shy;我們也許想要用一個可變變數幫我們記住 <code class="haskell">eval</code> 做了多少次加法。&shy;程式只要稍微變複雜，我們就會開始需要許多種副作用。</p><p>我們將用這個例子介紹單子。在接下來的幾個章節中，我們將以不同的方式擴充 <code class="haskell">Expr</code> 型別以及 <code class="haskell">eval</code> 函。&shy;每個擴充需要不同的副作用。&shy;我們將由如何模擬出副作用為動機出發，介紹單子的概念。&shy;引入單子這種抽象化後，我們會發現我們只需改用不同的單子，就可以在不太改變 <code class="haskell">eval</code> 的主要程式的情況下，為 <code class="haskell">eval</code> 加入新的副作用。&shy;因此單子可以視為模組化地加入副作用的方法</p><h2 class="section" id="sec:exceptions">8.1 例外處理</h2><p><span id="ix-8-4"></span></p><p>假設我們添了一個整數除法運算元：</p><pre><code class="spec">data Expr = Num Int | Neg Expr | Add Expr Expr | Div Expr Expr  
</code></pre><p>我們便碰到了一個小難題：要怎麼處理分母是零的狀況呢？</p><p>Haskell 的 <code class="haskell">div</code> 函數可做整數除法。碰到分母為零時，<code class="haskell">div</code> 和大部分語言的除法函數一樣讓整個程式當掉。我們不希望程式當掉，因此得在呼叫 <code class="haskell">div</code> 前先檢查一下分母是否為零。但當分母真為零，<code class="haskell">eval</code> 應該傳回什麼呢？</p><pre><code class="spec">eval (Div e0 e1) =  let v1 = eval e1
                    in if v1 /= 0 then eval e0 `div` v1 else ???
</code></pre><p><b>用 |Maybe| 表達部份函數</b> &emsp;&shy;一種看法是，有了除法後，<code class="haskell">eval</code> 對於某些輸入沒有對應的值，因此 <code class="haskell">eval</code> 成了一個部份 (partial) 函數。<span id="ix-8-5"></span></p><p>操作上，我們希望 Haskell 提供拋出例外的功能，<code class="haskell">eval</code> 無值可傳的時候便拋出例外。在程式的另外某處可能接住這些例外，另行處理。&shy;本章開頭提及，一個傳回 <code class="haskell">Int</code>、但可能拋出例外的函數可用傳回 <code class="haskell">Except Int</code> 的全函數來模擬。<code class="haskell">Except</code> 再給一次如下：</p><pre><code class="spec">data Except b = Expt String | Return b 

</code></pre><p>我們把 <code class="haskell">eval</code> 的型別改為 <code class="haskell">Expr -&gt; Except Int</code>, 正常運算結束便傳回 <code class="haskell">Return</code>, 碰到分母為零的情形則傳回 <code class="haskell">Expt</code>.</p><p>這個版本的 <code class="haskell">eval</code> 該怎麼寫呢？碰到 <code class="haskell">Num n</code> 自然是傳回 <code class="haskell">Return n</code>:</p><pre><code class="spec">eval (Num n) = Return n 
</code></pre><p>處理 <code class="haskell">Neg e</code> 的條款則比以前稍微複雜了。我們得檢查 <code class="haskell">eval e</code> 的結果，若是 <code class="haskell">Return v</code>，應傳回 <code class="haskell">-v</code>，但也需包上一個 <code class="haskell">Return</code>. 如果遇到 <code class="haskell">Expt msg</code>, 表示 <code class="haskell">e</code> 的運算失敗了，我們只好把 <code class="haskell">Expt msg</code> 再往上傳。</p><pre><code class="spec">eval (Neg e) =  case eval e of
                  Return v  -&gt; Return (-v)
                  Expt msg  -&gt; Expt msg  
</code></pre><p><code class="haskell">Add</code> 的情況下，程式碼看來更冗長了些：</p><pre><code class="spec">eval (Add e0 e1) =  case eval e0 of
                     Return v0  -&gt;  case eval e1 of
                                      Return v1  -&gt; Return (v0 + v1)
                                      Expt msg   -&gt; Expt msg
                     Expt msg   -&gt;  Expt msg  
</code></pre><p>我們得分別檢查 <code class="haskell">eval e0</code> 與 <code class="haskell">eval e1</code> 的結果是 <code class="haskell">Return</code> 或是 <code class="haskell">Expt</code>，因此用兩層 <code class="haskell">case</code> 分出了四個狀況 --- 雖然它們是重複性很高的程式碼。&shy;最後是 <code class="haskell">Div e0 e1</code> 的情況，我們先計算 <code class="haskell">e1</code>, 如果是零的話傳回 <code class="haskell">Expt</code>, 含錯誤訊息 <code class="haskell">"division by zero"</code>, 否則做除法運算。&shy;在這過程中我們也需要許多 <code class="haskell">case</code> ：</p><pre><code class="spec">eval (Div e0 e1) =  case eval e1 of
                     Return 0   -&gt;  Expt "division by zero"
                     Return v1  -&gt;  case eval e0 of
                                      Return v0  -&gt; Return (v0 `div` v1)
                                      Expt msg   -&gt; Expt msg
                     Expt msg   -&gt;  Expt msg  
</code></pre><p>很自然地，我們會希望把這些例行公事抽象掉。</p><p><b>|Except| 作為單子</b> &emsp;&shy;再看一次處理 <code class="haskell">Neg</code> 的條款：</p><pre><code class="spec">eval (Neg e) =  case eval e of
                  Return v  -&gt; Return (-v)
                  Expt msg  -&gt; Expt msg 
</code></pre><p>我們真正想表達的僅是「把 <code class="haskell">eval e</code> 的結果送給 <code class="haskell">\v -&gt; Return (-v)</code> --- 如果有結果的話」。這只是多加了一點手續的函數應用 (application)。回想 Haskell 有個函數應用運算元<code class="haskell">($) :: (a -&gt; b) -&gt; a -&gt; b</code>.&shy;給定 <code class="haskell">f :: a -&gt; b</code> 和 <code class="haskell">x :: a</code>, 那麼 <code class="haskell">f $ x</code> 就是把 <code class="haskell">x</code> 餵給 <code class="haskell">f</code>（也就是 <code class="haskell">f x</code>）。&shy;也許我們可以自己定義一個函數應用運算元 <code class="haskell">(=&lt;&lt;)</code>. 概念上，<code class="haskell">f =&lt;&lt; x</code> 仍是把 <code class="haskell">x</code> 餵給 <code class="haskell">f</code>，但 <code class="haskell">x</code> 的型別是 <code class="haskell">Except a</code>, <code class="haskell">f</code> 的型別是 <code class="haskell">a -&gt; Except b</code>, 而「檢查 <code class="haskell">x</code> 是 <code class="haskell">Return</code> 或 <code class="haskell">Expt</code>」的動作就可藏在 <code class="haskell">(=&lt;&lt;)</code> 之中（讀者可把 <code class="haskell">(=&lt;&lt;)</code> 的型別和 <code class="haskell">($)</code> 做比較）：</p><pre><code class="spec">(=&lt;&lt;) :: (a -&gt; Except b) -&gt; Except a -&gt; Except b
f =&lt;&lt; Return x  = f x
f =&lt;&lt; Expt msg  = Expt msg 
</code></pre><p>如此一來，<code class="haskell">eval (Neg e)</code> 的條款可簡潔地寫成：</p><pre><code class="spec">eval (Neg e) = (\v -&gt; Return (-v)) =&lt;&lt; eval e  

</code></pre><p> 如果定義 <code class="haskell">negate x = -x</code>, 上式的右手邊可以更簡潔地寫成 <code class="haskell">Return . negate =&lt;&lt; eval e</code>.</p><p>但，目前較常見的習慣是把這個運算子的左右顛倒：參數寫前面，函數寫後面。也就是定義:</p><pre><code class="spec">(&gt;&gt;=) : Except a -&gt; (a -&gt; Except b) -&gt; Except b
Just x   &gt;&gt;= f = f x
Nothing  &gt;&gt;= f = Nothing 
</code></pre><p>運算子 <code class="haskell">(&gt;&gt;=)</code> 唸作 ``bind'', 是我們將會細談的重要元素。&shy;有了它，函數 <code class="haskell">eval</code> 的前兩個條款可以改寫如下：</p><pre><code class="spec">eval (Num n)  = return n
eval (Neg e)  = eval e &gt;&gt;= \v -&gt; return (-v) 
</code></pre><p>我們把 <code class="haskell">Return</code> 寫成函數：<code class="haskell">return = Return</code>。等下會解釋為什麼。&shy;注意：依照 Haskell 的運算元優先順序，&shy;<code class="haskell">m &gt;&gt;= \v -&gt; e</code> 會被理解成 <code class="haskell">m &gt;&gt;= (\v -&gt; e)</code>.&shy;<code class="haskell">Add</code> 和 <code class="haskell">Div</code> 的情況也可以用 <code class="haskell">(&gt;&gt;=)</code> 改寫:</p><pre><code class="spec">eval (Add e0 e1) =  eval e0  &gt;&gt;= \v0 -&gt;
                    eval e1  &gt;&gt;= \v1 -&gt;
                    return (v0 + v1)
eval (Div e0 e1) =  eval e1  &gt;&gt;= \v1 -&gt;
                    if v1 == 0 then throw "division by zero"
                    else  eval e0 &gt;&gt;= \v0 -&gt;
                          return (v0 `div` v1) 
</code></pre><p>此處我們把 <code class="haskell">Expt</code> 寫成 <code class="haskell">throw</code>.</p><p>如此一來，我們的程式變得簡短了一些。例如，<code class="haskell">eval (Add e0 e1)</code> 直覺上彷彿在說「把 <code class="haskell">eval e0</code> 的結果叫做 <code class="haskell">v0</code>, <code class="haskell">eval e1</code> 的結果叫做 <code class="haskell">v1</code>, 然後傳回 <code class="haskell">v0 + v1</code>」，至於判斷 <code class="haskell">eval e0</code> 與 <code class="haskell">eval v1</code> 到底是 <code class="haskell">Return</code> 還是 <code class="haskell">Expt</code> 的動作則藏在 <code class="haskell">(&gt;&gt;=)</code> 之中了。&shy;但引入 <code class="haskell">(&gt;&gt;=)</code> 這個抽象的用意並不只是把程式變短，而是可推廣到其他的副作用之上。這將是接下來幾小節的主題。</p><p>提醒一下：&shy;有些讀者可能認為 <code class="haskell">eval</code> 的後兩個條款看來像命令式語言：<code class="haskell">eval e1 &gt;&gt;= \v1 -&gt; ..</code> 看來就像是 <code class="haskell">v1 := eval e1</code> --- 把 <code class="haskell">eval e1</code> 的值寫到 <code class="haskell">v1</code> 中。&shy;但其實 <code class="haskell">(&gt;&gt;=)</code> 並沒有賦值（改變變數現有的值）之意，要做比較的話，它更像是增強版的 <code class="haskell">let</code>.&shy;算式 <code class="haskell">p &gt;&gt;= \x -&gt; e</code> 就像是 <code class="haskell">let x = p in e</code>.&shy;兩者都是「把 <code class="haskell">p</code> 的值算出，給予一個名字 <code class="haskell">x</code>, 然後計算 <code class="haskell">e</code>」。&shy;差別則是：</p><ul><li><p><code class="haskell">let</code> 處理純的值：在 <code class="haskell">let x = p in e</code> 之中，如果 <code class="haskell">p</code> 的型別是 <code class="haskell">a</code>, <code class="haskell">x</code> 的型別也是 <code class="haskell">a</code>; 算式 <code class="haskell">e</code> 的型別若是 <code class="haskell">b</code>, 整個式子的型別也是 <code class="haskell">b</code>; <code class="haskell">e</code> 的型別相同。</p></li><li><p><code class="haskell">(&gt;&gt;=)</code> 處理含有 <code class="haskell">Except</code> 的值：在 <code class="haskell">p &gt;&gt;= \x -&gt; e</code> 之中，</p><ul><li><p><code class="haskell">p</code> 的型別得有 <code class="haskell">Except</code>. 如果 <code class="haskell">p</code> 的型別是 <code class="haskell">Except a</code>, 則 <code class="haskell">x</code> 的型別是 <code class="haskell">a</code>;</p></li><li><p><code class="haskell">e</code> 的型別得有 <code class="haskell">Except</code>. 如果 <code class="haskell">e</code> 的型別是 <code class="haskell">Except b</code>, 整個式子的型別也是 <code class="haskell">Except b</code>.</p></li><li><p>因此 <code class="haskell">\x -&gt; e</code> 是一個型別為 <code class="haskell">a -&gt; Except b</code> 的函數。</p></li></ul></li></ul><p><b>捕捉例外</b> &emsp;&shy;最後，我們可以定義一個捕捉例外的運算子。算式 <code class="haskell">catch p hdl</code> 嘗試配對 <code class="haskell">p</code> 的值，&shy;如果是 <code class="haskell">Return x</code>, 就傳回結果 <code class="haskell">x</code>；如果是 <code class="haskell">Expt msg</code>, 就把錯誤訊息 <code class="haskell">msg</code> 交給例外處理函數 <code class="haskell">hdl</code>。&shy;當 <code class="haskell">p</code> 的型別是 <code class="haskell">Except a</code>, <code class="haskell">catch p hdl</code> 的型別也是 <code class="haskell">a</code>, 而 <code class="haskell">hdl</code> 的型別必須是 <code class="haskell">String -&gt; a</code>:</p><pre><code class="spec">catch :: Except a -&gt; (String -&gt; a) -&gt; a
catch (Return x)  hdl = x
catch (Expt msg)  hdl = hdl msg 
</code></pre><p>例如，下式嘗試計算 <code class="haskell">e</code> 並把結果轉成字串。如果 <code class="haskell">e</code> 能正常計算，字串會是 <code class="haskell">"Result:"</code> 開頭，否則是 <code class="haskell">"Error:"</code> 開頭：</p><pre><code class="spec">   catch (eval e)  (\v -&gt; "Result: " ++ show v)
                   (\msg -&gt; "Error: " ++ msg)  
</code></pre><p>下式則無論如何都傳回 <code class="haskell">Int</code>, 如果 <code class="haskell">e</code> 之中出現了分母為零的除法，我們便傳回 <code class="haskell">65536</code>:</p><pre><code class="spec">   catch (eval e) id (const 65536) 
</code></pre><h2 class="section" id="sec:monad-class-laws">8.2 單子與單子律</h2><p>第 <a href="Introduction.html#ch:intro">0 </a> 章提及，「抽象化」意指抽取出一個問題中最關鍵的元素。&shy;一個成功的抽象化能抓到同類問題的共通本質，因此可以推廣到其他相關的情境、問題，用同一套方法表達這些情境、解決這些問題。&shy;我們在第 <a href="Monads.html#sec:exceptions">8.1 </a> 節發現的便是一個關於計算與副作用的成功抽象化。</p><p>我們可以把第 <a href="Monads.html#sec:exceptions">8.1 </a> 節中的 <code class="haskell">Except a</code> 理解成一個 <em>尚待完成的計算</em>，或是一個<em>尚待執行的程式</em>。&shy;用 <code class="haskell">case</code> 去配對它便是把這個計算算出來、把程式執行出來。&shy;如果順利執行，計算結果的型別為 <code class="haskell">a</code>, 但也可能產生副作用。&shy;而由其型別建構子 <code class="haskell">Except</code> 可看出此處可能的副作用是「可能拋出例外」。&shy;運算子 <code class="haskell">(&gt;&gt;=)</code> 的功用是將小計算/程式串接起來，組成較大的計算/程式。</p><p>推廣出去，<code class="haskell">Except</code> 其實可以是任意一個型別建構元 <code class="haskell">m</code>: 一個型別為 <code class="haskell">m a</code> 的值表示一個尚待完成的計算，或是一個尚待執行的程式。如果順利執行，計算結果的型別為 <code class="haskell">a</code>, 但執行過程中可能產生副作用。&shy;至於究竟是什麼副作用，則看 <code class="haskell">m</code> 是什麼而定。&shy;此外，每個 <code class="haskell">m</code> 附帶兩個運算子：</p><ul><li><p><code class="haskell">return :: a -&gt; m a</code>;</p></li><li><p><code class="haskell">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code>.</p></li></ul><p>它們三者合稱為一個<em>單子</em>(<em>monad</em>).<span id="ix-8-6"></span></p><p>給任一個值 <code class="haskell">x :: a</code>, 運算子 <code class="haskell">return x</code> 代表一個純粹傳回 <code class="haskell">x</code>, 沒有副作用的計算。以 <code class="haskell">m = Except</code> 為例，自然的選擇是令 <code class="haskell">return = Return</code>. 我們之後會看到其他例子。</p><p>運算子 <code class="haskell">(&gt;&gt;=)</code> 將小計算串接在一起。&shy;在 <code class="haskell">p &gt;&gt;= f</code> 之中，<code class="haskell">p :: m a</code> 是一個回傳型別將為 <code class="haskell">a</code>, 但可能有副作用的計算。&shy;如果 <code class="haskell">p</code> 被算出來，其結果會被傳給 <code class="haskell">f</code>.&shy;函數 <code class="haskell">f :: a -&gt; m b</code> 是一個拿到 <code class="haskell">p</code> 的結果後<em>算出一個計算的計算</em>.&shy;整個式子 <code class="haskell">p &gt;&gt;= f</code> 的型別也是 <code class="haskell">m b</code>.&shy;這是理解單子程式的一個重點：函數本身沒有副作用，但<em>函數可以算出含有副作用的程式</em>。&shy;如果我們把 <code class="haskell">f</code> 寫成 $\lambda$ 表示式，&shy;在 <code class="haskell">p &gt;&gt;= \x -&gt; e</code> 之中，<code class="haskell">p</code> 的結果被取名為 <code class="haskell">x</code>，而 <code class="haskell">e :: m b</code> 之中可以使用 <code class="haskell">x</code>.&shy;此處 <code class="haskell">(&gt;&gt;=)</code> 可理解成由兩個小計算 <code class="haskell">p</code> 與 <code class="haskell">e</code> 組出一個大計算的接著劑，兩個小計算用 <code class="haskell">x</code> 來溝通。</p><p>運算子 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 是用來組合出含有副作用的程式的元件，因此得滿足一些該有的性質。正式說來，</p><div class="theorem" id="def:monad" title="單子"><h5 class="theorem-title">定義 8.1  單子 </h5><p>一個單子(monad)<span id="ix-8-7"></span>包含一個型別建構子 <code class="haskell">m</code>,&shy;以及兩個運算子 <code class="haskell">return :: a -&gt; m a</code> 與 <code class="haskell">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code>. 它們須滿足以下三條<em>單子律</em>：<span id="ix-8-8"></span></p><div class="equations"><ul><li><p id="eq:monad-right-id"><b>右單位律(right identity): </b> &emsp;&shy;<code class="haskell">p &gt;&gt;= return  </code> <code class="haskell">=  p </code></p></li><li><p id="eq:monad-left-id"><b>左單位律(left identity): </b> &emsp;&shy;<code class="haskell">return x &gt;&gt;= f  </code> <code class="haskell">=  f x </code></p></li><li><p id="eq:monad-assoc"><b>結合律(associativity): </b> &emsp;&shy;<code class="haskell">(p &gt;&gt;= f) &gt;&gt;= g  </code> <code class="haskell">=  p &gt;&gt;= (\x -&gt; f x &gt;&gt;= g) </code></p></li></ul></div></div><p><em>右單位律</em>若寫成 <code class="haskell">p &gt;&gt;= \x -&gt; return x</code> 也許更好理解。計算 <code class="haskell">p</code> 的結果 <code class="haskell">x</code> 被傳到 <code class="haskell">(&gt;&gt;=)</code> 的右邊，但後者只是單純地把 <code class="haskell">x</code> 再傳出。這和只寫 <code class="haskell">p</code> 得是一樣的。</p><p>在<em>左單位律</em>的左手邊 <code class="haskell">return x &gt;&gt;= f</code> 之中，函數 <code class="haskell">f</code> 接收 <code class="haskell">return x</code> 的結果 --- 而 <code class="haskell">return x</code> 的結果就是 <code class="haskell">x</code>! 因此這和 <code class="haskell">f x</code> 得是一樣的。</p><p>最後一條是 <code class="haskell">(&gt;&gt;=)</code> 的<em>結合律</em>：「用 <code class="haskell">p</code> 與 <code class="haskell">f</code> 串接出一個程式，再把 <code class="haskell">g</code> 串接到右邊」與「把 <code class="haskell">f</code> 與 <code class="haskell">g</code> 串接在一起，並把 <code class="haskell">p</code> 串接在它們左邊」得到的必須是一樣的程式。&shy;但由於型別的問題，在後者的情況我們需要一個 <code class="haskell">x</code> 表示 <code class="haskell">p</code> 的結果，前者則不用。</p><p>每定義一個新的單子，我們需選定一個型別 <code class="haskell">m</code>，定義 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 兩個運算子，然後證明它們滿足單子律。需要推論含單子的程式的性質與正確性時，這三條單子律也是我們會用到的性質。</p><p>最後一提：定義 <a href="Monads.html#def:monad">8.1 </a> 並不是單子的唯一定義方式。其他等價的定義詳見 \todo{where}.</p><div class="exlist"><div class="exercise exer"><h5 class="exercise-title">練習 8.1 </h5><p>證明第 <a href="Monads.html#sec:exceptions">8.1 </a> 節中的定義滿足單子律。&shy;意即當 <code class="haskell">m = Except</code>, <code class="haskell">return = Return</code>, 而 <code class="haskell">(&gt;&gt;=)</code> 的定義如第 <a href="Monads.html#sec:exceptions">8.1 </a> 節所示時，三條單子律都成立。</p></div></div><p><b>單子 class</b> &emsp;&shy;既然 Haskell 有 type class 機制，我們可以把單子定義為一個 class:</p><pre><code class="spec">class Monad m where
  return  :: a -&gt; m a
  (&gt;&gt;=)   :: m a -&gt; (a -&gt; m b) -&gt; m b 
</code></pre><p>如此明確規定一個屬於 <code class="haskell">Monad</code> 的型別建構子必須有 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code>.&shy;<code class="haskell">Except</code> 型別則是其中的一個特例：</p><pre><code class="spec">instance Monad Except where
   return           = Return
   Expt msg  &gt;&gt;= f  = Expt msg
   Return x  &gt;&gt;= f  = f x 
</code></pre><p>之後我們討論其他的 <code class="haskell">m</code> 時，也將把它們宣告為 <code class="haskell">Monad</code> 的特例。&shy;但這麼做只是為了兩個方便性：1. 讓不同的 <code class="haskell">m</code> 可以共用 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 兩個符號，不用重新取名；2. 看到使用 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 的程式時，可以暫時不指定它們到底使用那一個特例。&shy;若非為了這些小方便，單子與 type class 不一定得有關聯。</p><p>此外，Haskell 中的 type class 宣告也只保證 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 的型別是正確的。&shy;目前 Haskell 並無法保證使用者定義的 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 滿足前述的單子律。</p><p><b>副作用特定的運算子</b> &emsp;&shy;不知讀者是否想起：那麼 <code class="haskell">throw</code> 與 <code class="haskell">catch</code> 呢？&shy;他們也應該滿足一些性質，例如，<code class="haskell">throw msg &gt;&gt;= f = throw msg</code> （拋出例外後，後面的 <code class="haskell">f</code> 不會執行）和 <code class="haskell">catch (throw msg) hdl = hdl msg</code> （<code class="haskell">throw</code> 拋出的例外由 <code class="haskell">hdl</code> 處理）應該都是合理以及必要的性質。&shy;另一方面，它們是屬於「例外」這個副作用的運算子，其他的副作用並不見得會有它們。&shy;反之，別的副作用可能會有該副作用的特定運算子。例如，要談可變變數，可能會有個賦值運算子，這是 <code class="haskell">Except</code> 沒有的。</p><p>由此得知，用於表達副作用時，單子的運算子可分為兩大類：1. <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 是各個副作用共通的，&shy;每個單子都必須定義 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code>, 並確保它們滿足單子律。2. 此外，每個副作用還可能擁有特有的運算子，它們可能也有些該滿足的性質。&shy;我們將在介紹各個副作用的小節中看到更多例子。</p><h2 class="section" id="sec:monad-reader">8.3 讀取單子</h2><p><span id="ix-8-9"></span></p><p>為了進入下一個例子，我們為算式型別加上變數：</p><pre><code class="spec">data Expr =  Num Int | Neg Expr | Add Expr Expr |
             Var Name | Let Var Expr Expr 

type Name = String 
</code></pre><p><code class="haskell">Name</code> 是變數名稱，<code class="haskell">Var v</code> 是出現在算式中的變數，<code class="haskell">Let</code> 則用來宣告新的區域變數。&shy;例如，以下式子表達的是 <code class="haskell">let x = 3 + 1 in (x+4)+x</code>:</p><pre><code class="spec">Let "x" (Add (Num 3) (Num 1))
   (Add (Add (Var "x") (Num 4)) (Var "x")) 
</code></pre><p>變數 <code class="haskell">x</code> 的值為 <code class="haskell">3+1</code>, 因此整個算式的值是 <code class="haskell">((3+1) + 4) + (3+1) = 12</code>.</p><h3 class="subsection" id="sec:var-env-reader">8.3.1 變數與環境</h3><p>有了變數後，我們不能只問「<code class="haskell">Add (Var "x") (Var "y")</code> 的（整數）值是什麼」了，因為我們不知道 <code class="haskell">x</code> 和 <code class="haskell">y</code> 的值。&shy;有自由變數的算式得放在一個<em>環境</em>下才能談它的值。&shy;所謂「環境」是一個變數到值的函數，告訴我們每個變數的值。我們可以用一個串列表示：<input class="toggle" id="footnote-8-3-3" type="checkbox"/><label class="fnote-toggle" for="footnote-8-3-3">(註3) </label><span class="collapsible-footnote">或著，我們也可以定義 <code class="haskell">type Env = Name -&gt; Maybe Int</code>, 而 <code class="haskell">lookup env x = env x</code>.</span></p><pre><code class="spec">type Env = [(Name, Int)] 
</code></pre><p>例如 <code class="haskell">Add (Var "x") (Num 4)</code> 在環境 <code class="haskell">[("x", 3), ("y", 6)]</code> 下的值是 <code class="haskell">7</code>.&shy;我們也假設有一個「查表」函數：</p><pre><code class="spec">lookup :: Env -&gt; Maybe Int 
</code></pre><p>例如，當 <code class="haskell">env = [("x", 3), ("y", 6)]</code>，<code class="haskell">lookup env "x"</code> 是 <code class="haskell">Just 3</code>，&shy;<code class="haskell">lookup env "z"</code> 則是 <code class="haskell">Nothing</code>.</p><p>提醒一下讀者：<code class="haskell">Let</code> 是在宣告區域變數，而不是賦值。例如，下式表達 <code class="haskell">let x = 3 in x + (let x = 4 in x) + (-x)</code>：</p><pre><code class="spec">Let "x" (Num 3)
    (Add (Add "x" (Let "x" (Num 4) (Var "x")))
         (Neg (Var "x")))
</code></pre><p>&shy;它的值是 <code class="haskell">3 + 4 + (-3)</code>，而不是 <code class="haskell">3 + 4 + (-4)</code> --- 內層宣告的 <code class="haskell">x</code> 僅是暫時遮蓋到外面的 <code class="haskell">x</code>。</p><p>有了這些鋪陳，我們看看新的 <code class="haskell">eval</code> 函數該怎麼寫。&shy;既然算式要在環境之下才有值，<code class="haskell">eval</code> 得把環境也納為參數之一：</p><pre><code class="spec">eval :: Expr -&gt; Env -&gt; Int
</code></pre><p>函數 <code class="haskell">eval</code> 拿一個算式和一個環境，計算該算式的值。&shy;新的 <code class="haskell">eval</code> 中，最初的三個條款基本上是一樣的，只是多了一個參數 <code class="haskell">env</code> 得往下傳：</p><pre><code class="spec">eval (Num n)      env = n
eval (Neg e)      env = - (eval e env)
eval (Add e0 e1)  env = eval e0 env + eval e1 env 
</code></pre><p>碰到變數時，我們到環境中查變數的值：</p><pre><code class="spec">eval (Var x) env = case lookup env x of Just v -&gt; return v 
</code></pre><p>這裡的 <code class="haskell">case</code> 算式只處理了 <code class="haskell">Just</code> 的情形。&shy;如果 <code class="haskell">lookup</code> 傳回的是 <code class="haskell">Nothing</code>，也就是變數 <code class="haskell">x</code> 並不在環境 <code class="haskell">env</code> 中，該怎麼辦呢？我們等下再談。&shy;最後，碰到 <code class="haskell">Let x e0 e1</code> 時，我們先把 <code class="haskell">e0</code> 的值在 <code class="haskell">env</code> 這個環境之下算出，然後算 <code class="haskell">e1</code>:</p><pre><code class="spec">eval (Let x e0 e1) env =
  let v = eval e0 env
  in eval e1 ((x, v) : env)
</code></pre><p>但計算 <code class="haskell">e1</code> 時須使用新的環境 <code class="haskell">(x, v) : env</code>，這讓 <code class="haskell">e1</code> 可以用到 <code class="haskell">x</code>。變數 <code class="haskell">x</code> 在新環境中的值是 <code class="haskell">v</code>.</p><p><b>算式的語意是函數</b> &emsp;&shy;第 [RefUndefined] 節開頭提及，&shy;算式沒有變數、沒有除法時，<code class="haskell">eval</code> 的型別是 <code class="haskell">Expr -&gt; Int</code> --- 此時一個算式的「意思」就是一個整數。&shy;有了除法後，為了表示可能拋出例外的函數，<code class="haskell">eval</code> 的型別變成 <code class="haskell">Expr -&gt; Except Int</code>.&shy;此時 <code class="haskell">Except a</code> 代表一個尚待完成、可能有副作用（拋出例外）的計算。</p><p>加上變數、考慮環境後， <code class="haskell">eval</code> 的型別變成了 <code class="haskell">Expr -&gt; (Env -&gt; Int)</code>：<code class="haskell">eval</code> 拿一個算式，傳回一個函數；該函數又拿一個環境，才算出一個整數值。&shy;也就是說，一個算式的語意是「拿一個環境，傳回一個整數的函數」。&shy;的確，既然算式算成的那個整數必須由環境決定，算式其實不能看作一個數值，而應該是從環境到整數的函數才對。&shy;算式 <code class="haskell">eval (Add (Var "x") (Var "y"))</code> 是一個函數，如果給它 <code class="haskell">[("x", 3), ("y", 2)]</code>, 我們得到 <code class="haskell">5</code>;&shy;如果給 <code class="haskell">[("x",4), ("y", -3)]</code>, 我們得到 <code class="haskell">1</code>.</p><p>如果把「給一個環境，傳回型別為 <code class="haskell">a</code> 的結果的函數」叫做 <code class="haskell">Reader a</code>, 也就是說定義 <code class="haskell">type Reader a = Env -&gt; a</code>，&shy;函數 <code class="haskell">eval</code> 的型別成了 <code class="haskell">Expr -&gt; Reader a</code>.&shy;此處，<code class="haskell">Reader a</code> 也可視為一個<em>尚待完成、可能發生副作用的計算</em>。&shy;此處可能的副作用包括「和環境詢問變數的值」。&shy;習慣上，我們把這種副作用稱作「讀者(reader)」或「讀取」。&shy;「給環境」的動作，就是執行運算，把值算出來。&shy;我們把其中兩個條款改寫成 $\lambda$ 算式：</p><pre><code class="spec">eval (Num n)      = \env -&gt;  n
eval (Add e1 e2)  = \env -&gt; eval e1 env + eval e2 env
</code></pre><p>可以理解成：<code class="haskell">eval (Num n)</code> 傳回一個計算，無論環境為何，該計算都傳回 <code class="haskell">n</code>;&shy;<code class="haskell">eval (Add e1 e2)</code> 也傳回一個計算，該計算拿到環境後，在同一個環境之下把 <code class="haskell">eval e1</code> 和 <code class="haskell">eval e2</code> 算成值，然後傳回他們的和。</p><p>然而，手動把 <code class="haskell">env</code> 傳來傳去是個重複性高、容易出錯、也嫌累贅的動作。在第 <a href="Monads.html#sec:exceptions">8.1 </a> 節中，我們把重複性地產生與拆開 <code class="haskell">Except</code> 型別的動作抽象成 <code class="haskell">return</code> 和 <code class="haskell">(&gt;&gt;=)</code>，&shy;使得 <code class="haskell">Except</code> 成為一個單子。&shy;對於本節的 <code class="haskell">Reader</code>, 我們也能設計出一組 <code class="haskell">return</code> 和 <code class="haskell">(&gt;&gt;=)</code>, 把重複的動作抽象掉，使得 <code class="haskell">Reader</code> 成為一個單子嗎？</p><h3 class="subsection" id="sec:reader-is-monad">8.3.2 「讀取」副作用是單子</h3><p><b>讀取單子</b> &emsp; 如第 <a href="Monads.html#sec:monad-class-laws">8.2 </a> 節所述，&shy;<code class="haskell">return</code> 製作一個沒有副作用的計算，<code class="haskell">(&gt;&gt;=)</code> 則用於把兩個計算接起來。&shy;把 <code class="haskell">m</code> 代換成 <code class="haskell">Reader</code>, 它們的型別分別是：</p><pre><code class="spec">return  :: a -&gt; Reader a
(&gt;&gt;=)   :: Reader a -&gt; (a -&gt; Reader b) -&gt; Reader b 
</code></pre><p>其中 <code class="haskell">Reader a = Env -&gt; a</code>.</p><p>函數 <code class="haskell">return</code> 比較單純：<code class="haskell">return x</code> 是一個無論 <code class="haskell">env</code> 是什麼，都傳回 <code class="haskell">x</code> 的計算：</p><pre><code class="spec">return x env = x 
</code></pre><p>至於 <code class="haskell">m &gt;&gt;= f</code> 則可定義如下：</p><pre><code class="spec">(p &gt;&gt;= f) env = f (p env) env 
</code></pre><p><code class="haskell">p &gt;&gt;= f</code> 的型別為 <code class="haskell">Reader b</code>, 意謂它可以收一個環境 <code class="haskell">env</code> 當參數，而等號右手邊必須算出一個型別為 <code class="haskell">b</code> 的結果。&shy;變數 <code class="haskell">p :: Reader a</code> 是一個尚待完成的計算，<code class="haskell">p env</code> 把它算出來，得到型別為 <code class="haskell">a</code> 的結果。&shy;函數 <code class="haskell">f</code> 的型別為 <code class="haskell">a -&gt; Reader b</code>, 因此 <code class="haskell">f (p env)</code> 意謂 <code class="haskell">f</code> 得到 <code class="haskell">p env :: a</code> 的結果，並<em>算出一個新的計算</em>. 這個計算又在得到 <code class="haskell">env</code> 之後才真正被算出來，最後型別為 <code class="haskell">b</code>.</p><p>有了 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code>, <code class="haskell">eval</code> 的前三個條款可改寫如下：</p><pre><code class="spec">eval :: Expr -&gt; Reader Int
eval (Num n)      =  return n
eval (Neg e)      =  eval e &gt;&gt;= \v -&gt; return (-v) 
eval (Add e0 e1)  =  eval e0  &gt;&gt;= \v0 -&gt;
                     eval e1  &gt;&gt;= \v1 -&gt;
                     return (v0 + v1) 
</code></pre><p>除了 <code class="haskell">Except</code> 變成 <code class="haskell">Reader</code> 之外和第 <a href="Monads.html#sec:exceptions">8.1 </a> 節完全相同！&shy;由於使用了單子這個適當的抽象，只要把型別從 <code class="haskell">Except</code> 變成 <code class="haskell">Reader</code>，主程式在不需大幅更動的情況下就可以沿用。使用單子，我們能<em>模組化地挑選我們想要的副作用</em>。</p><p><b>讀取單子的特定運算</b> &emsp;&shy;本節新添加的 <code class="haskell">Var</code> 與 <code class="haskell">Let</code> 兩個情況是第 <a href="Monads.html#sec:exceptions">8.1 </a> 節沒有的。&shy;要處理它們，需要讀取副作用特有的運算子。</p><p>處理 <code class="haskell">Var x</code> 時，<code class="haskell">eval</code> 得到環境中查變數 <code class="haskell">x</code> 的值。&shy;我們姑且先為此專門定義一個函數：</p><pre><code class="spec">lookupVar :: Var -&gt; Reader Int
lookupVar x env = case lookup env x of Just v -&gt; return v 
</code></pre><p>之後再考慮更通用的情況。&shy;有了它，<code class="haskell">eval</code> 遇上 <code class="haskell">Var x</code> 的條款可寫成：</p><pre><code class="spec">eval (Var x) = lookupVar x 
</code></pre><p>計算 <code class="haskell">Let x e1 e2</code> 時，我們需要更動環境，把「<code class="haskell">x</code> 的值是 <code class="haskell">e1</code> 的值」這個資訊加到環境中，&shy;並在新環境內執行 <code class="haskell">eval e2</code>, 但執行完之後就回到原有的環境 --- 新環境只是局部的。&shy;由於這是常見的模式，我們可定義一個更通用的運算子。&shy;給定一個函數 <code class="haskell">f :: Env -&gt; Env</code> 用於製作局部的環境，&shy;如果目前的環境是 <code class="haskell">env</code>, 算式 <code class="haskell">local f p</code> 在新環境 <code class="haskell">f env</code> 之下執行 <code class="haskell">p</code>:</p><pre><code class="spec">local :: (Env -&gt; Env) -&gt; Reader a -&gt; Reader a
local f p env = p (f env) 
</code></pre><p>有了 <code class="haskell">local</code> 的幫忙，<code class="haskell">eval</code> 遇上 <code class="haskell">Let</code> 時可寫成：</p><pre><code class="spec">eval (Let x e0 e1) =  eval e0 &gt;&gt;= \v -&gt;
                      local ((x,v):) (eval e1) 
</code></pre><p>我們用 <code class="haskell">((x,v):)</code> 幫環境增加一筆資料，在這之下計算 <code class="haskell">eval e2</code>.</p><div class="exlist"><div class="exercise exer" id="ex:expand-reader-by-def"><h5 class="exercise-title">練習 8.2 </h5><p>使用本節的定義，將 <code class="haskell">eval (Add e0 e1) env</code> 與 <code class="haskell">eval (Let x e0 e1) env</code> 展開，確認它們和第 <a href="Monads.html#sec:var-env-reader">8.3.1 </a> 節的定義一樣。意即：</p><pre><code class="spec">eval (Add e0 e1)    env = eval e0 env + eval e1 env 
eval (Let x e0 e1)  env = eval e1 ((x, eval e0 env):env)  
</code></pre></div><div class="wrap-collabsible"><input class="toggle" id="ans-8-2" type="checkbox"/><label class="lbl-toggle" for="ans-8-2">顯示答案</label><div class="collapsible-content"><h5>答案</h5><p>考慮 <code class="haskell">eval (Add e0 e1)</code>:</p><pre><code class="spec">     eval (Add e0 e1) env
===     <comment>{- <code class="haskell">eval</code> 之定義 -}</comment>
     (eval e0  &gt;&gt;= \v0 -&gt; eval e1  &gt;&gt;= \v1 -&gt; return (v0 + v1)) env
===     <comment>{- <code class="haskell">(&gt;&gt;=)</code> 之定義 -}</comment>
     (\v0 -&gt; eval e1 &gt;&gt;= \v1 -&gt; return (v0 + v1)) (eval e0 env) env
===     <comment>{- 函數應用 -}</comment>
     (eval e1 &gt;&gt;= \v1 -&gt; return (eval e0 env + v1)) env
===     <comment>{- <code class="haskell">(&gt;&gt;=)</code> 之定義, 函數應用 -}</comment>
     return (eval e0 env + eval e1 env) env
===     <comment>{- <code class="haskell">return</code> 之定義 -}</comment>
     eval e0 env + eval e1 env 
</code></pre><p>考慮 <code class="haskell">eval (Let x e0 e1) env</code>:</p><pre><code class="spec">     eval (Let x e0 e1) env
===     <comment>{- <code class="haskell">eval</code> 之定義 -}</comment>
     (eval e0 &gt;&gt;= \v -&gt; local ((x,v):) (eval e1)) env
===     <comment>{- <code class="haskell">(&gt;&gt;=)</code> 之定義, 函數應用 -}</comment>
     local ((x,eval e0 env):) (eval e1) env
===     <comment>{- <code class="haskell">local</code> 之定義 -}</comment>
     eval e1 ((x, eval e0 env):env)  
</code></pre></div></div></div><p><b>更通用的環境單子</b> &emsp;&shy;為了說明方便，目前為止我們假設「環境」是某個固定的型別: <code class="haskell">Env</code>.&shy;我們當然可以把這部份也抽象掉：</p><pre><code class="spec">type Reader e a = e -&gt; a  
</code></pre><p>現在 <code class="haskell">Reader</code> 多吃一個參數 <code class="haskell">e</code>, 代表環境的型別。&shy;對任意的 <code class="haskell">e</code>, <code class="haskell">Reader e</code> 都是一個單子，&shy;函數 <code class="haskell">local</code> 更通用的型別是 <code class="haskell">(e -&gt; e) -&gt; Reader e a -&gt; Reader e a</code>.&shy;本節之前的每個 <code class="haskell">Reader</code> 都需代換成 <code class="haskell">Reader Env</code>.&shy;例如 <code class="haskell">eval</code> 的型別是 <code class="haskell">Expr -&gt; Reader Env Int</code>.&shy;但改變的都只有型別，程式不需變動。</p><p>函數 <code class="haskell">lookupVar :: Var -&gt; Reader Env Int</code> 只能在 <code class="haskell">e</code> 為 <code class="haskell">Env</code> 的情況下運作。&shy;更一般來說，讀取單子通常會有一個運算子 <code class="haskell">ask</code>, 把整個環境傳出來供我們使用：</p><pre><code class="spec">ask :: Reader e e
ask env = env 
</code></pre><p>函數 <code class="haskell">lookupVar</code> 則可改用 <code class="haskell">ask</code> 定義為：</p><pre><code class="spec">lookupVar :: Var -&gt; Reader Int
lookupVar x =  ask &gt;&gt;= \env -&gt;
               case lookup env x of Just v -&gt; return v 
</code></pre><p>最後，本節之中讓 <code class="haskell">Reader e</code> 與前一節的 <code class="haskell">Except</code> 共用 <code class="haskell">return</code>, <code class="haskell">(&gt;&gt;=)</code> 等符號。&shy;若需在 Haskell 中如此，我們得將 <code class="haskell">Reader e</code> 宣告為 type class <code class="haskell">Monad</code> 的一個特例。&shy;但由於一些型別檢查的技術問題， Haskell 不允許用 <code class="haskell">type</code> 宣告的別名成為 type class 特例。&shy;我們得把 <code class="haskell">Reader</code> 用 <code class="haskell">data</code> 宣告成一個資料型別：<input class="toggle" id="footnote-8-3-4" type="checkbox"/><label class="fnote-toggle" for="footnote-8-3-4">(註4) </label><span class="collapsible-footnote">更普遍的做法是用 <code class="haskell">newtype</code> 宣告：<code class="haskell">newtype Reader e a = Reader { runReader :: (e -&gt; a) }</code>. 但本書不談 <code class="haskell">newtype</code>.</span></p><pre><code class="spec">data Reader e a = Reader (e -&gt; a) 

instance Monad (Reader e) where
    return a        = Reader (\e -&gt; a)
    Reader r &gt;&gt;= f  = Reader (\e -&gt; f (r e) e) 
</code></pre><h3 class="subsection" id="sec:monad-reader-laws">8.3.3 推論讀取單子程式的性質</h3><p>給一個單子程式，如何討論它的性質？&shy;比如說，對某一個 <code class="haskell">e</code>, 如何得知 <code class="haskell">eval</code> <code class="haskell">(Let "x" (Num 3)</code> <code class="haskell">(Let "y" (Num 4) e))</code>&shy;的值是什麼？&shy;它和 <code class="haskell">eval</code> <code class="haskell">(Let "y" (Num 4)</code> <code class="haskell">(Let "x" (Num 3) e))</code> 的值是否總是相等？</p><p>由於 <code class="haskell">eval</code> 是用 <code class="haskell">return</code>, <code class="haskell">(&gt;&gt;=)</code>, <code class="haskell">local</code> ... 等等運算子定義出來的，而這幾個運算子的定義也都已經有了，&shy;我們總是可以把他們的定義都展開，&shy;回到最基礎的層次證明任何我們想確認的性質。&shy;但一來如此的證明可能非常瑣碎，二來 <code class="haskell">return</code>, <code class="haskell">(&gt;&gt;=)</code> 等運算子的定義可能還會改變。&shy;我們是否能在稍微抽象一點的層次運作，假裝我們不知道這些單子運算子的定義，只討論它們具有什麼性質，並用這些性質來做證明？</p><p>我們應可以合理要求一個「正確」的讀取單子實作應該要滿足下列的性質。&shy;首先，假設 <code class="haskell">e</code> 是一個不含變數 <code class="haskell">v</code> 的算式：</p><pre><code class="equation" id="eq:reader-ask-return">|ask &gt;&gt;= \v -&gt; return e = return e | \mbox{如果 |v| 不出現在 |e| 之中。}</code>    (8.1 )
</pre><p>等號兩邊都只是傳回 <code class="haskell">e</code> 的值，而 <code class="haskell">e</code> 的值不受 <code class="haskell">v</code> 影響，因此 <code class="haskell">ask</code> 是可以省略掉的。&shy;其次，連續使用 <code class="haskell">ask</code> 兩次可以縮減為一次就好：</p><pre><code class="equation" id="eq:reader-ask-ask">|ask &gt;&gt;= \v0 -&gt; ask &gt;&gt;= \v1 -&gt; f v0 v1 <comment>{-"~~"-}</comment>=<comment>{-"~~"-}</comment> ask &gt;&gt;= \v -&gt; f v v |</code>    (8.2 )
</pre><p>在等號左手邊，我們把問了環境兩次之後的計算抽象為一個函數呼叫 <code class="haskell">f v0 v1</code>.&shy;在右手邊我們則讓 <code class="haskell">f</code> 的兩個參數都是 <code class="haskell">v</code> --- 詢問環境一次的結果。</p><p>下面兩個式子討論當 <code class="haskell">local</code> 遇上 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 時會如何：</p><div class="equations"><ul><li><p id="eq:reader-local-return"> <code class="haskell">local g (return e)</code> <code class="haskell">= return e</code></p></li><li><p id="eq:reader-local-bind"> <code class="haskell">local g (p &gt;&gt;= f)</code> <code class="haskell">= local g p &gt;&gt;= (local g . f)</code></p></li></ul></div><p>在 ([RefUndefined]) 的左手邊，改變環境之後立刻 <code class="haskell">return e</code>, 其實和單純做 <code class="haskell">return e</code> 一樣。&shy;性質 ([RefUndefined]) 則告訴我們 <code class="haskell">local g</code> 可以分配到 <code class="haskell">(&gt;&gt;=)</code> 的兩側。由於型別之故，<code class="haskell">(&gt;&gt;=)</code> 的左邊是 <code class="haskell">local g p</code>, 右邊則得用函數合成 <code class="haskell">(.)</code>.</p><p>最後，下列性質將 <code class="haskell">local</code> 與 <code class="haskell">ask</code> 關聯在一起：</p><pre><code class="equation" id="eq:reader-local-ask">|local g ask = ask &gt;&gt;= (return . g) |</code>    (8.3 )
</pre><p>在 <code class="haskell">local g</code> 的環境之下做 <code class="haskell">ask</code>, 相當於先做 <code class="haskell">ask</code>, 然後把得到的環境交給 <code class="haskell">g</code> 加工。&shy;我們可說算式 ([RefUndefined]) 藉由這兩個運算子的互動定義出了 <code class="haskell">local</code> 的「意思」。</p><p>有了這些性質，我們不需引用 <code class="haskell">local</code>, <code class="haskell">ask</code>, <code class="haskell">(&gt;&gt;=)</code> ... 等等的定義，也可論證讀取單子程式的性質了。例如，我們來看看 <code class="haskell">let x = 4 in x + x</code> 的值會是什麼：</p><pre><code class="spec">     eval (Let "x" (Num 4) (Add (Var "x") (Var "x")))
===    <comment>{- <code class="haskell">eval</code> 之定義 -}</comment>
     eval (Num 4) &gt;&gt;= \v -&gt; local (("x",v):) (eval (Add (Var "x") (Var "x")))
===    <comment>{- <code class="haskell">eval</code> 之定義 -}</comment>
     return 4 &gt;&gt;= \v -&gt; local (("x",v):) (eval (Add (Var "x") (Var "x")))
===    <comment>{- 單子律：左單位律 \eqref{eq:monad-left-id} -}</comment>
     local (("x",4):) (eval (Add (Var "x") (Var "x")))
===    <comment>{- <code class="haskell">eval</code> 之定義 -}</comment>
     local (("x",4):) (  eval (Var "x") &gt;&gt;= \v0 -&gt;
                         eval (Var "x") &gt;&gt;= \v1 -&gt; return (v0 + v1))
===    <comment>{- \eqref{eq:reader-local-bind} -}</comment>
     local (("x",4):) (eval (Var "x")) &gt;&gt;= \v0 -&gt;
     local (("x",4):) (eval (Var "x")) &gt;&gt;= \v1 -&gt;
     local (("x",4):) (return (v0 + v1))
</code></pre><p>我們將 <code class="haskell">local (("x",4):) (eval (Var "x"))</code> 抽出來化簡：</p><pre><code class="spec">    local (("x",4):) (eval (Var "x"))
===   <comment>{- <code class="haskell">eval</code> 與 <code class="haskell">lookupVar</code> 之定義 -}</comment>
    local (("x",4):) (ask &gt;&gt;= \env -&gt; case lookup env "x" of Just v -&gt; return v)
===   <comment>{- \eqref{eq:reader-local-bind} -}</comment>
    local (("x",4):) ask &gt;&gt;= \env -&gt;
    local (("x",4):) (case lookup env "x" of Just v -&gt; return v)
===   <comment>{- \eqref{eq:reader-local-ask}, 左單位律 \eqref{eq:monad-left-id} -}</comment>
    local (("x",4):) (case lookup (("x",4):env) "x" of Just v -&gt; return v)
===   <comment>{- <code class="haskell">lookup (("x",4):env) "x" = Just 4</code> -}</comment>
    local (("x",4):) (return 4)
===   <comment>{- \eqref{eq:reader-local-return} -}</comment>
    return 4 
</code></pre><p>由此我們得知 <code class="haskell">local (("x",4):) (eval (Var "x"))</code> 就是 <code class="haskell">return 4</code>.&shy;將它放回原式中：</p><pre><code class="spec">     local (("x",4):) (eval (Var "x")) &gt;&gt;= \v0 -&gt;
     local (("x",4):) (eval (Var "x")) &gt;&gt;= \v1 -&gt;
     local (("x",4):) (return (v0 + v1))
===   <comment>{- 前述計算 -}</comment>
     return 4 &gt;&gt;= \v0 -&gt; return 4 &gt;&gt;= \v1 -&gt; return (v0 + v1)
===   <comment>{- 單子律：左單位律 \eqref{eq:monad-left-id} -}</comment>
     return (4 + 4) 
</code></pre><p>因此，<code class="haskell">eval (Let "x" (Num 4) (Add (Var "x") (Var "x")))</code> 就是 <code class="haskell">return 8</code>.</p><p>提醒讀者注意一點：<code class="haskell">eval (Let "x" (Num 4) (Add (Var "x") (Var "x")))</code> 和 <code class="haskell">return 8</code> 都不是基礎型別，而是「尚待完成的計算」。&shy;論證單子程式時我們常常不是在基礎型別的層次上運作，而是證明一個計算與另一個計算是等價的。&shy;這意味著它們傳回同樣的值，也發生同樣的副作用。&shy;我們日後會看到更多此類的例子。</p><div class="exlist"><div class="exercise exer"><h5 class="exercise-title">練習 8.3 </h5><p>證明對所有 <code class="haskell">e :: Expr</code>,</p><pre><code class="spec">  eval (Let "x" (Num 3) (Let "y" (Num 4) e)) =
    eval (Let "y" (Num 4) (Let "x" (Num 3) e)) 
</code></pre><p>如果 <code class="haskell">(("x",3):) . (("y",4):) = (("y",4):) . (("x",3):)</code> 成立。</p></div><div class="exercise exer"><h5 class="exercise-title">練習 8.4 </h5><p>然而，<code class="haskell">(("x",3):) . (("y",4):) = (("y",4):) . (("x",3):)</code> 並不成立。</p></div></div><p>我們稍早曾遇到這個問題：如果給這樣的式子 <code class="haskell">eval (Var "x") [("y",0)]</code>,&shy;變數 <code class="haskell">x</code> 並不在環境中，<code class="haskell">lookup</code> 將傳回 <code class="haskell">Nothing</code>，這時該怎麼辦？</p><p>我們可以再擴充 <code class="haskell">Reader</code> 的型別，讓 <code class="haskell">eval</code> 也可以傳回一個 <code class="haskell">Except</code> 結果：</p><pre><code class="spec">type ReaderExcept e a = e -&gt; Except a
</code></pre><p>而 <code class="haskell">return</code> 和 <code class="haskell">(&gt;&gt;=)</code> 也得隨之擴充：</p><pre><code class="spec">return a = \env -&gt; Just a
rm &gt;&gt;= f = \env -&gt; case rm env of
                    Just v -&gt; f v env
                    Nothing -&gt; Nothing
</code></pre><p>這個 <code class="haskell">ReaderExcept</code> 型別綜合了讀取單子與例外單子的功能，其 <code class="haskell">return</code> 與 <code class="haskell">(&gt;&gt;=)</code> 定義也像是兩個單子定義的混合。&shy;但這並不是令人相當滿意的做法。<code class="haskell">ReaderExcept</code> 比起 <code class="haskell">Reader</code> 又更複雜了一點。日後我們也許會想要有更多功能，例如狀態、輸出入等。<code class="haskell">ReaderExcept</code> 已經夠抽象難解了，我們並不希望設計、維護越來越龐大的單子。</p><p>既然 Maybe 單子讓一個程式加上「例外」的副作用，讀取單子讓一個程式加上可存取環境的功能，我們能否把這兩項功能分別模組化地加入呢？</p><p>也就是說，給了兩個單子 M1 和 M2, 能否把他們的功能加在一起，產生另一個新單子呢？</p><h2 class="section" id="sec:monad-state">8.4 狀態單子</h2><p><span id="ix-8-10"></span></p><p>沿用第 <a href="Monads.html#sec:exceptions">8.1 </a> 節之中的型別：</p><pre><code class="spec">data Expr = Num Int | Neg Expr | Add Expr Expr | Div Expr Expr  
</code></pre><p>這次我們暫且忽略分母為零的可能，而考慮另一個應用：我們想知道計算過程中做了多少次除法。&shy;指令式語言中，一個常見的作法是用一個可變變數來計數。&shy;在函數語言中我們怎麼模擬這種行為呢？</p><p>在指令式語言中，可變變數的值常用來表示整個系統目前的「狀態(state)」：諸如已處理過的資料個數、處理中的元素號碼、棋盤上每個棋子的位置... 等等。因此我們把「存取可變變數」的能力稱作<em>狀態</em>(<em>state</em>)副作用。</p><p>經過前幾節的熟悉，我們現在應可以更抽象地、<em>由上而下</em>地想像單子了：對於一個我們需要的副作用，先假設其單子存在，考慮它該有哪些運算子、這些運算子該滿足什麼性質、用它們如何寫程式。&shy;然後才考慮這個單子的實作。對於狀態這個副作用，我們該怎麼設計其運算子呢？</p><p>在命令式語言中，<code class="haskell">x := x + 1</code> 這行指令把可變變數 <code class="haskell">x</code> 的值遞增。這一行看似單純的指令其實包含幾項特性：</p><ul><li><p>變數是有名字的；</p></li><li><p>當變數名字出現在 <code class="haskell">:=</code> 的右手邊，表示讀取變數的值；</p></li><li><p>當變數名字出現在 <code class="haskell">:=</code> 的左手邊，表示將值寫入該變數。</p></li></ul><p>函數語言中討論狀態副作用時偏好用單純些、使用時比較繁瑣、但比較好討論性質的設計：變數沒有名字，並且把「讀取」與「寫入」兩個動作分為單獨的運算子。</p><p>具體說來，令 <code class="haskell">State s a</code> 表示一個結果型別為 <code class="haskell">a</code>, 但在執行時可讀寫一個型別為 <code class="haskell">s</code> 的可變變數的計算。我們要求 <code class="haskell">State s</code> 是一個單子 --- 意謂存在著滿足單子律的&shy;<code class="haskell">return :: a -&gt; State s a</code> 和 <code class="haskell">(&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b</code>。&shy;一個型別為 <code class="haskell">State s a</code> 的運算中隱藏的可變變數沒有名字，只能用下述兩個運算子存取：</p><pre><code class="spec">get  :: State s s  
put  :: s -&gt; State s () 
</code></pre><p>運算子 <code class="haskell">get</code> 和第 <a href="Monads.html#sec:monad-reader">8.3 </a> 節中的 <code class="haskell">ask</code> 類似，讀出該可變變數的值；<code class="haskell">put e</code> 則把 <code class="haskell">e</code> 的值寫到可變變數中，並傳回 <code class="haskell">()</code>。&shy;例如，當 <code class="haskell">s = Int</code>, 我們可以定義如下的操作 <code class="haskell">inc</code>，把可變變數加一：</p><pre><code class="spec">inc :: State Int ()
inc = get &gt;&gt;= \v -&gt; put (1+v) 
</code></pre><p>關於 <code class="haskell">put</code> 有幾件事情可提醒。首先，當我們呼叫 <code class="haskell">put e</code>, 其中的 <code class="haskell">e</code> 已經是一個型別為 <code class="haskell">s</code> 的純數值，不含副作用。&shy;例如在 <code class="haskell">inc</code> 之中，我們必須先將變數的值 <code class="haskell">get</code> 出來（這是一個有副作用的動作），才能計算新的值並寫回去。&shy;這讓程式寫起來很繁瑣，但也使得推論程式的性質容易許多。&shy;其次，關於 <code class="haskell">put e</code> 的型別 <code class="haskell">State s ()</code>. 回想：<code class="haskell">()</code> 是一個只有一個值的型別，該值在 Haskell 中也寫作 <code class="haskell">()</code>. 給定 <code class="haskell">e :: s</code> 後，<code class="haskell">put e :: State s ()</code> 是一個會存取型別為 <code class="haskell">s</code> 的可變變數，並傳回 <code class="haskell">()</code> 的計算。在此，「傳回 <code class="haskell">()</code>」可理解為傳回一個不帶資訊的值，僅表達「我做完了」。</p><p>這個傳回值既然沒有資訊，通常不會被用上。因此當 <code class="haskell">put</code> 不是函數的最後一個動作時，程式常有如下的模樣：</p><pre><code class="spec">   ... put e &gt;&gt;= \_ -&gt; ...
</code></pre><p>由於「執行一段程式，但只需要它的副作用，不需要它的結果」這件事在本章還會常常發生，我們另外訂一個運算元：</p><pre><code class="spec">(&gt;&gt;) :: m a -&gt; m b -&gt; m b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q 
</code></pre><p>如此一來 <code class="haskell">put e &gt;&gt;= \_ -&gt; q</code> 可以簡寫成 <code class="haskell">put e &gt;&gt; q</code>.&shy;（注意： <code class="haskell">p &gt;&gt; q</code> 並不要求 <code class="haskell">p</code> 的傳回值型別為 <code class="haskell">()</code>.）</p><p>回到 <code class="haskell">get</code> 與 <code class="haskell">put</code>。&shy;如果它們的某個實作確實表達了我們前面口述的意圖，該實作應該會滿足以下的規則：</p><div class="equations"><ul><li><p id="eq:state-get-put"><b>get-put:</b> &emsp;&shy;<code class="haskell">get &gt;&gt;= put</code> <code class="haskell">= return () </code></p></li><li><p id="eq:state-put-get"><b>put-get:</b> &emsp;&shy;<code class="haskell">put e &gt;&gt; get</code> <code class="haskell">= put e &gt;&gt; return e </code></p></li><li><p id="eq:state-put-put"><b>put-put:</b> &emsp;&shy;<code class="haskell">put e0 &gt;&gt; put e1</code> <code class="haskell">= put e1 </code></p></li></ul></div><p>以及一個和第 <a href="Monads.html#sec:monad-reader">8.3 </a> 節中的 <code class="haskell">ask</code> 類似的性質：</p><pre><code class="equation" id="eq:state-get-get" title="get-get:">|get &gt;&gt;= \v0 -&gt; get v1 &gt;&gt;= \v1 -&gt; f v0 v1  =  get &gt;&gt;= \v -&gt; f v v |</code>    (8.4 )
</pre><p>其中，<strong>get-put</strong> 意謂：將可變變數的值讀出後立刻寫入相當於什麼都不做。&shy;規則 <strong>put-get</strong> 意謂：剛做完 <code class="haskell">put e</code> 之後立刻讀取可變變數的值，必定得到 <code class="haskell">e</code>.&shy;規則 <strong>put-put</strong> 意謂：連做兩個 <code class="haskell">put</code> 之後，只有第二個 <code class="haskell">put</code> 寫入的值會被留下。&shy;規則 <strong>get-get</strong> 則意謂：連做兩次 <code class="haskell">get</code> 所得到的值必定相同，可以只 <code class="haskell">get</code> 一次就好。</p><p>如前所述，用 <code class="haskell">get</code> 與 <code class="haskell">put</code> 可定義出 <code class="haskell">inc</code>, 而我們只需在 <code class="haskell">eval</code> 遇到 <code class="haskell">Div</code> 的情況中呼叫 <code class="haskell">inc</code>，就可記錄做了多少次除法了：</p><pre><code class="spec">eval (Div e0 e1) =  eval e1  &gt;&gt;= \v1 -&gt;
                    eval e0  &gt;&gt;= \v0 -&gt;
                    inc &gt;&gt;
                    return (v0 `div` v1) 
</code></pre><p>函數 <code class="haskell">eval</code> 的其他條款可完全不變，只需把所用單子的型別改成 <code class="haskell">State Int</code>.&shy;由於單子捕捉了含副作用的程式的共通模式，我們只需選用不同的副作用運算子，就可在不更動大部分程式的情況下使用我們需要的副作用。</p><h3 class="subsection" id="sec:hanoi">8.4.1 河內塔問題</h3><p>本節以河內塔問題為例子，示範狀態單子的推論。</p><pre><code class="spec">hanoi 0        = return ()
hanoi (Suc n)  = hanoi n &gt;&gt; inc &gt;&gt; hanoi n 
</code></pre><p><code class="haskell">hanoi n = put (2^n -1)</code>.</p><h2 class="section">8.5 參考資料</h2><p><a href="Biblio.html#Wadler:92:Monads">Wadler [1992]</a></p></div></div></div>

<script src="../js/ui.js"></script>

</body>
</html>
